<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on abril, 9 2015 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.36.0: 35. Conjuntos</title>

<meta name="description" content="Manual de Maxima 5.36.0: 35. Conjuntos">
<meta name="keywords" content="Manual de Maxima 5.36.0: 35. Conjuntos">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Conjuntos"></a>
<a name="SEC190"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_34.html#SEC189" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC191" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_34.html#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 35. Conjuntos </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC191">35.1 Introducción a los conjuntos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC196">35.2 Funciones y variables para los conjuntos</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">       
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-los-conjuntos"></a>
<a name="SEC191"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC190" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC192" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC190" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC190" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 35.1 Introducción a los conjuntos </h2>

<p>Maxima dispone de funciones para realizar operaciones con conjuntos, como la intersección o la unión. Los conjuntos deben ser finitos y definidos por enumeración. Maxima trata a los conjuntos y a las listas como objectos de distinta naturaleza, lo que permite trabajar con conjuntos cuyos elementos puedan ser también conjuntos o listas.
</p>
<p>Además de funciones para operar con conjuntos finitos, Maxima dispone también de algunas funciones sobre combinatoria, como los números de Stirling de primera y segunda especie, números de Bell, coeficientes multinomiales, particiones de enteros no negativos y algunos otros. Maxima también define la función delta de Kronecker.
</p>

<hr size="6">
<a name="SEC192"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC191" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC193" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC190" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC191" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.1 Utilización </h3>

<p>Para construir un conjunto cuyos elementos sean <code>a_1, ..., a_n</code>, se utiliza la instrucción  <code>set(a_1, ..., a_n)</code> o <code>{a_1, ..., a_n}</code>; para formar un conjunto vacío, basta con hacer <code>set()</code> o <code>{}</code>. Para introducir conjuntos en Maxima, <code>set (...)</code> y <code>{ ... }</code> son equivalentes. Los conjuntos se muestran siempre con llave.
</p>
<p>Si un elemento se indica más de una vez, el proceso 
de simplificación elimina los elementos redundantes.
</p>
<pre class="example">(%i1) set();
(%o1)                          {}
(%i2) set(a, b, a);
(%o2)                        {a, b}
(%i3) set(a, set(b));
(%o3)                       {a, {b}}
(%i4) set(a, [b]);
(%o4)                       {a, [b]}
(%i5) {};
(%o5)                          {}
(%i6) {a, b, a};
(%o6)                        {a, b}
(%i7) {a, {b}};
(%o7)                       {a, {b}}
(%i8) {a, [b]};
(%o8)                       {a, [b]}
</pre>

<p>Dos elementos candidatos a formar parte de un conjunto, <var>x</var> e <var>y</var>,
son redundantes, esto es, se consideran el mismo elemento a 
efectos de consruir el conjunto, si y sólo si <code>is (<var>x</var> = <var>y</var>)</code>
devuelve el valor <code>true</code>. Nótese que <code>is (equal (<var>x</var>, <var>y</var>))</code>
puede devolver <code>true</code> y <code>is (<var>x</var> = <var>y</var>)</code> retornar
<code>false</code>; en cuyo caso los elementos <var>x</var> e <var>y</var> se
considerarían distintos.
</p>
<pre class="example">(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) {x, y, z};
                          b + a  b   a
(%o9)                    {-----, - + -}
                            c    c   c
</pre>

<p>Para formar un conjunto a partir de los miembros de una lista úsese <code>setify</code>.
</p>
<pre class="example">(%i1) setify([b, a]);
(%o1)                        {a, b}
</pre>
<p>Los elementos <code>x</code> e <code>y</code> de un conjunto se consideran iguales si <code>is(x = y)</code> devuelve el valor <code>true</code>. Así, <code>rat(x)</code> y <code>x</code> se consideran el mismo elemento de un conjunto; consecuentemente, 
</p>
<pre class="example">(%i1) {x, rat(x)};
(%o1)                          {x}
</pre>
<p>Además, puesto que  <code>is((x-1)*(x+1) = x^2 - 1)</code> devuelve <code>false</code>,  <code>(x-1)*(x+1)</code> y <code>x^2-1</code> se consideran elementos diferentes; así
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
</pre>
<p>Para reducir este conjunto a otro unitario, aplicar <code>rat</code> a cada elemento del conjunto:
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
(%i2) map (rat, %);
                              2
(%o2)/R/                    {x  - 1}
</pre>
<p>Para eliminar redundancias con otros conjuntos, será necesario utilizar otras funciones de simplificación. He aquí un ejemplo que utiliza  <code>trigsimp</code>:
</p>
<pre class="example">(%i1) {1, cos(x)^2 + sin(x)^2};
                            2         2
(%o1)                {1, sin (x) + cos (x)}
(%i2) map (trigsimp, %);
(%o2)                          {1}
</pre>
<p>Se entiende que un conjunto está simplificado cuando entre sus elementos no hay redundancias y se hayan ordenados. La versión actual de las funciones para conjuntos utiliza la función <code>orderlessp</code> de Maxima para ordenar sus elementos; sin embargo, <i>futuras versiones de las funciones para operar con conjuntos podrán utilizar otras funciones de ordenación</i>.
</p>
<p>Algunas operaciones con conjuntos, tales como la sustitución, fuerzan automáticamente una re-simplificación; por ejemplo,
</p>
<pre class="example">(%i1) s: {a, b, c}$
(%i2) subst (c=a, s);
(%o2)                        {a, b}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          {x}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        {0, 1}
</pre>
<p>Maxima considera a las listas y conjuntos como objetos diferentes;
funciones tales como <code>union</code> y <code>intersection</code> emitirán
un error si alguno de sus argumentos no es un conjunto. Si se 
necesita aplicar una función de conjunto a una lista, se deberá 
utilizar la función <code>setify</code> para convertirla previamente en conjunto. 
Así,
</p>
<pre class="example">(%i1) union ([1, 2], {a, b});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), {a, b});
(%o2)                     {1, 2, a, b}
</pre>
<p>Para extraer todos los elementos de un conjunto <code>s</code> que satisfagan un predicado <code>f</code>, úsese <code>subset(s,f)</code>. (Un <i>predicado</i> es una función booleana.) Por ejemplo, para encontrar las ecuaciones en un conjunto dado que no dependan de la variable <code>z</code>, se hará
</p>
<pre class="example">(%i1) subset ({x + y + z, x - y + 4, x + y - 5},
              lambda ([e], freeof (z, e)));
(%o1)               {- y + x + 4, y + x - 5}
</pre>
<p>La sección <code>Funciones y variables para los conjuntos</code> incluye una lista completa de funciones para operar con conjuntos en  Maxima.
</p>
<hr size="6">
<a name="SEC193"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC192" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC194" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC190" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC191" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.2 Iteraciones con elementos </h3>

<p>Hay dos formas para operar iterativamente sobre los elementos de un conjunto. Una es utilizar <code>map</code>; por ejemplo:
</p>
<pre class="example">(%i1) map (f, {a, b, c});
(%o1)                  {f(a), f(b), f(c)}
</pre>
<p>La otra forma consiste en hacer uso de la construcción <code>for <var>x</var> in <var>s</var> do</code>
</p>
<pre class="example">(%i1) s: {a, b, c};
(%o1)                       {a, b, c}
(%i2) for si in s do print (concat (si, 1));
a1 
b1 
c1 
(%o2)                         done
</pre>
<p>Las funciones de Maxima  <code>first</code> y <code>rest</code> funcionan también con conjuntos.  En este caso, <code>first</code> devuelve el primer elemento que se muestra del conjunto, el cual puede depender de la implementación del sistema. Si <code>s</code> es un conjunto, entonces <code>rest(s)</code> equivale a <code>disjoin (first(s), s)</code>. Hay otras funciones que trabajan correctamente con conjuntos. En próximas versiones de las funciones para operar con conjuntos es posible que <code>first</code> y <code>rest</code> trabajen de modo diferente o que ya no lo hagan en absoluto.
</p>
<hr size="6">
<a name="SEC194"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC193" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC195" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC190" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC191" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.3 Fallos </h3>

<p>Las funciones para operar con conjuntos utilizan la función <code>orderlessp</code>
de Maxima para ordenar los elementos de los conjuntos, así
como la función <code>like</code> de Lisp para decidir sobre la igualdad de dichos
elementos. Ambas funciones tienen fallos que son conocidos y que pueden
aflorar si se trabaja con conjuntos que tengan elementos en formato de
listas o matrices y que contengan expresiones racionales canónicas (CRE).
Un ejemplo es
</p>
<pre class="example">(%i1) {[x], [rat (x)]};
Maxima encountered a Lisp error:

  The value #:X1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>Esta expresión provoca una parada de Maxima junto con la 
emisión de un mensaje de error, el cual dependerá de 
la versión de Lisp que utilice Maxima. Otro ejemplo es
</p>
<pre class="example">(%i1) setify ([[rat(a)], [rat(b)]]);
Maxima encountered a Lisp error:

  The value #:A1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>Estos fallos son causados por fallos en  <code>orderlessp</code> y <code>like</code>,
no por fallos cuyo origen se encuentre en las funciones para conjuntos.
Para ilustrarlo, se pueden ejecutar las siguientes expresiones
</p>
<pre class="example">(%i1) orderlessp ([rat(a)], [rat(b)]);
Maxima encountered a Lisp error:

  The value #:B1441 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i2) is ([rat(a)] = [rat(a)]);
(%o2)                         false
</pre>
<p>Hasta que estos errores no se corrijan, no es aconsejable construir conjuntos que tengan por elementos listas o matrices que contengan expresiones en forma CRE; sin embargo, un conjunto con elementos de la forma CRE no deberían dar problemas:
</p>
<pre class="example">(%i1) {x, rat (x)};
(%o1)                          {x}
</pre>
<p>La función <code>orderlessp</code> de Maxima tiene otro fallo que puede causar problemas con las funciones para conjuntos, en concreto, que el predicado de ordenación <code>orderlessp</code> no es transitivo. El ejemplo más simple que ilustra este punto es
</p>
<pre class="example">(%i1) q: x^2$
(%i2) r: (x + 1)^2$
(%i3) s: x*(x + 2)$
(%i4) orderlessp (q, r);
(%o4)                         true
(%i5) orderlessp (r, s);
(%o5)                         true
(%i6) orderlessp (q, s);
(%o6)                         false
</pre>
<p>El fallo puede causar problemas con todas las funciones para conjuntos,
así como también con otras funciones de Maxima.
Es probable, pero no seguro, que este fallo se puede evitar si todos 
los elementos del conjunto están en la forma de expresión racional
canónica (CRE) o han sido simplificados con <code>ratsimp</code>.
</p>
<p>Los mecanismos <code>orderless</code> y <code>ordergreat</code> de Maxima son incompatibles
con las funciones para conjuntos. Si se necesitan utilizar <code>orderless</code> o
<code>ordergreat</code>, hágase antes de construir los conjuntos y no se utilice 
la instrucción <code>unorder</code>.
</p>
<p>Se ruega a todo usuario que crea haber encontrado un fallo en las funciones para conjuntos que lo comunique en la base de datos de Maxima. Véase <code>bug_report</code>.
</p>
<hr size="6">
<a name="SEC195"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC194" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC190" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC191" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.4 Autores </h3>

<p>Stavros Macrakis de Cambridge, Massachusetts y Barton Willis de la University of Nebraska at Kearney (UNK).
</p>
<hr size="6">
<a name="Funciones-y-variables-para-los-conjuntos"></a>
<a name="SEC196"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC195" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC190" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC190" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 35.2 Funciones y variables para los conjuntos </h2>


<dl>
<dt><u>Función:</u> <b>adjoin</b><i> (<var>x</var>, <var>a</var>) </i>
<a name="IDX1415"></a>
</dt>
<dd><p>Calcula la unión del conjunto <var>a</var> y <code>{<var>x</var>}</code>.
</p>
<p>La función <code>adjoin</code> emite un mensaje de error si <var>a</var>
no es un conjunto literal.
</p>
<p>Las sentencias <code>adjoin(<var>x</var>, <var>a</var>)</code> y 
<code>union(set(<var>x</var>), <var>a</var>)</code> son equivalentes, aunque
<code>adjoin</code> puede ser algo más rápida que <code>union</code>.
</p>
<p>Véase también <code>disjoin</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) adjoin (c, {a, b});
(%o1)                       {a, b, c}
(%i2) adjoin (a, {a, b});
(%o2)                        {a, b}
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>belln</b><i> (<var>n</var>)</i>
<a name="IDX1416"></a>
</dt>
<dd><p>Representa el <em>n</em>-ésimo número de Bell, de
modo que <code>belln(n)</code> es el número de particiones de un conjunto de 
<var>n</var> elementos.
</p>
<p>El argumento <var>n</var> debe ser un entero no negativo.
</p>
<p>La función <code>belln</code> se distribuye sobre ecuaciones, listas,
matrices y conjuntos.
</p>
<p>Ejemplos:
</p>
<p><code>belln</code> se aplica a enteros no negativos,
</p>
<pre class="example">(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions ({})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6}))
                            = belln (6));
(%o3)                         true
</pre>
<p>Si <var>n</var> no es un entero no negativo, la función <code>belln(n)</code> no hace cálculo alguno.
</p>
<pre class="example">(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>cardinality</b><i> (<var>a</var>)</i>
<a name="IDX1417"></a>
</dt>
<dd><p>Devuelve el número de elementos del conjunto <var>a</var>.
</p>
<p>La función <code>cardinality</code> ignora los elementos
redundantes, incluso cuando la simplificación está
desabilitada.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) cardinality ({});
(%o1)                           0
(%i2) cardinality ({a, a, b, c});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality ({a, a, b, c});
(%o4)                           3
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>cartesian_product</b><i> (<var>b_1</var>, ... , <var>b_n</var>)</i>
<a name="IDX1418"></a>
</dt>
<dd><p>Devuelve un conjunto formado por listas de la forma <code>[<var>x_1</var>, ..., <var>x_n</var>]</code>,
siendo <var>x_1</var>, ..., <var>x_n</var> elementos de los conjuntos <var>b_1</var>, ... , <var>b_n</var>,
respectivamente.
</p>
<p>La función <code>cartesian_product</code> emite un mensaje de error si alguno
de sus argumentos no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) cartesian_product ({0, 1});
(%o1)                      {[0], [1]}
(%i2) cartesian_product ({0, 1}, {0, 1});
(%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
(%i3) cartesian_product ({x}, {y}, {z});
(%o3)                      {[x, y, z]}
(%i4) cartesian_product ({x}, {-1, 0, 1});
(%o4)              {[x, - 1], [x, 0], [x, 1]}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>disjoin</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX1419"></a>
</dt>
<dd><p>Devuelve el conjunto <var>a</var> sin el elemento <var>x</var>.
Si <var>x</var> no es elemento de <var>a</var>, entonces el
resultado es el propio <var>a</var>.
</p>
<p>La función <code>disjoin</code> emite un mensaje de error si
<var>a</var> no es un conjunto literal.
</p>
<p>Las sentencias <code>disjoin(<var>x</var>, <var>a</var>)</code>, <code>delete(<var>x</var>, <var>a</var>)</code>
y <code>setdifference(<var>a</var>, set(<var>x</var>))</code> son todas ellas equivalentes;
pero en general, <code>disjoin</code> será más rápida que las otras.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) disjoin (a, {a, b, c, d});
(%o1)                       {b, c, d}
(%i2) disjoin (a + b, {5, z, a + b, %pi});
(%o2)                      {5, %pi, z}
(%i3) disjoin (a - b, {5, z, a + b, %pi});
(%o3)                  {5, %pi, b + a, z}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>disjointp</b><i> (<var>a</var>, <var>b</var>) </i>
<a name="IDX1420"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y sólo si los conjuntos  <var>a</var> y <var>b</var>
son disjuntos.
</p>
<p>La función <code>disjointp</code> emite un mensaje de error si
<var>a</var> o <var>b</var> no son conjuntos literales.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) disjointp ({a, b, c}, {1, 2, 3});
(%o1)                         true
(%i2) disjointp ({a, b, 3}, {1, 2, 3});
(%o2)                         false
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>divisors</b><i> (<var>n</var>)</i>
<a name="IDX1421"></a>
</dt>
<dd><p>Calcula el conjunto de divisores de <var>n</var>.
</p>
<p>La sentencia <code>divisors(<var>n</var>)</code> devuelve un conjunto
de enteros si <var>n</var> es un entero no nulo.
El conjunto de divisores incluye los elementos 1 y <var>n</var>.
Los divisores de un entero negativo son los divisores de su
valor absoluto.
</p>
<p>La función <code>divisors</code> se distribuye sobre las ecuaciones,
listas, matrices y conjuntos.
</p>
<p>Ejemplos:
</p>
<p>Se puede comprobar que 28 es un número perfecto:
la suma de sus divisores (excepto él mismo) es 28.
</p>
<pre class="example">(%i1) s: divisors(28);
(%o1)                 {1, 2, 4, 7, 14, 28}
(%i2) lreduce (&quot;+&quot;, args(s)) - 28;
(%o2)                          28
</pre>
<p>La función <code>divisors</code> es simplificadora.
Haciendo la sustitución de <code>a</code> por 8 en <code>divisors(a)</code>
devuelve los divisores sin tener que reevaluar <code>divisors(8)</code>,
</p>
<pre class="example">(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     {1, 2, 4, 8}
</pre>
<p>La función <code>divisors</code> se distribuye sobre ecuaciones, listas,
matrices y conjuntos.
</p>
<pre class="example">(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors ({a, b, c});
(%o4)        {divisors(a), divisors(b), divisors(c)}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>elementp</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX1422"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y sólo si <var>x</var> es miembro del
conjunto <var>a</var>.
</p>
<p>La función <code>elementp</code> emite un mensaje de error si 
<var>a</var> no es un conjunto literal.
</p>
<p>Ejemplos: 
</p>
<pre class="example">(%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
(%o1)                         true
(%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
(%o2)                         false
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>emptyp</b><i> (<var>a</var>)</i>
<a name="IDX1423"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y sólo si <var>a</var> es el conjunto vacío o la lista vacía.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) map (emptyp, [{}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, {{}}, %pi]);
(%o2)                 [false, false, false]
</pre></dd></dl>
       

<dl>
<dt><u>Función:</u> <b>equiv_classes</b><i> (<var>s</var>, <var>F</var>)</i>
<a name="IDX1424"></a>
</dt>
<dd><p>Devuelve el conjunto de las clases de equivalencia del conjunto <var>s</var>
respecto de la relación de equivalencia <var>F</var>.
</p>
<p>El argumento <var>F</var> es una función de dos variables definida sobre
el producto cartesiano <var>s</var> por <var>s</var>.
El valor devuelto por <var>F</var> debe ser <code>true</code> o <code>false</code>,
o bien una expresión <var>expr</var> tal que <code>is(<var>expr</var>)</code>
tome el valor <code>true</code> o <code>false</code>.
</p>
<p>Si <var>F</var> no es una relación de equivalencia, <code>equiv_classes</code>
la acepta sin emitir ningún mensaje de error, pero el resultado
será incorrecto en general.
</p>
<p>Ejemplos:
</p>
<p>La relación de equivalencia es una expresión lambda que devuelve 
<code>true</code> o <code>false</code>,
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                      lambda ([x, y], is (equal (x, y))));
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>La relación de equivalencia es el nombre de una función relacional
en la que <code>is</code> evalúa a <code>true</code> o <code>false</code>,
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>Las clases de equivalencia son números que difieren en un múltiplo de 3.
</p>
<pre class="example">(%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7}, 
              lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>every</b><i> (<var>f</var>, <var>s</var>)</i>
<a name="IDX1425"></a>
</dt>
<dt><u>Función:</u> <b>every</b><i> (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</i>
<a name="IDX1426"></a>
</dt>
<dd><p>Devuelve <code>true</code> si el predicado <var>f</var> vale <code>true</code>
para todos los argumentos dados.
</p>
<p>Dado un conjunto como segundo argumento,
<code>every(<var>f</var>, <var>s</var>)</code> devuelve <code>true</code>
si <code>is(<var>f</var>(<var>a_i</var>))</code> devuelve <code>true</code> para todos los
<var>a_i</var> pertenecientes <var>s</var>.
La función <code>every</code> puede evaluar o no <var>f</var> para todos los
<var>a_i</var> pertenecientes <var>s</var>.
Puesto que los conjuntos no están ordenados, <code>every</code>
puede evaluar <code><var>f</var>(<var>a_i</var>)</code> en cualquier orden.
</p>
<p>Dada una o más listas como argumentos,
<code>every(<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code> devuelve <code>true</code>
si <code>is(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>))</code> devuelve <code>true</code> 
para todo <var>x_1</var>, ..., <var>x_n</var> en <var>L_1</var>, ..., <var>L_n</var>, respectivamente.
La función <code>every</code> puede evaluar o no 
<var>f</var> para cualquier combinación de <var>x_1</var>, ..., <var>x_n</var>; además,
<code>every</code> evalúa las listas en el orden creciente del índice.
</p>
<p>Dado un conjunto vacío <code>{}</code> o lista vacía 
<code>[]</code> como argumentos, <code>every</code> devuelve <code>false</code>.
</p>
<p>Si la variable global <code>maperror</code> vale <code>true</code>, todas las listas
<var>L_1</var>, ..., <var>L_n</var> deben ser de igual longitud.
Si <code>maperror</code> vale <code>false</code>, los argumentos en forma de listas
se truncan para igualar sus longitudes a la de la lista más corta.
</p>
<p>Los valores que devuelve el predicado <var>f</var> cuando toman 
(mediante <code>is</code>) un valor diferente a <code>true</code> y <code>false</code>
se controlan con la variable global <code>prederror</code>.
Si <code>prederror</code> vale <code>true</code>, tales valores se
consideran como <code>false</code> y la respuesta de <code>every</code> es <code>false</code>.
Si <code>prederror</code> vale <code>false</code>, tales valores se
consideran como desconocidos (<code>unknown</code>) y la respuesta de 
<code>every</code> es <code>unknown</code>.
</p>
<p>Ejemplos:
</p>
<p>Se aplica <code>every</code> a un único conjunto.
El predicado es una función de un argumento.
</p>
<pre class="example">(%i1) every (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         false
</pre>
<p>Se aplica <code>every</code> a dos listas.
El predicado es una función de dos argumentos.
</p>
<pre class="example">(%i1) every (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p>Las respuestas del predicado <var>f</var> que se evalúan 
a cualquier cosa diferente de <code>true</code> y <code>false</code>
están controlados por la variable global <code>prederror</code>.
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z],
                   [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
</pre></dd></dl>
 

<dl>
<dt><u>Función:</u> <b>extremal_subset</b><i> (<var>s</var>, <var>f</var>, max)</i>
<a name="IDX1427"></a>
</dt>
<dt><u>Función:</u> <b>extremal_subset</b><i> (<var>s</var>, <var>f</var>, min)</i>
<a name="IDX1428"></a>
</dt>
<dd><p>Calcula el subconjunto de <var>s</var> para el cual la función <var>f</var>
toma sus valores mayor y menor.
</p>
<p>La sentencia <code>extremal_subset(<var>s</var>, <var>f</var>, max)</code>
devuelve el subconjunto del conjunto o lista <var>s</var> para el cual
la función real <var>f</var> toma su valor máximo.
</p>
<p>La sentencia <code>extremal_subset(<var>s</var>, <var>f</var>, min)</code>
devuelve el subconjunto del conjunto o lista <var>s</var> para el cual
la función real <var>f</var> toma su valor mínimo.
</p>
<p>Ejemplos
</p>
<pre class="example">(%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
(%o1)                       {- 2, 2}
(%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
(%o2)                       {sqrt(2)}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>flatten</b><i> (<var>expr</var>)</i>
<a name="IDX1429"></a>
</dt>
<dd><p>Recoge los argumentos de subexpresiones con el mismo operador que <var>expr</var>
y construye con ellas otra expresión a partir de estos argumentos.
</p>
<p>Aquellas subexpresiones en las que el operador es diferente del operador
principal de <code>expr</code> se copian sin modificarse, incluso cuando ellas
mismas contengan subexpresiones en las que el operador sea el mismo 
que el de <code>expr</code>.
</p>
<p>Es posible que <code>flatten</code> construya expresiones en las que el número
de argumentos difiera del número admitido por el operador, lo cual
hará que se emita un mensaje de error. La función <code>flatten</code>
no intentará detectar estas situaciones.
</p>
<p>Las expresiones que tengan representaciones especiales, por ejemplo las racionales
canónicas (CRE), no admiten que se aplique sobre ellas la función <code>flatten</code>;
en tales casos se devuelve el argumento sin modificación.
</p>
<p>Ejemplos:
</p>
<p>Aplicada a una lista, <code>flatten</code> reune todos los elementos que son a su vez listas.
</p>
<pre class="example">(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
</pre>
<p>Aplicado a un conjunto, <code>flatten</code> reune todos los elementos que son a su vez conjuntos.
</p>
<pre class="example">(%i1) flatten ({a, {b}, {{c}}});
(%o1)                       {a, b, c}
(%i2) flatten ({a, {[a], {a}}});
(%o2)                       {a, [a]}
</pre>
<p>La función <code>flatten</code> es similar a la declaración del operador
principal como n-ario. Sin embargo, <code>flatten</code> no tiene efecto alguno
sobre subexpresiones que tengan un operador diferente del principal, mientras
que sí lo tiene una declaración n-aria.
</p>

<pre class="example">(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
</pre>
<p>La función <code>flatten</code> trata las funciones subindicadas como
a cualquier otro operador.
</p>
<pre class="example">(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
</pre>
<p>Es posible que <code>flatten</code> construya expresiones en las que el número
de argumentos difiera del número admitido por el operador.
</p>
<pre class="example">(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>full_listify</b><i> (<var>a</var>)</i>
<a name="IDX1430"></a>
</dt>
<dd><p>Sustituye los operadores de conjunto presentes en <var>a</var>
por operadores de listas, devolviendo el resultado.
La función <code>full_listify</code> sustituye operadores de 
conjuntos en subexpresiones anidadas, incluso cuando
el operador principal no es <code>set</code>.
</p>
<p>La función <code>listify</code> sustituye únicamente el
operador principal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) full_listify ({a, b, {c, {d, e, f}, g}});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G ({a, b, H({c, d, e})})));
(%o2)              F(G([a, b, H([c, d, e])]))
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>fullsetify</b><i> (<var>a</var>)</i>
<a name="IDX1431"></a>
</dt>
<dd><p>Si <var>a</var> es una lista, sustituye el operador de lista por el
de conjunto, aplicando posteriormente <code>fullsetify</code> a todos
los elementos que son a su vez conjuntos.
Si <var>a</var> no es una lista, se devuelve sin cambio alguno.
</p>
<p>La función <code>setify</code> sustituye solamente el operador principal.
</p>
<p>Ejemplos:
</p>
<p>En la salida <code>(%o2)</code> el argumento de <code>f</code> no se convierte en
conjunto porque el operador principal de <code>f([b])</code> no es una lista.
</p>
<pre class="example">(%i1) fullsetify ([a, [a]]);
(%o1)                       {a, {a}}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      {a, f([b])}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>identity</b><i> (<var>x</var>)</i>
<a name="IDX1432"></a>
</dt>
<dd><p>La función <code>identity</code> devuelve su argumento cualquiera que sea éste.
</p>
<p>Ejemplos:
</p>
<p>La función <code>identity</code> puede utilizarse como predicado cuando
los argumentos ya son valores booleanos.
</p>
<pre class="example">(%i1) every (identity, [true, true]);
(%o1)                         true
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>integer_partitions</b><i> (<var>n</var>)</i>
<a name="IDX1433"></a>
</dt>
<dt><u>Función:</u> <b>integer_partitions</b><i> (<var>n</var>, <var>len</var>)</i>
<a name="IDX1434"></a>
</dt>
<dd><p>Devuelve particiones enteras de <var>n</var>, esto es,
listas de enteros cuyas sumas son <var>n</var>.
</p>
<p>La sentencia <code>integer_partitions(<var>n</var>)</code>
devuelve el conjunto de todas las particiones del entero <var>n</var>.
Cada partición es una lista ordenada de mayor a menor.
</p>
<p>La sentencia <code>integer_partitions(<var>n</var>, <var>len</var>)</code>
devuelve todas las particiones de longitud <var>len</var> o menor;
en este caso, se añaden ceros a cada partición con menos
de <var>len</var> términos para que todas ellas sean de longitud
<var>len</var>. Las particiones son listas ordenadas de mayor a menor.
</p>
<p>Una lista <em>[a_1, ..., a_m]</em> es una partición de un entero no
negativo <em>n</em> si (1) cada <em>a_i</em> es entero no nulo y (2)
<em>a_1 + ... + a_m = n.</em> Así, 0 no tiene particiones.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) integer_partitions (3);
(%o1)               {[1, 1, 1], [2, 1], [3]}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply (&quot;+&quot;, x)), s);
(%o4)                         {25}
(%i5) integer_partitions (5, 3);
(%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
(%i6) integer_partitions (5, 2);
(%o6)               {[3, 2], [4, 1], [5, 0]}
</pre>
<p>Para encontrar todas las particiones que satisfagan cierta
condición, utilícese la función <code>subset</code>;
he aquí un ejemplo que encuentra todas las
particiones de 10 formadas por números primos.
</p>
<pre class="example">(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x &gt; 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>intersect</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1435"></a>
</dt>
<dd><p>Es una forma abreviada de la función <code>intersection</code>.
</p></dd></dl>


<dl>
<dt><u>Función:</u> <b>intersection</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1436"></a>
</dt>
<dd><p>Devuelve el conjunto de todos los elementos que son
comunes a los conjuntos  <var>a_1</var> a <var>a_n</var>.
</p>
<p>Emite un mensaje de error en caso de que cualquiera de los 
<var>a_i</var> no sea un conjunto.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, d};
(%o1)                     {a, b, c, d}
(%i2) S_2 : {d, e, f, g};
(%o2)                     {d, e, f, g}
(%i3) S_3 : {c, d, e, f};
(%o3)                     {c, d, e, f}
(%i4) S_4 : {u, v, w};
(%o4)                       {u, v, w}
(%i5) intersection (S_1, S_2);
(%o5)                          {d}
(%i6) intersection (S_2, S_3);
(%o6)                       {d, e, f}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          {d}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          {}
</pre></dd></dl>

<dl>
<dt><u>Función:</u> <b>kron_delta</b><i> (<var>x1</var>, <var>y1</var>, &hellip;, <var>xp</var>, <var>yp</var>)</i>
<a name="IDX1437"></a>
</dt>
<dd><p>Es la función delta de Kronecker.
</p>
<p>La función <code>kron_delta</code> devuelve 1 cuando <var>xi</var> y
<var>yi</var> son iguales para todos los pares, devolviendo 0 si existe
un par en el que <var>xi</var> y <var>yi</var> no sean iguales. La igualdad
se determina utilizando <code>is(equal(xi,xj))</code> y la desigualdad
con <code>is(notequal(xi,xj))</code>. En caso de un solo argumento,
<code>kron_delta</code> devuelve un mensaje de error.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) kron_delta(a,a);
(%o1)                                  1
(%i2) kron_delta(a,b,a,b);
(%o2)                          kron_delta(a, b)
(%i3) kron_delta(a,a,b,a+1);
(%o3)                                  0
(%i4) assume(equal(x,y));
(%o4)                            [equal(x, y)]
(%i5) kron_delta(x,y);
(%o5)                                  1
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>listify</b><i> (<var>a</var>)</i>
<a name="IDX1438"></a>
</dt>
<dd><p>Si <var>a</var> es un conjunto, devuelve una lista con los elementos de <var>a</var>;
si  <var>a</var> no es un conjunto, devuelve <var>a</var>.
</p>
<p>La función <code>full_listify</code> sustituye todos los operadores
de conjunto en <var>a</var> por operadores de lista.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) listify ({a, b, c, d});
(%o1)                     [a, b, c, d]
(%i2) listify (F ({a, b, c, d}));
(%o2)                    F({a, b, c, d})
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>lreduce</b><i> (<var>f</var>, <var>s</var>)</i>
<a name="IDX1439"></a>
</dt>
<dt><u>Función:</u> <b>lreduce</b><i> (<var>f</var>, <var>s</var>, <var>init</var>)</i>
<a name="IDX1440"></a>
</dt>
<dd><p>Amplía la función binaria <var>F</var> a n-aria mediante
composición, siendo <var>s</var> una lista.
</p>
<p>La sentencia  <code>lreduce(<var>F</var>, <var>s</var>)</code> devuelve
<code>F(... F(F(s_1, s_2), s_3), ... s_n)</code>.
Si se incluye el argumento opcional <var>s_0</var>,
el resultado equivale a <code>lreduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>))</code>.
</p>
<p>La función <var>F</var> se aplica primero a los elementos del
extremo izquierdo de la lista, de ahí el nombre
<code>lreduce</code>, (<i>left reduce</i>).
</p>
<p>Véanse también <code>rreduce</code>, <code>xreduce</code> y <code>tree_reduce</code>.
</p>
<p>Ejemplos:
</p>
<p>La función <code>lreduce</code> sin el argumento opcional,
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
</pre>
<p>La función <code>lreduce</code> con el argumento opcional,
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
</pre>
<p>La función <code>lreduce</code> aplicada a operadores binarios de Maxima.
El símbolo <code>/</code> es el operador división.
</p>
<pre class="example">(%i1) lreduce (&quot;^&quot;, args ({a, b, c, d}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce (&quot;/&quot;, args ({a, b, c, d}));
                                a
(%o2)                         -----
                              b c d
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>makeset</b><i> (<var>expr</var>, <var>x</var>, <var>s</var>)</i>
<a name="IDX1441"></a>
</dt>
<dd><p>Genera un conjunto cuyos miembros se generan a partir de la
expresión <var>expr</var>, siendo <var>x</var> una lista de variables de
<var>expr</var> y <var>s</var> un conjunto o lista de listas.
Para generar los elementos del conjunto, se evalúa <var>expr</var>
asignando a las variables de <var>x</var> los elementos de <var>s</var>
en paralelo.
</p>
<p>Los elementos de <var>s</var> deben tener la misma longitud que <var>x</var>.
La lista de variables <var>x</var> debe ser una lista de símbolos
sin subíndices. Cuando se trate de un único símbolo,
<var>x</var> debe expresarse como una lista de un elemento y cada elemento de <var>s</var>
debe ser una lista de un sólo elemento.
</p>

<p>Véase también <code>makelist</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     {-, -, -, -}
                           a  b  c  d
(%i2) S : {x, y, z}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y], 
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x], 
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z], 
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y], 
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x], 
[z, z, y], [z, z, z]}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x, 
                                       z + 2 y, 2 z + x, 2 z + y}
(%i5) makeset (sin(x), [x], {[1], [2], [3]});
(%o5)               {sin(1), sin(2), sin(3)}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>moebius</b><i> (<var>n</var>)</i>
<a name="IDX1442"></a>
</dt>
<dd><p>Representa la función de Moebius.
</p>
<p>Si <var>n</var> es el producto de <em>k</em> números primos diferentes,
<code>moebius(<var>n</var>)</code> devuelve <em>(-1)^k</em>, retornando 1 si 
<em><var>n</var> = 1</em> y 0 para cualesquiera otros enteros positivos.
</p>

<p>La función de Moebius se distribuye respecto de ecuaciones,
listas, matrices y conjuntos.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius ({21, 22, 23, 24});
(%o9)                      {- 1, 0, 1}
</pre></dd></dl>
 

<dl>
<dt><u>Función:</u> <b>multinomial_coeff</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1443"></a>
</dt>
<dt><u>Función:</u> <b>multinomial_coeff</b><i> ()</i>
<a name="IDX1444"></a>
</dt>
<dd><p>Calcula el coeficiente multinomial.
</p>
<p>Si todos los <var>a_k</var> son enteros no negativos, el coeficiente multinomial
es el número de formas de colocar  <code><var>a_1</var> + ... + <var>a_n</var></code>
objetos diferentes en  <em>n</em> cajas con <var>a_k</var> elementos en la
<em>k</em>-ésima caja. En general,
<code>multinomial_coeff (<var>a_1</var>, ..., <var>a_n</var>)</code> calcula
<code>(<var>a_1</var> + ... + <var>a_n</var>)!/(<var>a_1</var>! ... <var>a_n</var>!)</code>.
</p>
<p>Si no se dan argumentos, <code>multinomial_coeff()</code> devuelve 1.
</p>
<p>Se puede usar <code>minfactorial</code> para simplificar el valor
devuelto por <code>multinomial_coeff</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>num_distinct_partitions</b><i> (<var>n</var>)</i>
<a name="IDX1445"></a>
</dt>
<dt><u>Función:</u> <b>num_distinct_partitions</b><i> (<var>n</var>, <var>list</var>)</i>
<a name="IDX1446"></a>
</dt>
<dd><p>Si <var>n</var> es un entero no negativo, devuelve el número de
particiones enteras distintas de <var>n</var>, en caso contrario
<code>num_distinct_partitions</code> devuelve una forma nominal.
</p>
<p>La sentencia <code>num_distinct_partitions(<var>n</var>, list)</code>
devuelve una lista con el número de particiones distintas
de 1, 2, 3, ..., <var>n</var>.
</p>
<p>Una partición distinta de <var>n</var> es una lista de números
enteros positivos distintos <em>k_1</em>, ..., <em>k_m</em>
tales que <em><var>n</var> = k_1 + ... + k_m</em>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>num_partitions</b><i> (<var>n</var>)</i>
<a name="IDX1447"></a>
</dt>
<dt><u>Función:</u> <b>num_partitions</b><i> (<var>n</var>, <var>list</var>)</i>
<a name="IDX1448"></a>
</dt>
<dd><p>Si <var>n</var> es un entero no negativo, devuelve el número de
particiones enteras de <var>n</var>, en caso contrario <code>num_partitions</code>
devuelve una expresión nominal.
</p>
<p>La sentencia <code>num_partitions(<var>n</var>, list)</code> devuelve una lista
con los números de particiones enteras de 1, 2, 3, ..., <var>n</var>.
</p>
<p>Siendo <var>n</var> un entero no negativo, <code>num_partitions(<var>n</var>)</code>
es igual a <code>cardinality(integer_partitions(<var>n</var>))</code>; sin
embargo, <code>num_partitions</code> no construye el conjunto de 
particiones, por lo que es más rápido.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>partition_set</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX1449"></a>
</dt>
<dd><p>Particiona el conjunto <var>a</var> respecto del predicado <var>f</var>.
</p>
<p>La función <code>partition_set</code> devuelve una lista con dos conjuntos;
el primer conjunto es el subconjunto de <var>a</var> para el cual el predicado
<var>f</var> devuelve <code>false</code> y el segundo contiene al resto de elementos de <var>a</var>.
</p>
<p>La función <code>partition_set</code> no aplica <code>is</code> al valor devuelto
por <var>f</var>.
</p>
<p>La función <code>partition_set</code> emite un mensaje de error si <var>a</var>
no es un conjunto literal.
</p>
<p>Véase también <code>subset</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
(%o1)                   [{1, 7}, {2, 8}]
(%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                  lambda ([x], ratp(x)));
(%o2)/R/              [{1, x}, {y, y + z}]
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>permutations</b><i> (<var>a</var>)</i>
<a name="IDX1450"></a>
</dt>
<dd><p>Devuelve un conjunto con todas las permutaciones distintas
de los miembros de la lista o conjunto  <var>a</var>. Cada permutación
es una lista, no un conjunto.
</p>
<p>Si <var>a</var> es una lista, sus miembros duplicados no son eliminados
antes de buscar sus permutaciones.
</p>
<p>Si <var>a</var> no es una lista o conjunto, <code>permutations</code> emite
un mensaje de error.
</p>
<p>Véase también <code>random_permutation</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) permutations ([a, a]);
(%o1)                       {[a, a]}
(%i2) permutations ([a, a, b]);
(%o2)           {[a, a, b], [a, b, a], [b, a, a]}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>powerset</b><i> (<var>a</var>)</i>
<a name="IDX1451"></a>
</dt>
<dt><u>Función:</u> <b>powerset</b><i> (<var>a</var>, <var>n</var>)</i>
<a name="IDX1452"></a>
</dt>
<dd><p>Devuelve el conjunto de todos los subconjuntos del conjunto <var>a</var>
o un sunconjunto de ellos.
</p>
<p>La sentencia <code>powerset(<var>a</var>)</code> devuelve el conjunto de todos
los subconjuntos de <var>a</var>, que contendrá <code>2^cardinality(<var>a</var>)</code>
elementos.
</p>
<p>La sentencia <code>powerset(<var>a</var>, <var>n</var>)</code> devuelve el conjunto de todos
los subconjuntos de <var>a</var> de cardinalidad <var>n</var>.
</p>
<p>La función <code>powerset</code> emite un mensaje de error si <var>a</var> no
es un conjunto literal o si <var>n</var> no es un entero no negativo.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) powerset ({a, b, c});
(%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
(%i2) powerset ({w, x, y, z}, 4);
(%o2)                    {{w, x, y, z}}
(%i3) powerset ({w, x, y, z}, 3);
(%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
(%i4) powerset ({w, x, y, z}, 2);
(%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
(%i5) powerset ({w, x, y, z}, 1);
(%o5)                 {{w}, {x}, {y}, {z}}
(%i6) powerset ({w, x, y, z}, 0);
(%o6)                         {{}}
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>random_permutation</b><i> (<var>a</var>)</i>
<a name="IDX1453"></a>
</dt>
<dd><p>Devuelve una permutación aleatoria del conjunto o lista
<var>a</var>, siguiendo el algoritmo de Knuth.
</p>
<p>El valor devuelto es una lista nueva distinta del argumento,
incluso cuando todos los elementos son iguales. Sin embargo,
los elementos del argumento no se copian.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) random_permutation ([a, b, c, 1, 2, 3]);
(%o1)                  [c, 1, 2, 3, a, b]
(%i2) random_permutation ([a, b, c, 1, 2, 3]);
(%o2)                  [b, 3, 1, c, a, 2]
(%i3) random_permutation ({x + 1, y + 2, z + 3});
(%o3)                 [y + 2, z + 3, x + 1]
(%i4) random_permutation ({x + 1, y + 2, z + 3});
(%o4)                 [x + 1, y + 2, z + 3]
</pre>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>rreduce</b><i> (<var>f</var>, <var>s</var>)</i>
<a name="IDX1454"></a>
</dt>
<dt><u>Función:</u> <b>rreduce</b><i> (<var>f</var>, <var>s</var>, <var>init</var>)</i>
<a name="IDX1455"></a>
</dt>
<dd><p>Amplía la función binaria <var>F</var> a n-aria mediante
composición, siendo <var>s</var> una lista.
</p>
<p>La sentencia  <code>rreduce(<var>F</var>, <var>s</var>)</code> devuelve
<code>F(s_1, ... F(s_{n - 2}, F(s_{n - 1}, s_n)))</code>.
Si se incluye el argumento opcional <var>s_{n + 1}</var>,
el resultado equivale a <code>rreduce(<var>F</var>, endcons(<var>s_{n + 1}</var>, <var>s</var>))</code>.
</p>
<p>La función <var>F</var> se aplica primero a los elementos del
extremo derecho de la lista, de ahí el nombre
<code>rreduce</code>, (<i>right reduce</i>).
</p>
<p>Véanse también <code>lreduce</code>, <code>xreduce</code> y <code>tree_reduce</code>.
</p>
<p>Ejemplos:
</p>
<p>La función <code>rreduce</code> sin el argumento opcional,
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
</pre>
<p>La función <code>rreduce</code> con el argumento opcional,
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
</pre>
<p>La función <code>rreduce</code> aplicada a operadores binarios de Maxima.
El símbolo <code>/</code> es el operador división.
</p>
<pre class="example">(%i1) rreduce (&quot;^&quot;, args ({a, b, c, d}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce (&quot;/&quot;, args ({a, b, c, d}));
                               a c
(%o2)                          ---
                               b d
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>setdifference</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1456"></a>
</dt>
<dd><p>Devuelve el conjunto con los elementos del conjunto <var>a</var> que
no pertenecen al conjunto <var>b</var>.
</p>
<p>La función <code>setdifference</code> emite un mensaje de error si
<var>a</var> o <var>b</var> no son conjuntos.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, x, y, z};
(%o1)                  {a, b, c, x, y, z}
(%i2) S_2 : {aa, bb, c, x, y, zz};
(%o2)                 {aa, bb, c, x, y, zz}
(%i3) setdifference (S_1, S_2);
(%o3)                       {a, b, z}
(%i4) setdifference (S_2, S_1);
(%o4)                     {aa, bb, zz}
(%i5) setdifference (S_1, S_1);
(%o5)                          {}
(%i6) setdifference (S_1, {});
(%o6)                  {a, b, c, x, y, z}
(%i7) setdifference ({}, S_1);
(%o7)                          {}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>setequalp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1457"></a>
</dt>
<dd><p>Devuelve  <code>true</code> si los conjuntos <var>a</var> y <var>b</var> tienen
el mismo número de elementos
y <code>is (<var>x</var> = <var>y</var>)</code> vale <code>true</code>
para <code>x</code> perteneciente a <var>a</var>
e <code>y</code> perteneciente a <var>b</var>,
considerados en el orden que determina la función 
<code>listify</code>. En caso contrario, <code>setequalp</code>
devuelve <code>false</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) setequalp ({1, 2, 3}, {1, 2, 3});
(%o1)                         true
(%i2) setequalp ({a, b, c}, {1, 2, 3});
(%o2)                         false
(%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
(%o3)                         false
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>setify</b><i> (<var>a</var>)</i>
<a name="IDX1458"></a>
</dt>
<dd><p>Construye un conjunto con los miembros de la lista <var>a</var>.
Los elementos duplicados de la lista <var>a</var> son borrados
y ordenados de acuerdo con el predicado <code>orderlessp</code>.
</p>
<p>La función <code>setify</code> emite un mensaje de error si
<var>a</var> no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  {1, 2, 3, a, b, c}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       {a, b, c}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                {1, 3, 5, 7, 9, 11, 13}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>setp</b><i> (<var>a</var>)</i>
<a name="IDX1459"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y sólo si <var>a</var> es un conjunto de Maxima.
</p>
<p>La función <code>setp</code> devuelve <code>true</code> tanto cuando el conjunto
tiene como cuando no tiene elementos repetidos.
</p>
<p>La función <code>setp</code> is equivalent to the Maxima function
<code>setp(a) := not atom(a) and op(a) = 'set</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) simp : false;
(%o1)                         false
(%i2) {a, a, a};
(%o2)                       {a, a, a}
(%i3) setp (%);
(%o3)                         true
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>set_partitions</b><i> (<var>a</var>)</i>
<a name="IDX1460"></a>
</dt>
<dt><u>Función:</u> <b>set_partitions</b><i> (<var>a</var>, <var>n</var>)</i>
<a name="IDX1461"></a>
</dt>
<dd><p>Devuelve el conjunto de todas las particiones de <var>a</var> o
un subconjunto de ellas.
</p>
<p>La sentencia <code>set_partitions(<var>a</var>, <var>n</var>)</code>
devuelve un conjunto con todas las descomposiciones de <var>a</var>
en <var>n</var> conjuntos no vacíos disjuntos.
</p>
<p>La sentencia <code>set_partitions(<var>a</var>)</code> devuelve el
conjunto de todas las particiones.
</p>
<p>La función <code>stirling2</code> devuelve la cardinalidad del conjunto
de las particiones de un conjunto.
</p>
<p>Se dice que un conjunto <em>P</em> es una partición del conjunto <em>S</em> si verifica
</p>
<ol>
<li>
cada elemento de <em>P</em> es un conjunto no vacío, 
</li><li>
los elementos de <em>P</em> son disjuntos,
</li><li>
la unión de los elementos de <em>P</em> es igual a  <em>S</em>.
</li></ol>

<p>Ejemplos:
</p>
<p>El conjunto vacío forma una partición de sí mismo,
</p>
<pre class="example">(%i1) set_partitions ({});
(%o1)                         {{}}
</pre>
<p>La cardinalidad del conjunto de particiones de un conjunto puede calcularse con <code>stirling2</code>,
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
</pre>
<p>Cada elemento de <code>p</code> debería tener <var>n</var> = 3 miembros,
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (cardinality, p);
(%o3)                          {3}
</pre>
<p>Por último, para cada miembro de <code>p</code>, la unión de sus elementos
debe ser igual a <code>s</code>,
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$ 
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 {{0, 1, 2, 3, 4, 5}}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>some</b><i> (<var>f</var>, <var>a</var>)</i>
<a name="IDX1462"></a>
</dt>
<dt><u>Función:</u> <b>some</b><i> (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</i>
<a name="IDX1463"></a>
</dt>
<dd><p>Devuelve <code>true</code> si el predicado <var>f</var> devuelve <code>true</code>
para al menos uno de sus argumentos.
Si el segundo argumento es un conjunto, <code>some (<var>f</var>, <var>a</var>)</code>
devuelve <code>true</code> si <code><var>f</var>(<var>a_i</var>)</code> devuelve también
<code>true</code> para alguno de los <var>a_i</var> en <var>a</var>; puede ser que
<code>some</code> no evalúe <var>f</var> para todos los <var>a_i</var> de <var>s</var>.
Puesto que los conjuntos no están ordenados, <code>some</code> puede evaluar
<code><var>f</var>(<var>a_i</var>)</code> en cualquier orden.
</p>
<p>Dada una o más listas como argumentos,
<code>some (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code> devuelve <code>true</code>
si <code><var>f</var>(<var>x_1</var>, ..., <var>x_n</var>)</code> devuelve también
<code>true</code> para al menos un  <var>x_1</var>, ..., <var>x_n</var> de
<var>L_1</var>, ..., <var>L_n</var>, respectivamente; puede ser que
<code>some</code> no evalúe <var>f</var> para todos las combinaciones
<var>x_1</var>, ..., <var>x_n</var>. La función <code>some</code> evalúa
las listas en el orden creciente de su índice
</p>
<p>Dado un conjunto vacío <code>{}</code> o una lista
vacía como argumentos, <code>some</code> devuelve <code>false</code>.
</p>
<p>Si la variable global <code>maperror</code> vale <code>true</code>,
todas las listas <var>L_1</var>, ..., <var>L_n</var> deben tener
igual número de elementos. Si <code>maperror</code> vale
<code>false</code>, los argumentos se truncan para tener todos
el número de elementos de la lista más corta. 
</p>
<p>Los valores que devuelve el predicado <var>f</var> cuando toman 
(mediante <code>is</code>) un valor diferente a <code>true</code> y <code>false</code>
se controlan con la variable global <code>prederror</code>.
Si <code>prederror</code> vale <code>true</code>, tales valores se
consideran como <code>false</code>.
Si <code>prederror</code> vale <code>false</code>, tales valores se
consideran como desconocidos (<code>unknown</code>).
</p>
<p>Ejemplos:
</p>
<p>La función <code>some</code> aplicada a un único conjunto.
El predicado es una función de un argumento,
</p>
<pre class="example">(%i1) some (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         true
</pre>
<p>La función <code>some</code> aplicada a dos listas.
El predicado es una función de dos argumentos,
</p>
<pre class="example">(%i1) some (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p>Las respuestas del predicado <var>f</var> que se evalúan 
a cualquier cosa diferente de <code>true</code> y <code>false</code>
están controlados por la variable global <code>prederror</code>.
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z],
                     [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>stirling1</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1464"></a>
</dt>
<dd><p>Es el número de Stirling de primera especie.
</p>
<p>Si tanto <var>n</var> como <var>m</var> son enteros no negativos,
el valor que toma <code>stirling1 (<var>n</var>, <var>m</var>)</code>
es el número de permutaciones de un conjunto de
<var>n</var> elementos con <var>m</var> ciclos. Para más detalles,
véase Graham, Knuth and Patashnik <i>Concrete Mathematics</i>.
Maxima utiliza una relación recursiva para definir
<code>stirling1 (<var>n</var>, <var>m</var>)</code> para <var>m</var> menor
que 0; no está definida para <var>n</var> menor que 0 ni
para argumentos no enteros.
</p>
<p>La función <code>stirling1</code> es simplificadora. Maxima
reconoce las siguientes identidades:
</p>
<ol>
<li>
<em>stirling1(0, n) = kron_delta(0, n)</em> (Ref. [1])
</li><li>
<em>stirling1(n, n) = 1</em> (Ref. [1])
</li><li>
<em>stirling1(n, n - 1) = binomial(n, 2)</em> (Ref. [1])
</li><li>
<em>stirling1(n + 1, 0) = 0</em> (Ref. [1])
</li><li>
<em>stirling1(n + 1, 1) = n!</em> (Ref. [1])
</li><li>
<em>stirling1(n + 1, 2) = 2^n  - 1</em> (Ref. [1])
</li></ol>

<p>Estas identidades se aplican cuando los argumentos son enteros
literales o símbolos declarados como enteros y
el primer argumento es no negativo. La función <code>stirling1</code>
no simplifica para argumentos no enteros.
</p>
<p>Referencias:
</p>
<p>[1] Donald Knuth, <i>The Art of Computer Programming,</i>
Tercera Edición, Volumen 1, Sección 1.2.6, Ecuaciones 48, 49 y 50.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
</pre>
<p>La función <code>stirling1</code> no simplifica en caso de argumentos no enteros,
</p>
<pre class="example">(%i1) stirling1 (sqrt(2), sqrt(2));
(%o1)              stirling1(sqrt(2), sqrt(2))
</pre>
<p>Maxima aplicas algunas identidades a <code>stirling1</code>,
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling1 (n + 1, n);
                            n (n + 1)
(%o3)                       ---------
                                2
(%i4) stirling1 (n + 1, 1);
(%o4)                          n!
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>stirling2</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1465"></a>
</dt>
<dd><p>Es el número de Stirling de segunda especie.
</p>
<p>Si <var>n</var> y <var>m</var> son enteros no negativos,
<code>stirling2 (<var>n</var>, <var>m</var>)</code> es el número
de formas en las que se puede particionar un conjunto
de cardinal <var>n</var> en <var>m</var> subconjuntos disjuntos.
Maxima utiliza una relación recursiva para definir
<code>stirling2 (<var>n</var>, <var>m</var>)</code> con <var>m</var> menor
que 0; la función no está definida para  <var>n</var>
menor que 0  ni para argumentos no enteros.
</p>
<p>La función <code>stirling2</code> es simplificadora. Maxima
reconoce las siguientes identidades:
</p>
<ol>
<li>
<em>stirling2(0, n) = kron_delta(0, n)</em> (Ref. [1])
</li><li>
<em>stirling2(n, n) = 1</em> (Ref. [1])
</li><li>
<em>stirling2(n, n - 1) = binomial(n, 2)</em> (Ref. [1])
</li><li>
<em>stirling2(n + 1, 1) = 1</em> (Ref. [1])
</li><li>
<em>stirling2(n + 1, 2) = 2^n  - 1</em> (Ref. [1])
</li><li>
<em>stirling2(n, 0) = kron_delta(n, 0)</em> (Ref. [2])
</li><li>
<em>stirling2(n, m) = 0</em> when <em>m &gt; n</em> (Ref. [2])
</li><li>
<em>stirling2(n, m) = sum((-1)^(m - k) binomial(m k) k^n,i,1,m) / m!</em>
si <em>m</em> y <em>n</em> son enteros y <em>n</em> no negativo. (Ref. [3])
</li></ol>

<p>Estas identidades se aplican cuando los argumentos son enteros
literales o símbolos declarados como enteros y
el primer argumento es no negativo. La función <code>stirling2</code>
no simplifica para argumentos no enteros.
</p>
<p>Referencias:
</p>
<p>[1] Donald Knuth. <i>The Art of Computer Programming</i>,
Tercera Edición, Volumen 1, Sección 1.2.6, Ecuaciones 48, 49 y 50.
</p>
<p>[2] Graham, Knuth y Patashnik. <i>Concrete Mathematics</i>, Tabla 264.
</p>
<p>[3] Abramowitz y Stegun. <i>Handbook of Mathematical Functions</i>, Sección 24.1.4.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
</pre>
<p>La función <code>stirling2</code> no simplifica en caso de argumentos no enteros,
</p>
<pre class="example">(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
</pre>
<p>Maxima aplicas algunas identidades a <code>stirling2</code>,
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling2 (n + 9, n + 8);
                         (n + 8) (n + 9)
(%o3)                    ---------------
                                2
(%i4) stirling2 (n + 1, 2);
                              n
(%o4)                        2  - 1
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>subset</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX1466"></a>
</dt>
<dd><p>Devuelve el subconjunto del conjunto <var>a</var> que satisface el predicado <var>f</var>.
</p>
<p>La función <code>subset</code> devuelve el conjunto que contiene a los
elementos de <var>a</var> para los cuales <var>f</var> devuelve un resultado
diferente de <code>false</code>. La función <code>subset</code> no aplica
<code>is</code> al valor retornado por <var>f</var>.
</p>
<p>La función <code>subset</code> emite un mensaje de error si <var>a</var>
no es un conjunto literal.
</p>
<p>Véase también <code>partition_set</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
(%o1)                     {1, 2, x, z}
(%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
(%o2)                      {2, 8, 14}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>subsetp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1467"></a>
</dt>
<dd><p>Devuelve <code>true</code> si y sólo si el conjunto <var>a</var> es un subconjunto de <var>b</var>.
</p>
<p>La función <code>subsetp</code> emite un mensaje de error si
cualesquiera <var>a</var> o <var>b</var> no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
(%o1)                         true
(%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
(%o2)                         false
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>symmdifference</b><i> (<var>a_1</var>, &hellip;, <var>a_n</var>)</i>
<a name="IDX1468"></a>
</dt>
<dd><p>Devuelve la diferencia simétrica de los conjuntos <code> <var>a_1</var>, &hellip;, <var>a_n</var></code>.
</p>
<p>Dados dos argumentos, <code>symmdifference (<var>a</var>, <var>b</var>)</code> equivale a
<code>union (setdifference (<var>a</var>, <var>b</var>), setdifference (<var>b</var>, <var>a</var>))</code>.
</p>
<p>La función <code>symmdifference</code> emite un mensaje de error si alguno de
su argumentos no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c};
(%o1)                       {a, b, c}
(%i2) S_2 : {1, b, c};
(%o2)                       {1, b, c}
(%i3) S_3 : {a, b, z};
(%o3)                       {a, b, z}
(%i4) symmdifference ();
(%o4)                          {}
(%i5) symmdifference (S_1);
(%o5)                       {a, b, c}
(%i6) symmdifference (S_1, S_2);
(%o6)                        {1, a}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                       {1, b, z}
(%i8) symmdifference ({}, S_1, S_2, S_3);
(%o8)                       {1,b, z}
</pre></dd></dl>

<dl>
<dt><u>Función:</u> <b>tree_reduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX1469"></a>
</dt>
<dt><u>Función:</u> <b>tree_reduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1470"></a>
</dt>
<dd><p>Amplía la función binaria <var>F</var> a n-aria, siendo <var>s</var> una lista.
</p>
<p>La función <code>tree_reduce</code> equivale a lo suguiente:
Aplicar <var>F</var> a pares sucesivos de elementos para formar
una nueva lista <code>[<var>F</var>(<var>s_1</var>, <var>s_2</var>), <var>F</var>(<var>s_3</var>, <var>s_4</var>), ...]</code>,
llevando el elemento final sin cambiar si el número de elementos es impar;
después repetir hasta que la lista se reduzca a un único elemento,
que es el valor de retorno.
</p>
<p>Cuando está presente el argumento opcional <var>s_0</var>,
el resultado equivale a <code>tree_reduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>)</code>.
</p>
<p>Para la suma de números decimales en coma flotante,
<code>tree_reduce</code> puede devolver una suma que tenga un error
de redondeo menor que el conseguido por <code>rreduce</code> o <code>lreduce</code>.
</p>
<p>Los elementos de <var>s</var> y los resultados parciales pueden colocarse
en un árbol binario de mínima profundidad, de ahí
el nombre de <i>tree_reduce</i>.
</p>
<p>Ejemplos:
</p>
<p>La función <code>tree_reduce</code> aplicada a una lista con un número
par de elementos,
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
</pre>
<p>La función <code>tree_reduce</code> aplicada a una lista con un número
impar de elementos,
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
</pre></dd></dl>


<dl>
<dt><u>Function:</u> <b>union</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1471"></a>
</dt>
<dd><p>Devuelve la unión de los conjuntos <var>a_1</var> hasta <var>a_n</var>.
</p>
<p>La sentencia <code>union()</code> (sin argumentos) devuelve el
conjunto vacío.
</p>
<p>La función <code>union</code> emite un mensaje de error si alguno
de sus argumentos no es un conjunto literal.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) S_1 : {a, b, c + d, %e};
(%o1)                   {%e, a, b, d + c}
(%i2) S_2 : {%pi, %i, %e, c + d};
(%o2)                 {%e, %i, %pi, d + c}
(%i3) S_3 : {17, 29, 1729, %pi, %i};
(%o3)                {17, 29, 1729, %i, %pi}
(%i4) union ();
(%o4)                          {}
(%i5) union (S_1);
(%o5)                   {%e, a, b, d + c}
(%i6) union (S_1, S_2);
(%o6)              {%e, %i, %pi, a, b, d + c}
(%i7) union (S_1, S_2, S_3);
(%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
(%i8) union ({}, S_1, S_2, S_3);
(%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
</pre></dd></dl>


<dl>
<dt><u>Función:</u> <b>xreduce</b><i> (<var>F</var>, <var>s</var>)</i>
<a name="IDX1472"></a>
</dt>
<dt><u>Función:</u> <b>xreduce</b><i> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1473"></a>
</dt>
<dd><p>Amplía la función <var>F</var> a n-aria mediante
composición; si <var>F</var> ya es n-aria, aplica <var>F</var> a <var>s</var>.
Si <var>F</var> no es n-aria, <code>xreduce</code> equivale a <code>lreduce</code>.
El argumento <var>s</var> debe ser una lista.
</p>
<p>Funciones n-arias reconocidas por Maxima son la suma <code>+</code>, la
multiplicación <code>*</code>, <code>and</code>, <code>or</code>, <code>max</code>,
<code>min</code> y <code>append</code>. Las funciones también se pueden
declarar n-arias mediante <code>declare(<var>F</var>, nary)</code>;
para estas funciones, <code>xreduce</code> será más rápida que
<code>rreduce</code> o <code>lreduce</code>.
</p>
<p>Cuando está presente el argumento opcional <var>s_0</var>,
el resultado equivale a <code>xreduce(<var>s</var>, cons(<var>s_0</var>, <var>s</var>))</code>.
</p>
<p>La suma de números decimales en coma flotante no es exactamente asociativa;
aún así, <code>xreduce</code> aplica la suma n-aria cuando <var>s</var>
contiene números en coma flotante.
</p>
<p>Ejemplos:
</p>
<p>La función <code>xreduce</code> aplicada a una función n-aria;
<code>F</code> es invocada una sóla vez, con todos sus argumentos,
</p>
<pre class="example">(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
</pre>
<p>La función <code>xreduce</code> aplicada a una función que se desconoce si
es n-aria; <code>G</code> es invocada varias veces, con dos argumentos de cada vez,
</p>
<pre class="example">(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
</pre></dd></dl>









<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC190" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC197" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>abril, 9 2015</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
