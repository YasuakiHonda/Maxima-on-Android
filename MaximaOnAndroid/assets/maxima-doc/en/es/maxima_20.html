<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on abril, 9 2015 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.36.0: 20. Ecuaciones</title>

<meta name="description" content="Manual de Maxima 5.36.0: 20. Ecuaciones">
<meta name="keywords" content="Manual de Maxima 5.36.0: 20. Ecuaciones">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Ecuaciones"></a>
<a name="SEC116"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_19.html#SEC115" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC117" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_19.html#SEC110" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC118" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 20. Ecuaciones </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC117">20.1 Funciones y variable para las ecuaciones</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Funciones-y-variable-para-las-ecuaciones"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC116" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC118" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC116" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC116" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC118" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC117"></a>
<h2 class="section"> 20.1 Funciones y variable para las ecuaciones </h2>

<dl>
<dt><u>Variable del sistema:</u> <b>%rnum_list</b>
<a name="IDX851"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>La variable <code>%rnum_list</code> es la lista de variables introducidas en las
soluciones por la funciones <code>solve</code> y <code>algsys</code>.
Las variables <code>%r</code> se añaden a <code>%rnum_list</code> en su orden de creación.
Esto es útil para hacer sustituciones en la solución a posteriori.
</p>
<pre class="example">(%i1) solve ([x + y = 3], [x,y]);
(%o1)              [[x = 3 - %r1, y = %r1]]
(%i2) %rnum_list;
(%o2)                       [%r1]
(%i3) sol : solve ([x + 2*y + 3*z = 4], [x,y,z]);
(%o3)   [[x = - 2 %r3 - 3 %r2 + 4, y = %r3, z = %r2]]
(%i4) %rnum_list;
(%o4)                     [%r2, %r3]
(%i5) for i : 1 thru length (%rnum_list) do
        sol : subst (t[i], %rnum_list[i], sol)$
(%i6) sol;
(%o6)     [[x = - 2 t  - 3 t  + 4, y = t , z = t ]]
                     2      1           2       1
</pre></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>algepsilon</b>
<a name="IDX852"></a>
</dt>
<dd><p>Valor por defecto: 10^8
</p>
<p>La variable <code>algepsilon</code> es utilizada por <code>algsys</code>.
</p>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>algexact</b>
<a name="IDX853"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>El contenido de la variable <code>algexact</code> afecta al comportamiento de <code>algsys</code> de la siguiente forma:
</p>
<p>Si <code>algexact</code> vale <code>true</code>, <code>algsys</code> llamará siempre a <code>solve</code> y luego utilizará <code>realroots</code>.
</p>
<p>Si <code>algexact</code> vale <code>false</code>, <code>solve</code> será llamada sólo si la ecuación no es univariante, o si es cuadrática o bicuadrática.
</p>
<p>Sin embargo, <code>algexact: true</code> no garantiza que únicamente se obtengan soluciones exactas, ya que aunque <code>algsys</code> intente siempre dar soluciones exactas, dará resultados aproximados si no encuentra una solución mejor.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>algsys</b><i> ([<var>expr_1</var>, ..., <var>expr_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX854"></a>
</dt>
<dt><u>Función:</u> <b>algsys</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX855"></a>
</dt>
<dd><p>Resuelve el sistema de ecuaciones polinómicas <var>expr_1</var>, ..., <var>expr_m</var>
o las ecuaciones <var>eqn_1</var>, ..., <var>eqn_m</var> para las variables <var>x_1</var>, ..., <var>x_n</var>.
La expresión <var>expr</var> equivale a la ecuación <code><var>expr</var> = 0</code>. Puede haber más ecuaciones que variables o viceversa.
</p>
<p>La función <code>algsys</code> devuelve una lista de soluciones, cada una de las cuales consistente a su vez en una lista de ecuaciones asociando valores a las variables <var>x_1</var>, ..., <var>x_n</var> que satisfacen el sistema de ecuaciones.
Si <code>algsys</code> no puede encontrar soluciones devuelve la lista vacía <code>[]</code>.
</p>
<p>Si es necesario se introducen en la solución los símbolos  <code>%r1</code>, <code>%r2</code>, ..., para representar parámetros arbitrarios; estas variables también se añaden a la lista <code>%rnum_list</code>.
</p>
<p>El proceso que se sigue es el siguiente:
</p>
<p>(1) Primero se factorizan las ecuaciones y se reparten en subsistemas.
</p>
<p>(2) Para cada subsistema <var>S_i</var>, se seleccionan una ecuación <var>E</var> y una variable <var>x</var>. Se elige la variable que tenga grado menor. Entonces se calcula el resultado de <var>E</var> y <var>E_j</var> respecto de <var>x</var>, siendo las <var>E_j</var> el resto de ecuaciones del subsistema <var>S_i</var>. De aquí se obtiene otro subsistema <var>S_i'</var> con una incógnita menos, ya que <var>x</var> ha sido eliminada. El proceso ahora vuelve al paso (1).
</p>
<p>(3) En ocasiones se obtiene un subsistema consistente en una única ecuación. Si la ecuación es multivariante y no se han introducido aproximaciones en formato decimal de coma flotante, entonces  se llama a <code>solve</code> para tratar de encontrar una solución exacta.
</p>
<p>En algunos casos, <code>solve</code> no puede encontrar la solución, o si lo consigue puede que el resultado tenga una expresión muy grande.
</p>
<p>Si la ecuación tiene una sóla incógnita y es lineal, o cuadrática o bicuadrática, entonces se llama a la función <code>solve</code> si no se han introducido aproximaciones en formato decimal. Si se han introducido aproximaciones, o si hay más de una incógnita, o si no es lineal, ni cuadrática ni bicuadrática, y si la variables <code>realonly</code> vale <code>true</code>, entonces se llama a la función <code>realroots</code> para calcular las soluciones reales.  Si
<code>realonly</code> vale <code>false</code>, entonces se llama a <code>allroots</code> para obtener las soluciones reales y complejas.
</p>
<p>Si <code>algsys</code> devuelve una solución que tiene menos dígitos significativos de los requeridos, el usuario puede cambiar a voluntad el valor de <code>algepsilon</code> para obtener mayor precisión.
</p>
<p>Si <code>algexact</code> vale <code>true</code>, se llamará siempre a <code>solve</code>.
</p>
<p>Cuando <code>algsys</code> encuentra una ecuación con múltiples incógnitas y que contiene aproximaciones en coma flotante (normalmente debido a la imposibilidad de encontrar soluciones exactas en pasos anteriores), entonces no intenta aplicar los métodos exactos a estas ecuaciones y presenta el mensaje: 
&quot;<code>algsys</code> cannot solve - system too complicated.&quot;
</p>
<p>Las interacciones con <code>radcan</code> pueden dar lugar a expresiones grandes o complicadas. En tal caso, puede ser posible aislar partes del resultado con  <code>pickapart</code> o <code>reveal</code>.
</p>
<p>Ocasionalmente, <code>radcan</code> puede introducir la unidad imaginaria <code>%i</code> en una solución que de hecho es real.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) e1: 2*x*(1 - a1) - 2*(x - 1)*a2;
(%o1)              2 (1 - a1) x - 2 a2 (x - 1)
(%i2) e2: a2 - a1; 
(%o2)                        a2 - a1
(%i3) e3: a1*(-y - x^2 + 1); 
                                   2
(%o3)                   a1 (- y - x  + 1)
(%i4) e4: a2*(y - (x - 1)^2);
                                       2
(%o4)                   a2 (y - (x - 1) )
(%i5) algsys ([e1, e2, e3, e4], [x, y, a1, a2]);
(%o5) [[x = 0, y = %r1, a1 = 0, a2 = 0], 

                                  [x = 1, y = 0, a1 = 1, a2 = 1]]
(%i6) e1: x^2 - y^2;
                              2    2
(%o6)                        x  - y
(%i7) e2: -1 - y + 2*y^2 - x + x^2;
                         2        2
(%o7)                 2 y  - y + x  - x - 1
(%i8) algsys ([e1, e2], [x, y]);
                 1            1
(%o8) [[x = - -------, y = -------], 
              sqrt(3)      sqrt(3)

        1              1             1        1
[x = -------, y = - -------], [x = - -, y = - -], [x = 1, y = 1]]
     sqrt(3)        sqrt(3)          3        3
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>allroots</b><i> (<var>expr</var>)</i>
<a name="IDX856"></a>
</dt>
<dt><u>Función:</u> <b>allroots</b><i> (<var>eqn</var>)</i>
<a name="IDX857"></a>
</dt>
<dd><p>Calcula aproximaciones numéricas de las raíces reales y complejas del polinomio <var>expr</var> o ecuación polinómica <var>eqn</var> de una variable.
</p>
<p>Si la variable <code>polyfactor</code> vale <code>true</code> hace que la función 
<code>allroots</code> factorice el polinomio para números reales si el polinomio es real, o para números complejos si el polinomio es complejo.
</p>
<p>La función <code>allroots</code> puede dar resultados inexactos en caso de que haya raíces múltiples.
Si el polinomio es real, <code>allroots (%i*<var>p</var>)</code>) puede alcanzar mejores aproximaciones que <code>allroots (<var>p</var>)</code>,
ya que <code>allroots</code> ejecuta entonces un algoritmo diferente.
</p>
<p>La función <code>allroots</code> no opera sobre expresiones no polinómicas, pues requiere que el numerador sea reducible a un polinomio y el denominador sea, como mucho, un número complejo. 
</p>
<p>Para polinomios complejos se utiliza el algoritmo de Jenkins y Traub descrito
en (Algorithm 419, <i>Comm. ACM</i>, vol. 15, (1972), p. 97). Para polinomios 
reales se utiliza el algoritmo de Jenkins descrito en 
(Algorithm 493, <i>ACM TOMS</i>, vol. 1, (1975), p.178).
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) eqn: (1 + 2*x)^3 = 13.5*(1 + x^5);
                            3          5
(%o1)              (2 x + 1)  = 13.5 (x  + 1)
(%i2) soln: allroots (eqn);
(%o2) [x = .8296749902129361, x = - 1.015755543828121, 

x = .9659625152196369 %i - .4069597231924075, 

x = - .9659625152196369 %i - .4069597231924075, x = 1.0]
(%i3) for e in soln
        do (e2: subst (e, eqn), disp (expand (lhs(e2) - rhs(e2))));
                      - 3.5527136788005E-15

                     - 5.32907051820075E-15

         4.44089209850063E-15 %i - 4.88498130835069E-15

        - 4.44089209850063E-15 %i - 4.88498130835069E-15

                       3.5527136788005E-15

(%o3)                         done
(%i4) polyfactor: true$
(%i5) allroots (eqn);
(%o5) - 13.5 (x - 1.0) (x - .8296749902129361)

                           2
 (x + 1.015755543828121) (x  + .8139194463848151 x

 + 1.098699797110288)
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>bfallroots</b><i> (<var>expr</var>)</i>
<a name="IDX858"></a>
</dt>
<dt><u>Función:</u> <b>bfallroots</b><i> (<var>eqn</var>)</i>
<a name="IDX859"></a>
</dt>
<dd><p>Calcula aproximaciones numéricas de las raíces
reales y complejas del polinomio <var>expr</var> o de la ecuación
polinómica <var>eqn</var> de una variable.
</p>
<p>En todos los aspectos, <code>bfallroots</code> es idéntica a <code>allroots</code>,
excepto que <code>bfallroots</code> calcula las raíces en 
formato bigfloat (números decimales de precisión arbitraria).
</p>
<p>Véase <code>allroots</code> para más información.
</p></dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>backsubst</b>
<a name="IDX860"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>backsubst</code> vale <code>false</code>, evita la retrosustitución 
en <code>linsolve</code> tras la triangularización de las ecuaciones. 
Esto puede ser de utilidad en problemas muy grandes, en los que la
retrosustitución puede provocar la generación de expresiones
extremadamente largas.
</p>
<pre class="example">(%i1) eq1 : x + y + z = 6$
(%i2) eq2 : x - y + z = 2$
(%i3) eq3 : x + y - z = 0$
(%i4) backsubst : false$
(%i5) linsolve ([eq1, eq2, eq3], [x,y,z]);
(%o5)             [x = z - y, y = 2, z = 3]
(%i6) backsubst : true$
(%i7) linsolve ([eq1, eq2, eq3], [x,y,z]);
(%o7)               [x = 1, y = 2, z = 3]
</pre>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>breakup</b>
<a name="IDX861"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>breakup</code> vale <code>true</code>, <code>solve</code> expresa sus soluciones a las ecuaciones cúbicas y cuárticas en términos de subexpresiones comunes, las cuales son asignadas a etiquetas del tipo <code>%t1</code>, <code>%t2</code>, etc.
En otro caso, no se identifican subexpresiones comunes.
</p>
<p>La asignación <code>breakup: true</code> sólo tiene efecto cuando <code>programmode</code> vale <code>false</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) programmode: false$
(%i2) breakup: true$
(%i3) solve (x^3 + x^2 - 1);

                        sqrt(23)    25 1/3
(%t3)                  (--------- + --)
                        6 sqrt(3)   54
Solution:

                                      sqrt(3) %i   1
                                      ---------- - -
                sqrt(3) %i   1            2        2   1
(%t4)    x = (- ---------- - -) %t3 + -------------- - -
                    2        2            9 %t3        3

                                      sqrt(3) %i   1
                                    - ---------- - -
              sqrt(3) %i   1              2        2   1
(%t5)    x = (---------- - -) %t3 + ---------------- - -
                  2        2             9 %t3         3

                                   1     1
(%t6)                  x = %t3 + ----- - -
                                 9 %t3   3
(%o6)                    [%t4, %t5, %t6]
(%i6) breakup: false$
(%i7) solve (x^3 + x^2 - 1);
Solution:

             sqrt(3) %i   1
             ---------- - -
                 2        2        sqrt(23)    25 1/3
(%t7) x = --------------------- + (--------- + --)
             sqrt(23)    25 1/3    6 sqrt(3)   54
          9 (--------- + --)
             6 sqrt(3)   54

                                              sqrt(3) %i   1    1
                                           (- ---------- - -) - -
                                                  2        2    3

           sqrt(23)    25 1/3  sqrt(3) %i   1
(%t8) x = (--------- + --)    (---------- - -)
           6 sqrt(3)   54          2        2

                                            sqrt(3) %i   1
                                          - ---------- - -
                                                2        2      1
                                      + --------------------- - -
                                           sqrt(23)    25 1/3   3
                                        9 (--------- + --)
                                           6 sqrt(3)   54

            sqrt(23)    25 1/3             1             1
(%t9)  x = (--------- + --)    + --------------------- - -
            6 sqrt(3)   54          sqrt(23)    25 1/3   3
                                 9 (--------- + --)
                                    6 sqrt(3)   54
(%o9)                    [%t7, %t8, %t9]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>dimension</b><i> (<var>eqn</var>)</i>
<a name="IDX862"></a>
</dt>
<dt><u>Función:</u> <b>dimension</b><i> (<var>eqn_1</var>, ..., <var>eqn_n</var>)</i>
<a name="IDX863"></a>
</dt>
<dd><p>El paquete <code>dimen</code> es para análisis dimensional. La instrucción <code>load (&quot;dimen&quot;)</code> carga el paquete y
<code>demo (&quot;dimen&quot;)</code> presenta una pequeña demostración.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dispflag</b>
<a name="IDX864"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>dispflag</code> vale <code>false</code>, entonces se inhibirá que Maxima muestre resultados de las funciones que resuelven ecuaciones cuando éstas son llamadas desde dentro de un bloque (<code>block</code>). Cuando un bloque termina con el signo del dólar, $, a la variable <code>dispflag</code> se le asigna <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>funcsolve</b><i> (<var>eqn</var>, <var>g</var>(<var>t</var>))</i>
<a name="IDX865"></a>
</dt>
<dd><p>Devuelve <code>[<var>g</var>(<var>t</var>) = ...]</code>  o <code>[]</code>, dependiendo de que exista o no una función racional  <code><var>g</var>(<var>t</var>)</code> que satisfaga <var>eqn</var>, la cual debe ser un polinomio de primer orden, lineal para <code><var>g</var>(<var>t</var>)</code> y <code><var>g</var>(<var>t</var>+1)</code>
</p>
<pre class="example">(%i1) eqn: (n + 1)*f(n) - (n + 3)*f(n + 1)/(n + 1)
                 = (n - 1)/(n + 2);
                            (n + 3) f(n + 1)   n - 1
(%o1)        (n + 1) f(n) - ---------------- = -----
                                 n + 1         n + 2
(%i2) funcsolve (eqn, f(n));

Dependent equations eliminated:  (4 3)
                                   n
(%o2)                f(n) = ---------------
                            (n + 1) (n + 2)
</pre>
<p>Aviso: esta es una implemetación rudimentaria, por lo que debe ser utilizada con cautela.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>globalsolve</b>
<a name="IDX866"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>globalsolve</code> vale <code>true</code>,
a las incógnitas de las ecuaciones se les asignan las soluciones encontradas por <code>linsolve</code> y
por <code>solve</code> cuando se resuelven sistemas de dos o más ecuaciones lineales.
</p>
<p>Si <code>globalsolve</code> vale <code>false</code>,
las soluciones encontradas por <code>linsolve</code> y por <code>solve</code> cuando se resuelven sistemas de dos o más ecuaciones lineales se expresan como ecuaciones y a las incógnitas no se le asignan valores.
</p>
<p>Cuando se resuelven ecuaciones que no son sistemas de dos o más ecuaciones lineales, <code>solve</code> ignora el valor de <code>globalsolve</code>. Otras funciones que resuelven ecuaciones (como <code>algsys</code>) ignoran siempre el valor de <code>globalsolve</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) globalsolve: true$
(%i2) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t2)                        x : --
                                 7

                                   1
(%t3)                        y : - -
                                   7
(%o3)                     [[%t2, %t3]]
(%i3) x;
                               17
(%o3)                          --
                               7
(%i4) y;
                                 1
(%o4)                          - -
                                 7
(%i5) globalsolve: false$
(%i6) kill (x, y)$
(%i7) solve ([x + 3*y = 2, 2*x - y = 5], [x, y]);
Solution

                                 17
(%t7)                        x = --
                                 7

                                   1
(%t8)                        y = - -
                                   7
(%o8)                     [[%t7, %t8]]
(%i8) x;
(%o8)                           x
(%i9) y;
(%o9)                           y
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>ieqn</b><i> (<var>ie</var>, <var>unk</var>, <var>tech</var>, <var>n</var>, <var>guess</var>)</i>
<a name="IDX867"></a>
</dt>
<dd><p>El paquete <code>inteqn</code> se dedica a la resolución de ecuaciones integrales. Para hacer uso de él, ejecutar la instrucción <code>load (&quot;inteqn&quot;)</code>.
</p>
<p>El argumento <var>ie</var> es la ecuación integral; <var>unk</var> es la función incógnita; <var>tech</var> es el método a aplicar para efectuar la resolución del problema (<var>tech</var> = <code>first</code> significa: aplica el primer método que encuentre una solución; <var>tech</var> = <code>all</code> significa: aplica todos los métodos posibles); <var>n</var> es el número máximo de términos que debe tomar <code>taylor</code>, <code>neumann</code>, <code>firstkindseries</code> o <code>fredseries</code> (también es el máximo nivel de recursión para el método de diferenciación); <var>guess</var> es la solución candidata inicial para <code>neumann</code> o <code>firstkindseries</code>.
</p>
<p>Valores por defecto para los argumentos segundo a quinto son:
</p>
<p><var>unk</var>: <code><var>p</var>(<var>x</var>)</code>, donde <var>p</var> es la primera función desconocida que Maxima encuentra en el integrando y <var>x</var> es la variable que actúa como argumento en la primera aparición de <var>p</var> encontrada fuera de una integral en el caso de ecuaciones de segunda especie (<code>secondkind</code>), o es la única variable aparte de la de integración en el caso de ecuaciones de primera especie (<code>firstkind</code>). Si el intento de encontrar <var>x</var> falla, el usuario será consultado para suministrar una variable independiente.
</p>

</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>ieqnprint</b>
<a name="IDX868"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>ieqnprint</code> controla el comportamiento del resultado retornado por la instrucción <code>ieqn</code>. Si <code>ieqnprint</code> vale <code>false</code>, la lista devuelta por la función <code>ieqn</code> tiene el formato
</p>
<p>   [<var>solución</var>, <var>método utilizado</var>, <var>nterms</var>, <var>variable</var>]
</p>
<p>donde <var>variable</var> estará ausente si la solución es exacta; en otro caso, será la palabra <code>approximate</code> o <code>incomplete</code> según que la solución sea inexacta o que no tenga forma explícita, respectivamente. Si se ha utilizado un método basado en series, <var>nterms</var> es el número de términos utilizado, que puede ser menor que el <code>n</code> dado a <code>ieqn</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>lhs</b><i> (<var>expr</var>)</i>
<a name="IDX869"></a>
</dt>
<dd><p>Devuelve el miembro izquierdo (es decir, el primer argumento)
de la expresión <var>expr</var>,
cuando el operador de <var>expr</var> es uno de los operadores
de relación <code>&lt; &lt;= = # equal notequal &gt;= &gt;</code>,
o un operadores de asignación <code>:= ::= : ::</code>,
o un operador infijo binario definido por el usuario mediante <code>infix</code>.
</p>
<p>Si <var>expr</var> es un átomo o si su operador es diferente de los
citados más arriba, <code>lhs</code> devuelve <var>expr</var>.
</p>
<p>Véase también <code>rhs</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [lhs (aa &lt; bb), lhs (aa &lt;= bb), 
       lhs (aa &gt;= bb), lhs (aa &gt; bb)];
(%o4)                   [aa, aa, aa, aa]
(%i5) [lhs (aa = bb), lhs (aa # bb), lhs (equal (aa, bb)),
       lhs (notequal (aa, bb))];
(%o5)                   [aa, aa, aa, aa]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [lhs (e1), lhs (e2), lhs (e3), lhs (e4)];
(%o10)               [foo(x), bar(y), x, x]
(%i11) infix (&quot;][&quot;);
(%o11)                         ][
(%i12) lhs (aa ][ bb);
(%o12)                         aa
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>linsolve</b><i> ([<var>expr_1</var>, ..., <var>expr_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX870"></a>
</dt>
<dd><p>Resuelve la lista de ecuaciones lineales simultáneas para la lista de variables. Las expresiones deben ser polinomios lineales respecto de las variables o ecuaciones.
</p>
<p>Si <code>globalsolve</code> vale <code>true</code>,
a cada incógnita se le asigna el valor de la solución encontrada.
</p>
<p>Si <code>backsubst</code> vale <code>false</code>, <code>linsolve</code>
no hace la sustitución tras la triangulariación de las ecuaciones. 
Esto puede ser necesario en problemas muy grandes en los que la
sustitución puede dar lugar a la generación de expresiones
enormes.
</p>
<p>Si <code>linsolve_params</code> vale <code>true</code>, <code>linsolve</code> también genera símbolos <code>%r</code> para representar parámetros arbitrarios como los descritos para la función <code>algsys</code>. Si vale <code>false</code>, el resultado devuelto por <code>linsolve</code> expresará, si es el sistema es indeterminado, unas variables en función de otras.
</p>
<p>Si <code>programmode</code> vale <code>false</code>,
<code>linsolve</code> muestra la solución con etiquetas de expresiones 
intermedias (<code>%t</code>) y devuelve las lista de etiquetas.
</p>
<pre class="example">(%i1) e1: x + z = y;
(%o1)                       z + x = y
(%i2) e2: 2*a*x - y = 2*a^2;
                                       2
(%o2)                   2 a x - y = 2 a
(%i3) e3: y - 2*z = 2;
(%o3)                      y - 2 z = 2
(%i4) [globalsolve: false, programmode: true];
(%o4)                     [false, true]
(%i5) linsolve ([e1, e2, e3], [x, y, z]);
(%o5)            [x = a + 1, y = 2 a, z = a - 1]
(%i6) [globalsolve: false, programmode: false];
(%o6)                    [false, false]
(%i7) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t7)                       z = a - 1

(%t8)                        y = 2 a

(%t9)                       x = a + 1
(%o9)                    [%t7, %t8, %t9]
(%i9) ''%;
(%o9)            [z = a - 1, y = 2 a, x = a + 1]
(%i10) [globalsolve: true, programmode: false];
(%o10)                    [true, false]
(%i11) linsolve ([e1, e2, e3], [x, y, z]);
Solution

(%t11)                      z : a - 1

(%t12)                       y : 2 a

(%t13)                      x : a + 1
(%o13)                 [%t11, %t12, %t13]
(%i13) ''%;
(%o13)           [z : a - 1, y : 2 a, x : a + 1]
(%i14) [x, y, z];
(%o14)                 [a + 1, 2 a, a - 1]
(%i15) [globalsolve: true, programmode: true];
(%o15)                    [true, true]
(%i16) linsolve ([e1, e2, e3], '[x, y, z]);
(%o16)           [x : a + 1, y : 2 a, z : a - 1]
(%i17) [x, y, z];
(%o17)                 [a + 1, 2 a, a - 1]
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>linsolvewarn</b>
<a name="IDX871"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>linsolvewarn</code> vale <code>true</code>, <code>linsolve</code> mostrará el mensaje: &quot;Dependent equations eliminated&quot;.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>linsolve_params</b>
<a name="IDX872"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>linsolve_params</code> vale <code>true</code>, <code>linsolve</code> también genera símbolos <code>%r</code> para representar parámetros arbitrarios como los descritos para la función <code>algsys</code>. Si vale <code>false</code>, el resultado devuelto por <code>linsolve</code> expresará, si es el sistema es indeterminado, unas variables en función de otras.
</p>
</dd></dl>

<dl>
<dt><u>System variable:</u> <b>multiplicities</b>
<a name="IDX873"></a>
</dt>
<dd><p>Valor por defecto: <code>not_set_yet</code>
</p>
<p>La variable <code>multiplicities</code> es una con las multiplicidades de las soluciones encontradas por <code>solve</code> o
<code>realroots</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>nroots</b><i> (<var>p</var>, <var>low</var>, <var>high</var>)</i>
<a name="IDX874"></a>
</dt>
<dd><p>Devuelve el número de raíces reales del polinomio real univariante <var>p</var> en el intervalo semiabierto
<code>(<var>low</var>, <var>high</var>]</code>. Los extremos del intervalo pueden ser <code>minf</code> o <code>inf</code>, menos y más infinito.
</p>
<p>La función <code>nroots</code> utiliza el método de las secuencias de Sturm.
</p>
<pre class="example">(%i1) p: x^10 - 2*x^4 + 1/2$
(%i2) nroots (p, -6, 9.1);
(%o2)                           4
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>nthroot</b><i> (<var>p</var>, <var>n</var>)</i>
<a name="IDX875"></a>
</dt>
<dd><p>Siendo <code>p</code> un polinomio de coeficientes enteros y <code>n</code> un entero positivo, <code>nthroot</code> devuelve un polinomio <code>q</code>, también de coeficientes enteros, tal que <code>q^n=p</code>, o un mensaje de error indicando que <code>p</code> no es una <code>n</code>-potencia exacta. Esta función es bastante más rápida que <code>factor</code> y que <code>sqfr</code>.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>polyfactor</b>
<a name="IDX876"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>polyfactor</code> vale <code>true</code>, las funciones
<code>allroots</code> y <code>bfallroots</code> factorizan el polinomio
sobre los números reales si el polinomio es real, o
factoriza sobre los complejos si el polinomio es complejo.
</p>
<p>Véase un ejemplo en <code>allroots</code>.
</p></dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>programmode</b>
<a name="IDX877"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>programmode</code> vale <code>true</code>, <code>solve</code>, <code>realroots</code>, <code>allroots</code> y <code>linsolve</code>
devuelve sus soluciones como elementos de una lista. </p>
<p>Si <code>programmode</code> vale <code>false</code>, <code>solve</code> y las demás crean expresiones intermedias etiquetadas <code>%t1</code>, <code>t2</code>, etc., y les asinan las soluciones.
</p>
<pre class="example">(%i1) solve(x^2+x+1);
                    sqrt(3) %i + 1      sqrt(3) %i - 1
(%o1)        [x = - --------------, x = --------------]
                          2                   2
(%i2) programmode:false$
(%i3) solve(x^2+x+1);
Solution:

                              sqrt(3) %i + 1
(%t3)                   x = - --------------
                                    2

                             sqrt(3) %i - 1
(%t4)                    x = --------------
                                   2
(%o4)                        [%t4, %t5]
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>realonly</b>
<a name="IDX878"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>realonly</code> vale <code>true</code>, <code>algsys</code> sólo devuelve aquellas soluciones exentas de la constante <code>%i</code>.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>realroots</b><i> (<var>expr</var>, <var>bound</var>)</i>
<a name="IDX879"></a>
</dt>
<dt><u>Función:</u> <b>realroots</b><i> (<var>eqn</var>, <var>bound</var>)</i>
<a name="IDX880"></a>
</dt>
<dt><u>Función:</u> <b>realroots</b><i> (<var>expr</var>)</i>
<a name="IDX881"></a>
</dt>
<dt><u>Función:</u> <b>realroots</b><i> (<var>eqn</var>)</i>
<a name="IDX882"></a>
</dt>
<dd><p>Calcula aproximaciones racionales de las raíces reales del
polinomio <var>expr</var> o de la ecuación polinómica <var>eqn</var> de una variable,
dentro de la tolerancia especificada por <var>bound</var>.
Los coeficientes de <var>expr</var> o de <var>eqn</var> deben ser números literales,
por lo que las constantes simbólicas como <code>%pi</code> no son aceptadas.
</p>
<p>La función <code>realroots</code> guarda las multiplicidades de las
raíces encontradas en la variable global <code>multiplicities</code>.
</p>
<p>La función <code>realroots</code> genera una secuencia de Sturm para acotar cada
raíz, aplicando después el método de bisección para
afinar las aproximaciones. Todos los coeficientes se convierten a formas
racionales equivalentes antes de comenzar la búsqueda de las raíces,
de modo que los cálculos se realizan con aritmética exacta racional. Incluso en
el caso de que algunos coeficientes sean números decimales en coma flotante, los
resultados son racionales, a menos que se les fuerce a ser decimales con las variables
<code>float</code> o <code>numer</code>.
</p>
<p>Si <var>bound</var> es menor que la unidad, todas las raíces enteras se expresan
en forma exacta. Si no se especifica <var>bound</var>, se le supone igual al valor de la
variable global <code>rootsepsilon</code>.
</p>
<p>Si la variable global <code>programmode</code> vale <code>true</code>, la función 
<code>realroots</code> devuelve una lista de la forma <code>[x = <var>x_1</var>, x = <var>x_2</var>, ...]</code>.
Si <code>programmode</code> vale <code>false</code>, <code>realroots</code> crea etiquetas 
<code>%t1</code>, <code>%t2</code>, ... para las expresiones intermedias, les asigna valores y, finalmente,
devuelve la lista de etiquetas.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) realroots (-1 - x + x^5, 5e-6);
                               612003
(%o1)                     [x = ------]
                               524288
(%i2) ev (%[1], float);
(%o2)                 x = 1.167303085327148
(%i3) ev (-1 - x + x^5, %);
(%o3)                - 7.396496210176905E-6
</pre>

<pre class="example">(%i1) realroots (expand ((1 - x)^5 * (2 - x)^3 * (3 - x)), 1e-20);
(%o1)                 [x = 1, x = 2, x = 3]
(%i2) multiplicities;
(%o2)                       [5, 3, 1]
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>rhs</b><i> (<var>expr</var>)</i>
<a name="IDX883"></a>
</dt>
<dd><p>Devuelve el miembro derecho (es decir, el segundo argumento)
de la expresión <var>expr</var>,
cuando el operador de <var>expr</var> es uno de los operadores
de relación <code>&lt; &lt;= = # equal notequal &gt;= &gt;</code>,
o un operadores de asignación <code>:= ::= : ::</code>,
o un operador infijo binario definido por el usuario mediante <code>infix</code>.
</p>
<p>Si <var>expr</var> es un átomo o si su operador es diferente de los
citados más arriba, <code>rhs</code> devuelve <var>expr</var>.
</p>
<p>Véase también <code>lhs</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) e: aa + bb = cc;
(%o1)                     bb + aa = cc
(%i2) lhs (e);
(%o2)                        bb + aa
(%i3) rhs (e);
(%o3)                          cc
(%i4) [rhs (aa &lt; bb), rhs (aa &lt;= bb),
       rhs (aa &gt;= bb), rhs (aa &gt; bb)];
(%o4)                   [bb, bb, bb, bb]
(%i5) [rhs (aa = bb), rhs (aa # bb), rhs (equal (aa, bb)),
       rhs (notequal (aa, bb))];
(%o5)                   [bb, bb, bb, bb]
(%i6) e1: '(foo(x) := 2*x);
(%o6)                     foo(x) := 2 x
(%i7) e2: '(bar(y) ::= 3*y);
(%o7)                    bar(y) ::= 3 y
(%i8) e3: '(x : y);
(%o8)                         x : y
(%i9) e4: '(x :: y);
(%o9)                        x :: y
(%i10) [rhs (e1), rhs (e2), rhs (e3), rhs (e4)];
(%o10)                  [2 x, 3 y, y, y]
(%i11) infix (&quot;][&quot;);
(%o11)                         ][
(%i12) rhs (aa ][ bb);
(%o12)                         bb
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>rootsconmode</b>
<a name="IDX884"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>La variable <code>rootsconmode</code> controla el comportamiento de la instrucción <code>rootscontract</code>.  Véase <code>rootscontract</code> para más detalles.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>rootscontract</b><i> (<var>expr</var>)</i>
<a name="IDX885"></a>
</dt>
<dd><p>Convierte productos de raíces en raíces de productos. Por ejemplo, <code>rootscontract (sqrt(x)*y^(3/2))</code> devuelve <code>sqrt(x*y^3)</code>.
</p>
<p>Si <code>radexpand</code> vale <code>true</code> y <code>domain</code> vale <code>real</code>,
<code>rootscontract</code> convierte <code>abs</code> en <code>sqrt</code>, por ejemplo,
<code>rootscontract (abs(x)*sqrt(y))</code> devuelve <code>sqrt(x^2*y)</code>.
</p>
<p>La opción <code>rootsconmode</code> afecta el resultado de <code>rootscontract</code> como sigue:
</p>
<pre class="example">Problema            Valor de         Resultadod de
                  rootsconmode        rootscontract
      
x^(1/2)*y^(3/2)      false          (x*y^3)^(1/2)
x^(1/2)*y^(1/4)      false          x^(1/2)*y^(1/4)
x^(1/2)*y^(1/4)      true           (x*y^(1/2))^(1/2)
x^(1/2)*y^(1/3)      true           x^(1/2)*y^(1/3)
x^(1/2)*y^(1/4)      all            (x^2*y)^(1/4)
x^(1/2)*y^(1/3)      all            (x^3*y^2)^(1/6)
</pre>
<p>Si <code>rootsconmode</code> vale <code>false</code>, <code>rootscontract</code> contrae sólamente respecto de exponentes racionales cuyos denominadores sean iguales. La clave para los ejemplos <code>rootsconmode: true</code> es simplemente que 2 divide a 4 pero no a 3. La asignación <code>rootsconmode: all</code> hace que se calcule el mínimo común múltiplo de los denominadores de los exponentes.
</p>
<p>La función <code>rootscontract</code> utiliza <code>ratsimp</code> de forma similar a como lo hace <code>logcontract</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) rootsconmode: false$
(%i2) rootscontract (x^(1/2)*y^(3/2));
                                   3
(%o2)                      sqrt(x y )
(%i3) rootscontract (x^(1/2)*y^(1/4));
                                   1/4
(%o3)                     sqrt(x) y
(%i4) rootsconmode: true$
(%i5) rootscontract (x^(1/2)*y^(1/4));
(%o5)                    sqrt(x sqrt(y))
(%i6) rootscontract (x^(1/2)*y^(1/3));
                                   1/3
(%o6)                     sqrt(x) y
(%i7) rootsconmode: all$
(%i8) rootscontract (x^(1/2)*y^(1/4));
                              2   1/4
(%o8)                       (x  y)
(%i9) rootscontract (x^(1/2)*y^(1/3));
                             3  2 1/6
(%o9)                      (x  y )
(%i10) rootsconmode: false$
(%i11) rootscontract (sqrt(sqrt(x) + sqrt(1 + x))
                    *sqrt(sqrt(1 + x) - sqrt(x)));
(%o11)                          1
(%i12) rootsconmode: true$
(%i13) rootscontract (sqrt(5 + sqrt(5)) - 5^(1/4)*sqrt(1 + sqrt(5)));
(%o13)                          0
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>rootsepsilon</b>
<a name="IDX886"></a>
</dt>
<dd><p>Valor por defecto: 1.0e-7
</p>
<p>La variable <code>rootsepsilon</code> es la tolerancia que establece el intervalo de confianza para las raíces calculadas por la función <code>realroots</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>solve</b><i> (<var>expr</var>, <var>x</var>)</i>
<a name="IDX887"></a>
</dt>
<dt><u>Función:</u> <b>solve</b><i> (<var>expr</var>)</i>
<a name="IDX888"></a>
</dt>
<dt><u>Función:</u> <b>solve</b><i> ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX889"></a>
</dt>
<dd><p>Resuelve la ecuación algebraica <var>expr</var> de incógnita <var>x</var> y devuelve una lista de igualdades con la <var>x</var> despejada.  Si <var>expr</var> no es una igualdad, se supone que se quiere resolver la ecuación <code><var>expr</var> = 0</code>.
El argumento <var>x</var> puede ser una función (por ejemplo, <code>f(x)</code>), u otra expresión no atómica, excepto una suma o producto. Puede omitirse <var>x</var> si <var>expr</var> contiene solamente una variable. El argumento <var>expr</var> puede ser una expresión racional y puede contener funciones trigonométricas, exponenciales, etc.
</p>
<p>Se utiliza el siguiente método de resolución:
</p>
<p>Sea <var>E</var> la expresión y <var>X</var> la incógnita. Si <var>E</var> es lineal respecto de <var>X</var> entonces <var>X</var> se resuelve de forma trivial. En caso contrario, si <var>E</var> es de la forma <code>A*X^N + B</code> entonces el resultado es <code>(-B/A)^1/N)</code> multiplicado por las <code>N</code>-ésimas raíces de la unidad.
</p>
<p>Si <var>E</var> no es lineal respecto de <var>X</var> entonces el máximo común divisor de los exponentes de <var>X</var> en <var>E</var> (supóngase que es <var>N</var>) se divide entre los exponentes y la multiplicidad de las raíces se multiplica por <var>N</var>.  Entonces es llamado recursivamente <code>solve</code> para este resultado. Si <var>E</var> es factorizable entonces <code>solve</code> es invocado para cada uno de los factores.  Finalmente, <code>solve</code> usará, según sea necesario, las fórmulas cuadrática, cúbica o cuártica.
</p>
<p>En caso de que <var>E</var> sea un polinomio respecto de una función de la incógnita, por ejemplo <code>F(X)</code>, entonces se calcula primero para  <code>F(X)</code> (sea <var>C</var> el resultado obtenido), entonces la ecuación <code>F(X)=C</code> se resuelve para <var>X</var> en el supuesto que se conozca la inversa de la función <var>F</var>.
</p>
<p>Si la variable <code>breakup</code> vale <code>false</code> hará que <code>solve</code> muestre las soluciones de las ecuaciones cúbicas o cuárticas como expresiones únicas, en lugar de utilizar varias subexpresiones comunes, que es el formato por defecto.
</p>
<p>A la variable <code>multiplicities</code> se le asignará una lista con las multiplicidades de las soluciones individuales devueltas por <code>solve</code>, <code>realroots</code> o <code>allroots</code>. La instrucción <code>apropos (solve)</code> hará que se muestren las variables optativas que de algún modo afectan al comportamiento de <code>solve</code>. Se podrá luego utilizar la función  <code>describe</code> para aquellas variables cuyo objeto no esté claro.
</p>
<p>La llamada <code>solve ([<var>eqn_1</var>, ..., <var>eqn_n</var>], [<var>x_1</var>, ..., <var>x_n</var>])</code>
resuelve un sistema de ecuaciones polinómicas simultáneas (lineales o no) llamando a <code>linsolve</code> o <code>algsys</code> y devuelve una lista de listas con soluciones para las incógnitas. En caso de haberse llamado a <code>linsolve</code> esta lista contendrá una única lista de soluciones. La llamada a <code>solve</code> tiene dos listas como argumentos. La primera lista tiene las ecuaciones a resolver y la segunda son las incógnitas cuyos valores se quieren calcular. Si el número de variables en las ecuaciones es igual al número de incógnitas, el segundo argumento puede omitirse.
</p>
<p>Si <code>programmode</code> vale <code>false</code>,
<code>solve</code> muestra la solución con etiquetas de expresiones 
intermedias (<code>%t</code>) y devuelve las lista de etiquetas.
</p>

<p>Si <code>globalsolve</code> vale <code>true</code> y el problema consiste en resolver un sistema de dos o más ecuaciones lineales, a cada incógnita se le asigna el valor encontrado en la resolución del sistema.
</p>
<p>Ejemplos:
</p><pre class="example">(%i1) solve (asin (cos (3*x))*(f(x) - 1), x);

SOLVE is using arc-trig functions to get a solution.
Some solutions will be lost.
                            %pi
(%o1)                  [x = ---, f(x) = 1]
                             6
(%i2) ev (solve (5^f(x) = 125, f(x)), solveradcan);
                                log(125)
(%o2)                   [f(x) = --------]
                                 log(5)
(%i3) [4*x^2 - y^2 = 12, x*y - x = 2];
                      2    2
(%o3)             [4 x  - y  = 12, x y - x = 2]
(%i4) solve (%, [x, y]);
(%o4) [[x = 2, y = 2], [x = .5202594388652008 %i

 - .1331240357358706, y = .0767837852378778

 - 3.608003221870287 %i], [x = - .5202594388652008 %i

 - .1331240357358706, y = 3.608003221870287 %i

 + .0767837852378778], [x = - 1.733751846381093, 

y = - .1535675710019696]]
(%i5) solve (1 + a*x + x^3, x);
                                       3
              sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(%o5) [x = (- ---------- - -) (--------------- - -)
                  2        2      6 sqrt(3)      2

        sqrt(3) %i   1
       (---------- - -) a
            2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

                          3
 sqrt(3) %i   1   sqrt(4 a  + 27)   1 1/3
(---------- - -) (--------------- - -)
     2        2      6 sqrt(3)      2

         sqrt(3) %i   1
      (- ---------- - -) a
             2        2
 - --------------------------, x = 
              3
      sqrt(4 a  + 27)   1 1/3
   3 (--------------- - -)
         6 sqrt(3)      2

         3
 sqrt(4 a  + 27)   1 1/3               a
(--------------- - -)    - --------------------------]
    6 sqrt(3)      2                  3
                              sqrt(4 a  + 27)   1 1/3
                           3 (--------------- - -)
                                 6 sqrt(3)      2
(%i6) solve (x^3 - 1);
             sqrt(3) %i - 1        sqrt(3) %i + 1
(%o6)   [x = --------------, x = - --------------, x = 1]
                   2                     2
(%i7) solve (x^6 - 1);
           sqrt(3) %i + 1      sqrt(3) %i - 1
(%o7) [x = --------------, x = --------------, x = - 1, 
                 2                   2

                     sqrt(3) %i + 1        sqrt(3) %i - 1
               x = - --------------, x = - --------------, x = 1]
                           2                     2
(%i8) ev (x^6 - 1, %[1]);
                                      6
                      (sqrt(3) %i + 1)
(%o8)                 ----------------- - 1
                             64
(%i9) expand (%);
(%o9)                           0
(%i10) x^2 - 1;
                              2
(%o10)                       x  - 1
(%i11) solve (%, x);
(%o11)                  [x = - 1, x = 1]
(%i12) ev (%th(2), %[1]);
(%o12)                          0
</pre>
<p>Los í <code>%r</code> se utilizan para indicar parámetros en
las soluciones.
</p>
<pre class="example">(%i1) solve([x+y=1,2*x+2*y=2],[x,y]);

solve: dependent equations eliminated: (2)
(%o1)                      [[x = 1 - %r1, y = %r1]]
</pre>
<p>Véanse <code>algsys</code> y <code>%rnum_list</code> para más información.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solvedecomposes</b>
<a name="IDX890"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>solvedecomposes</code> vale <code>true</code>, <code>solve</code> llama a <code>polydecomp</code> en caso de que se le pida resolver ecuaciones polinómicas.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solveexplicit</b>
<a name="IDX891"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>solveexplicit</code> vale <code>true</code>, le inhibe a <code>solve</code> devolver soluciones implícitas, esto es, soluciones de la forma <code>F(x) = 0</code>, donde <code>F</code> es cierta función.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solvefactors</b>
<a name="IDX892"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>solvefactors</code> vale <code>false</code>, <code>solve</code> no intenta factorizar la expresión.  Este valor <code>false</code> puede ser útil en algunos casos en los que la factorización no es necesaria.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solvenullwarn</b>
<a name="IDX893"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>solvenullwarn</code> vale <code>true</code>,  <code>solve</code> muestra un mensaje de aviso si es llamado con una lista de ecuaciones vacía o con una lista de incógnitas vacía. Por ejemplo, <code>solve ([], [])</code> imprimirá dos mensajes de aviso y devolverá <code>[]</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solveradcan</b>
<a name="IDX894"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>solveradcan</code> vale <code>true</code>, <code>solve</code> llama a <code>radcan</code>, lo que hará que <code>solve</code> se ejecute de forma más lenta, pero permitirá que se resuelvan ciertas ecuaciones que contengan exponenciales y logaritmos.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>solvetrigwarn</b>
<a name="IDX895"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>solvetrigwarn</code> vale <code>true</code>, <code>solve</code> puede presentar un mensaje diciendo que está utilizando funciones trigonométricas inversas para resolver la ecuación, y que por lo tanto puede estar ignorando algunas soluciones.
</p>
</dd></dl>



<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC116" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_21.html#SEC118" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>abril, 9 2015</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
