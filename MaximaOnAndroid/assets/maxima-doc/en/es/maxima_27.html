<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on abril, 9 2015 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.36.0: 27. atensor</title>

<meta name="description" content="Manual de Maxima 5.36.0: 27. atensor">
<meta name="keywords" content="Manual de Maxima 5.36.0: 27. atensor">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="atensor"></a>
<a name="SEC163"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_26.html#SEC162" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC164" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_26.html#SEC150" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC166" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 27. atensor </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC164">27.1 Introducción a atensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC165">27.2 Funciones y variables para atensor</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-atensor"></a>
<a name="SEC164"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC163" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC165" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC163" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC163" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC166" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 27.1 Introducción a atensor </h2>

<p>El paquete <code>atensor</code> contiene funciones para la manipulación algebraica de tensores. Para hacer uso de <code>atensor</code> es necesario cargarlo en memoria haciendo <code>load(atensor)</code>, seguido de una llamada a la función  <code>init_atensor</code>.
</p>
<p>La parte más importante de <code>atensor</code> es una batería de reglas de simplificación para el producto no conmutativo (&quot;<code>.</code>&quot;). El paquete <code>atensor</code> reconoce algunos tipos de álgebras; las correspondientes reglas de simplificación se activan tan pronto como se hace una llamada a la función <code>init_atensor</code>.
</p>
<p>Las capacidades de <code>atensor</code> se pueden demostrar definiendo el álgebra de cuaterniones como un álgebra de Clifford Cl(0,2) con una base de dos vectores. Las tres unidades imaginarias son los dos vectores de la base junto con su producto:
</p>
<pre class="example">    i = v     j = v     k = v  . v
         1         2         1    2
</pre>
<p>Aunque el paquete <code>atensor</code> incluye su propia definición para el álgebra de cuaterniones, no se utiliza en el siguiente ejemplo, en el cual se construye la tabla de multiplicación como una matriz:
</p>
<pre class="example">
(%i1) load(atensor);
(%o1)       /share/tensor/atensor.mac
(%i2) init_atensor(clifford,0,0,2);
(%o2)                                done
(%i3) atensimp(v[1].v[1]);
(%o3)                                 - 1
(%i4) atensimp((v[1].v[2]).(v[1].v[2]));
(%o4)                                 - 1
(%i5) q:zeromatrix(4,4);
                                [ 0  0  0  0 ]
                                [            ]
                                [ 0  0  0  0 ]
(%o5)                           [            ]
                                [ 0  0  0  0 ]
                                [            ]
                                [ 0  0  0  0 ]
(%i6) q[1,1]:1;
(%o6)                                  1
(%i7) for i thru adim do q[1,i+1]:q[i+1,1]:v[i];
(%o7)                                done
(%i8) q[1,4]:q[4,1]:v[1].v[2];
(%o8)                               v  . v
                                     1    2
(%i9) for i from 2 thru 4 do for j from 2 thru 4 do
      q[i,j]:atensimp(q[i,1].q[1,j]);
(%o9)                                done
(%i10) q;
                   [    1        v         v      v  . v  ]
                   [              1         2      1    2 ]
                   [                                      ]
                   [   v         - 1     v  . v    - v    ]
                   [    1                 1    2      2   ]
(%o10)             [                                      ]
                   [   v      - v  . v     - 1      v     ]
                   [    2        1    2              1    ]
                   [                                      ]
                   [ v  . v      v        - v       - 1   ]
                   [  1    2      2          1            ]
</pre>
<p>El paquete <code>atensor</code> reconoce como vectores de la base símbolos indexados, donde el símbolo es el almacenado en  <code>asymbol</code> y el índice va desde 1 hasta <code>adim</code>. Para símbolos indexados, y sólo para ellos, se evalúan las formas bilineales <code>sf</code>, <code>af</code> y <code>av</code>. La evaluación sustituye el valor de <code>aform[i,j]</code> en lugar de <code>fun(v[i],v[j])</code>, donde <code>v</code> representa el valor de <code>asymbol</code> y <code>fun</code> es  <code>af</code> o <code>sf</code>; o sustituye <code>v[aform[i,j]]</code> en lugar de <code>av(v[i],v[j])</code>.
</p>
<p>Huelga decir que las funciones <code>sf</code>, <code>af</code> y <code>av</code> pueden volver a definirse.
</p>
<p>Cuando se carga el paquete <code>atensor</code> se hacen las siguientes asignaciones de variables:
</p>
<pre class="example">dotscrules:true;
dotdistrib:true;
dotexptsimp:false;
</pre>
<p>Si se quiere experimentar con una álgebra no asociativa, también se puede igualar la variable  <code>dotassoc</code> a <code>false</code>. En tal caso, sin embargo, <code>atensimp</code> no será siempre capaz de realizar las simplificaciones deseadas.
</p>

<hr size="6">
<a name="Funciones-y-variables-para-atensor"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC164" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC166" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC163" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC163" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC166" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>

<a name="SEC165"></a>
<h2 class="section"> 27.2 Funciones y variables para atensor </h2>

<dl>
<dt><u>Función:</u> <b>init_atensor</b><i> (<var>alg_type</var>, <var>opt_dims</var>)</i>
<a name="IDX1177"></a>
</dt>
<dt><u>Función:</u> <b>init_atensor</b><i> (<var>alg_type</var>)</i>
<a name="IDX1178"></a>
</dt>
<dd><p>Inicializa el paquete <code>atensor</code> con el tipo de álgebra especificado, <var>alg_type</var>, que puede ser una de las siguientes:
</p>
<p><code>universal</code>: El álgebra universal no tiene reglas de conmutación.
</p>
<p><code>grassmann</code>: El álgebra de Grassman se define mediante la relación de conmutación <code>u.v+v.u=0</code>.
</p>
<p><code>clifford</code>: El álgebra de Clifford se define mediante la regla de conmutación  <code>u.v+v.u=-2*sf(u,v)</code> donde  <code>sf</code> es una función escalar simétrica. Para esta álgebra,  <var>opt_dims</var> puede contener hasta tres enteros no negativos, que representan el número de dimensiones positivas, degeneradas y negativas, respectivamente, de esta álgebra. Si se suministran los valores de <var>opt_dims</var>, <code>atensor</code> configurará los valores de <code>adim</code> y <code>aform</code> de forma apropiada. En otro caso, <code>adim</code> tomará por defecto el valor 0 y <code>aform</code> no se definirá.
</p>
<p><code>symmetric</code>: El álgebra simétrica se define mediante la regla de conmutación <code>u.v-v.u=0</code>.
</p>
<p><code>symplectic</code>: El álgebra simpléctica se define mediante la regla de conmutación <code>u.v-v.u=2*af(u,v)</code>, donde <code>af</code> es una función escalar antisimétrica. Para el álgebra simpléctica, <var>opt_dims</var> puede contener hasta dos enteros no negativos, que representan las dimensiones no degeneradas y degeneradas, respectivamente. Si se suministran los valores de <var>opt_dims</var>, <code>atensor</code> configurará los valores de <code>adim</code> y <code>aform</code> de forma apropiada. En otro caso, <code>adim</code> tomará por defecto el valor 0 y <code>aform</code> no se definirá.
</p>
<p><code>lie_envelop</code>: El álgebra de la envolvente de Lie se define mediante la regla de conmutación <code>u.v-v.u=2*av(u,v)</code>, donde <code>av</code> es una función antisimétrica.
</p>
<p>La función <code>init_atensor</code> también reconoce algunos tipos de álgebras predefinidas:
</p>
<p><code>complex</code> implementa el álgebra de números complejos como un álgebra de Clifford Cl(0,1). La llamada  <code>init_atensor(complex)</code> equivale a <code>init_atensor(clifford,0,0,1)</code>.
</p>
<p><code>quaternion</code> implementa el álgebra de cuaterniones. La llamada <code>init_atensor(quaternion)</code> equivale a
<code>init_atensor(clifford,0,0,2)</code>.
</p>
<p><code>pauli</code> implementa el álgebra de Pauli como un álgebra de Clifford Cl(3,0). La llamada <code>init_atensor(pauli)</code> equivale a <code>init_atensor(clifford,3)</code>.
</p>
<p><code>dirac</code> implementa el álgebra de Dirac como un álgebra de Clifford Cl(3,1). La llamada <code>init_atensor(dirac)</code> equivale a <code>init_atensor(clifford,3,0,1)</code>.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>atensimp</b><i> (<var>expr</var>)</i>
<a name="IDX1179"></a>
</dt>
<dd><p>Simplifica la expresión algebraica de un tensor  <var>expr</var> de acuerdo con las reglas configuradas mediante una llamada a  <code>init_atensor</code>. La simplificación incluye la aplicación recursiva de las reglas de conmutación y llamadas a <code>sf</code>, <code>af</code> y <code>av</code> siempre que sea posible. Se utiliza un algoritmo que asegure que la función termina siempre, incluso en el caso de expresiones complejas.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>alg_type</b>
<a name="IDX1180"></a>
</dt>
<dd><p>Tipo de álgebra. Valores válidos son <code>universal</code>, <code>grassmann</code>,
<code>clifford</code>, <code>symmetric</code>, <code>symplectic</code> y <code>lie_envelop</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>adim</b>
<a name="IDX1181"></a>
</dt>
<dd><p>Valor por defecto: 0
</p>
<p>La dimensión del álgebra. El paquete <code>atensor</code> utiliza el valor de <code>adim</code> para determinar si un objeto indexado es un vector válido para la base. Véase <code>abasep</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>aform</b>
<a name="IDX1182"></a>
</dt>
<dd><p>Valor por defecto: <code>ident(3)</code>
</p>
<p>Valores por defecto para las formas bilineales  <code>sf</code>, <code>af</code> y <code>av</code>. El valor por defecto es la matriz identidad <code>ident(3)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable:</u> <b>asymbol</b>
<a name="IDX1183"></a>
</dt>
<dd><p>Valor por defecto: <code>v</code>
</p>
<p>Símbolo para los vectores base.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>sf</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1184"></a>
</dt>
<dd><p>Una función escalar simétrica que se utiliza en relaciones de conmutación. La implementación por defecto analiza si los dos argumentos son vectores base mediante  <code>abasep</code> y en tal caso sustituye el valor correspondiente de la matriz  <code>aform</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>af</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1185"></a>
</dt>
<dd><p>Una función escalar antisimétrica que se utiliza en relaciones de conmutación. La implementación por defecto analiza si los dos argumentos son vectores base mediante  <code>abasep</code> y en tal caso sustituye el valor correspondiente de la matriz  <code>aform</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>av</b><i> (<var>u</var>, <var>v</var>)</i>
<a name="IDX1186"></a>
</dt>
<dd><p>Una función antisimétrica que se utiliza en relaciones de conmutación. La implementación por defecto analiza si los dos argumentos son vectores base mediante  <code>abasep</code> y en tal caso sustituye el valor correspondiente de la matriz  <code>aform</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) load(atensor);
(%o1)       /share/tensor/atensor.mac
(%i2) adim:3;
(%o2)                                  3
(%i3) aform:matrix([0,3,-2],[-3,0,1],[2,-1,0]);
                               [  0    3   - 2 ]
                               [               ]
(%o3)                          [ - 3   0    1  ]
                               [               ]
                               [  2   - 1   0  ]
(%i4) asymbol:x;
(%o4)                                  x
(%i5) av(x[1],x[2]);
(%o5)                                 x
                                       3
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>abasep</b><i> (<var>v</var>)</i>
<a name="IDX1187"></a>
</dt>
<dd><p>Analiza si su argumento es un vector base en <code>atensor</code>. Esto es, si se trata de un símbolo indexado, siendo el símbolo el mismo que el valor de <code>asymbol</code> y si el índice tiene un valor numérico entre 1 y <code>adim</code>.
</p>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC163" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_28.html#SEC166" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>abril, 9 2015</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
