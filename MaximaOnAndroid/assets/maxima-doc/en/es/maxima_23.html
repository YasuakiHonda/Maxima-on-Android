<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on abril, 9 2015 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Manual de Maxima 5.36.0: 23. Matrices y Álgebra Lineal</title>

<meta name="description" content="Manual de Maxima 5.36.0: 23. Matrices y Álgebra Lineal">
<meta name="keywords" content="Manual de Maxima 5.36.0: 23. Matrices y Álgebra Lineal">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="../figures/favicon.ico"/>
</head>

<body lang="es" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Matrices-y-_00c1lgebra-Lineal"></a>
<a name="SEC127"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_22.html#SEC126" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_22.html#SEC121" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC133" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 23. Matrices y Álgebra Lineal </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC128">23.1 Introducción a las matrices y el álgebra lineal</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC132">23.2 Funciones y variables para las matrices y el álgebra lineal</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Introducci_00f3n-a-las-matrices-y-el-_00e1lgebra-lineal"></a>
<a name="SEC128"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC127" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC129" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC127" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC127" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC133" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 23.1 Introducción a las matrices y el álgebra lineal </h2>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC129">23.1.1 Operador punto</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                         
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC130">23.1.2 Vectores</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">                     
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC131">23.1.3 Paquete eigen</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr size="6">
<a name="Operador-punto"></a>
<a name="SEC129"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC128" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC130" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC127" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC133" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 23.1.1 Operador punto </h3>
<p>El operador  <code>.</code> realiza la multiplicación matricial y el producto escalar.
Cuando los operandos son dos matrices columna o matrices fila <code>a</code> y <code>b</code>,
la expresión <code>a.b</code> es equivalente a <code>sum (a[i]*b[i], i, 1, length(a))</code>.
Si <code>a</code> y <code>b</code> no son complejos, estamos en el caso del producto escalar.
En caso de ser <code>a</code> y <code>b</code> vectores en el campo complejo, el producto 
escalar se define como <code>conjugate(a).b</code>; la función <code>innerproduct</code> del
paquete <code>eigen</code> realiza el producto escalar complejo.
</p>
<p>Cuando los operandos son matrices de índole más general,
el resultado que se obtiene es el producto matricial de <code>a</code> por <code>b</code>.
El número de filas de <code>b</code> debe ser igual al número de columnas de <code>a</code>,
y el resultado tiene un número de filas igual al de <code>a</code> y un número de
columnas igual al de <code>b</code>.
</p>
<p>Al objeto de distinguir <code>.</code> como operador aritmético del punto decimal
de la notación en coma flotante, puede ser necesario dejar espacios a ambos lados.
Por ejemplo, <code>5.e3</code> es <code>5000.0</code> pero <code>5 . e3</code> es <code>5</code> por <code>e3</code>.
</p>
<p>Hay algunas variables globales que controlan la simplificación de expresiones que
contengan al operador <code>.</code>, a saber,
<code>dot</code>, <code>dot0nscsimp</code>, <code>dot0simp</code>, <code>dot1simp</code>, <code>dotassoc</code>, 
<code>dotconstrules</code>, <code>dotdistrib</code>, <code>dotexptsimp</code>, <code>dotident</code>,
y <code>dotscrules</code>.
</p>
<hr size="6">
<a name="Vectores"></a>
<a name="SEC130"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC129" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC131" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC127" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC133" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 23.1.2 Vectores </h3>
<p>El paquete <code>vect</code> define funciones para análisis vectorial. Para cargar el paquete en memoria se debe hacer
<code>load (&quot;vect&quot;)</code>  y con <code>demo (&quot;vect&quot;)</code> se presenta una demostración sobre las funciones del paquete.
</p>
<p>El paquete de análisis vectorial puede combinar y simplificar expresiones
simbólicas que incluyan productos escalares y vectoriales, junto con los operadores
de gradiente, divergencia, rotacional y laplaciano. La distribución de estos operadores
sobre sumas o productos se gobierna por ciertas variables, al igual que otras transformaciones,
incluida la expansión en componentes en cualquier sistema de coordenadas especificado. 
También hay funciones para obtener el potencial escalar o vectorial de un campo.
</p>
<p>El paquete <code>vect</code> contiene las siguientes funciones:
<code>vectorsimp</code>, <code>scalefactors</code>,
<code>express</code>, <code>potential</code> y <code>vectorpotential</code>.
</p>
<p>Por defecto, el paquete <code>vect</code> no declara el operador <code>.</code> como conmutativo.
Para transformarlo en conmutativo, se debe ejecutar previamente la instrucción
<code>declare(&quot;.&quot;, commutative)</code>.
</p>
<hr size="6">
<a name="Paquete-eigen"></a>
<a name="SEC131"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC130" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC132" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC127" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC128" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC133" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 23.1.3 Paquete eigen </h3>

<p>El paquete <code>eigen</code> contiene funciones para el cálculo 
simbólico de valores y vectores propios. Maxima carga el paquete
automáticamente si se hace una llamada a cualquiera de las dos funciones
<code>eigenvalues</code> o <code>eigenvectors</code>. El paquete se puede cargar de
forma explícita mediante <code>load (&quot;eigen&quot;)</code>.
</p>
<p>La instrucción <code>demo (&quot;eigen&quot;)</code> hace una demostración de las funciones de este paquete;
<code>batch (&quot;eigen&quot;)</code> realiza la misma demostración pero sin pausas entre los
sucesivos cálculos.
</p>
<p>Las funciones del paquete <code>eigen</code> son
<code>innerproduct</code>, <code>unitvector</code>, <code>columnvector</code>,
<code>gramschmidt</code>, <code>eigenvalues</code>, <code>eigenvectors</code>, <code>uniteigenvectors</code>
y <code>similaritytransform</code>.
</p>
<hr size="6">
<a name="Funciones-y-variables-para-las-matrices-y-el-_00e1lgebra-lineal"></a>
<a name="SEC132"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC131" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC133" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC127" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC127" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC133" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 23.2 Funciones y variables para las matrices y el álgebra lineal </h2>

<dl>
<dt><u>Función:</u> <b>addcol</b><i> (<var>M</var>, <var>lista_1</var>, ..., <var>lista_n</var>)</i>
<a name="IDX923"></a>
</dt>
<dd><p>Añade la/s columna/s dada/s por la/s lista/s (o matrices) a la matriz <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>addrow</b><i> (<var>M</var>, <var>lista_1</var>, ..., <var>lista_n</var>)</i>
<a name="IDX924"></a>
</dt>
<dd><p>Añade la/s fila/s dada/s por la/s lista/s (o matrices) a la matriz <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>adjoint</b><i> (<var>M</var>)</i>
<a name="IDX925"></a>
</dt>
<dd><p>Devuelve el adjunto de la matriz <var>M</var>.
La matriz adjunta es la transpuesta de la matriz de cofactores de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>augcoefmatrix</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX926"></a>
</dt>
<dd><p>Devuelve la matriz aumentada de coeficientes del sistema de ecuaciones lineales 
<var>eqn_1</var>, ..., <var>eqn_m</var> de variables <var>x_1</var>, ..., <var>x_n</var>. Se trata de la
matriz de coeficientes con una columna adicional para los términos constantes de cada
ecuación, es decir, aquellos términos que no dependen de las variables
<var>x_1</var>, ..., <var>x_n</var>.
</p>
<pre class="example">(%i1) m: [2*x - (a - 1)*y = 5*b, c + b*y + a*x = 0]$
(%i2) augcoefmatrix (m, [x, y]);
                       [ 2  1 - a  - 5 b ]
(%o2)                  [                 ]
                       [ a    b      c   ]
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>cauchy_matrix</b><i> ([<var>x_1</var>,<var>x_2</var>, ..., <var>x_m</var>], [<var>y_1</var>,<var>y_2</var>, ..., <var>y_n</var>])</i>
<a name="IDX927"></a>
</dt>
<dt><u>Función:</u> <b>cauchy_matrix</b><i> ([<var>x_1</var>,<var>x_2</var>, ..., <var>x_n</var>])</i>
<a name="IDX928"></a>
</dt>
<dd><p>Devuelve una matriz de Cauchy <var>n</var> by <var>m</var> de elementos
<var>a[i,j]</var> = 1/(<var>x_i</var>+<var>y_i</var>).
El segundo elemento de <code>cauchy_matrix</code> es opcional, y en caso
de no estar presente, los elementos serán de la forma
<var>a[i,j]</var> = 1/(<var>x_i</var>+<var>x_j</var>).
</p>
<p>Observación: en la literatura, la matriz de Cauchy se define a veces
con sus elementos de la forma <var>a[i,j]</var> = 1/(<var>x_i</var>-<var>y_i</var>).
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) cauchy_matrix([x1,x2],[y1,y2]);
                      [    1        1    ]
                      [ -------  ------- ]
                      [ y1 + x1  y2 + x1 ]
(%o1)                 [                  ]
                      [    1        1    ]
                      [ -------  ------- ]
                      [ y1 + x2  y2 + x2 ]

(%i2) cauchy_matrix([x1,x2]);
                      [   1         1    ]
                      [  ----    ------- ]
                      [  2 x1    x2 + x1 ]
(%o2)                 [                  ]
                      [    1       1     ]
                      [ -------   ----   ]
                      [ x2 + x1   2 x2   ]
</pre></dd></dl>



<dl>
<dt><u>Función:</u> <b>charpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX929"></a>
</dt>
<dd><p>Calcula el polinomio característico de la matriz <var>M</var>
respecto de la variable <var>x</var>. Esto es, 
<code>determinant (<var>M</var> - diagmatrix (length (<var>M</var>), <var>x</var>))</code>.
</p>
<pre class="example">(%i1) a: matrix ([3, 1], [2, 4]);
                            [ 3  1 ]
(%o1)                       [      ]
                            [ 2  4 ]
(%i2) expand (charpoly (a, lambda));
                           2
(%o2)                lambda  - 7 lambda + 10
(%i3) (programmode: true, solve (%));
(%o3)               [lambda = 5, lambda = 2]
(%i4) matrix ([x1], [x2]);
                             [ x1 ]
(%o4)                        [    ]
                             [ x2 ]
(%i5) ev (a . % - lambda*%, %th(2)[1]);
                          [ x2 - 2 x1 ]
(%o5)                     [           ]
                          [ 2 x1 - x2 ]
(%i6) %[1, 1] = 0;
(%o6)                     x2 - 2 x1 = 0
(%i7) x2^2 + x1^2 = 1;
                            2     2
(%o7)                     x2  + x1  = 1
(%i8) solve ([%th(2), %], [x1, x2]);
                  1               2
(%o8) [[x1 = - -------, x2 = - -------], 
               sqrt(5)         sqrt(5)

                                             1             2
                                    [x1 = -------, x2 = -------]]
                                          sqrt(5)       sqrt(5)
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>coefmatrix</b><i> ([<var>eqn_1</var>, ..., <var>eqn_m</var>], [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX930"></a>
</dt>
<dd><p>Devuelve la matriz de coeficientes para las variables <var>x_1</var>, ..., <var>x_n</var>
del sistema de ecuaciones lineales <var>eqn_1</var>, ..., <var>eqn_m</var>.
</p>
<pre class="example">(%i1) coefmatrix([2*x-(a-1)*y+5*b = 0, b*y+a*x = 3], [x,y]);
                                 [ 2  1 - a ]
(%o1)                            [          ]
                                 [ a    b   ]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>col</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX931"></a>
</dt>
<dd><p>Devuelve la <var>i</var>-ésima columna de la matriz <var>M</var>.
El resultado es una matriz de una sola columna.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>columnvector</b><i> (<var>L</var>)</i>
<a name="IDX932"></a>
</dt>
<dt><u>Función:</u> <b>covect</b><i> (<var>L</var>)</i>
<a name="IDX933"></a>
</dt>
<dd><p>Devuelve una matriz con una columna  y <code>length (<var>L</var>)</code> filas,
conteniendo los elementos de la lista <var>L</var>.
</p>
<p>La llamada <code>covect</code> es un sinónimo de <code>columnvector</code>.
</p>
<p>Es necesario cargar la función haciendo <code>load (&quot;eigen&quot;)</code>.
</p>

<p>Ejemplo:
</p>
<pre class="example">(%i1) load (&quot;eigen&quot;)$
Warning - you are redefining the Macsyma function eigenvalues
Warning - you are redefining the Macsyma function eigenvectors
(%i2) columnvector ([aa, bb, cc, dd]);
                             [ aa ]
                             [    ]
                             [ bb ]
(%o2)                        [    ]
                             [ cc ]
                             [    ]
                             [ dd ]
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>copymatrix</b><i> (<var>M</var>)</i>
<a name="IDX934"></a>
</dt>
<dd><p>Devuelve una copia de la matriz <var>M</var>. Esta es la única
manera de obtener una réplica de <var>M</var> además de la de
copiar elemento a elemento.
</p>
<p>Nótese que una asignación de una matriz a otra, como en <code>m2: m1</code>,
no hace una copia de <code>m1</code>. Asignaciones del tipo <code>m2 [i,j]: x</code> o
<code>setelmx (x, i, j, m2</code> también modifica <code>m1 [i,j]</code>. Si se crea una copia 
con <code>copymatrix</code> y luego se hacen asignaciones se tendrá una copia separada y
modificada.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>determinant</b><i> (<var>M</var>)</i>
<a name="IDX935"></a>
</dt>
<dd><p>Calcula el determinante de  <var>M</var> por un método similar al
de eliminación de Gauss
</p>
<p>La forma del resultado depende del valor asignado
a <code>ratmx</code>.
</p>
<p>Existe una rutina especial para calcular determinantes de matrices con elementos dispersas, la cual
será invocada cuando las variables <code>ratmx</code> y <code>sparse</code> valgan ambas
<code>true</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>detout</b>
<a name="IDX936"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>detout</code> vale <code>true</code>, el determinante de la matriz 
cuya inversa se calcula aparece como un factor fuera de la matriz.
</p>
<p>Para que esta variable surta efecto, <code>doallmxops</code> y <code>doscmxops</code> deberían tener
el valor <code>false</code> (véanse sus descripciones). Alternativamente, esta 
variable puede ser suministrada a <code>ev</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) m: matrix ([a, b], [c, d]);
                            [ a  b ]
(%o1)                       [      ]
                            [ c  d ]
(%i2) detout: true$
(%i3) doallmxops: false$
(%i4) doscmxops: false$
(%i5) invert (m);
                          [  d   - b ]
                          [          ]
                          [ - c   a  ]
(%o5)                     ------------
                           a d - b c
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>diagmatrix</b><i> (<var>n</var>, <var>x</var>)</i>
<a name="IDX937"></a>
</dt>
<dd><p>Devuelve una matriz diagonal de orden <var>n</var> 
con los elementos de la diagonal todos ellos iguales a <var>x</var>. La llamada
<code>diagmatrix (<var>n</var>, 1)</code> devuelve una matriz identidad
(igual que <code>ident (<var>n</var>)</code>).
</p>
<p>La variable <var>n</var> debe ser un número entero, en caso contrario <code>diagmatrix</code> envía un mensaje de error.
</p>
<p><var>x</var> puede ser cualquier tipo de expresión, incluso otra matriz.
Si <var>x</var> es una matriz, no se copia; todos los elementos de la diagonal son iguales a <var>x</var>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>doallmxops</b>
<a name="IDX938"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>doallmxops</code> vale <code>true</code>,
todas las operaciones relacionadas con matrices son
llevadas a cabo. Cuando es <code>false</code>, entonces las
selecciones para <code>dot</code> controlan las operaciones a ejecutar.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>domxexpt</b>
<a name="IDX939"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>domxexpt</code> vale <code>true</code>,
un exponente matricial, como <code>exp (<var>M</var>)</code> donde <var>M</var> es
una matriz, se interpreta como una matriz cuyo elemento <code>[i,j</code> es
igual a <code>exp (m[i,j])</code>. En otro caso, <code>exp (<var>M</var>)</code> se
evalúa como <code>exp (ev(<var>M</var>))</code>.
</p>
<p>La variable <code>domxexpt</code> afecta a todas las expresiones de la forma <code><var>base</var>^<var>exponente</var></code>
donde <var>base</var> es una expresión escalar o constante y <var>exponente</var> es una
lista o matriz.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) m: matrix ([1, %i], [a+b, %pi]);
                         [   1    %i  ]
(%o1)                    [            ]
                         [ b + a  %pi ]
(%i2) domxexpt: false$
(%i3) (1 - c)^m;
                             [   1    %i  ]
                             [            ]
                             [ b + a  %pi ]
(%o3)                 (1 - c)
(%i4) domxexpt: true$
(%i5) (1 - c)^m;
                  [                      %i  ]
                  [    1 - c      (1 - c)    ]
(%o5)             [                          ]
                  [        b + a         %pi ]
                  [ (1 - c)       (1 - c)    ]
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>domxmxops</b>
<a name="IDX940"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>domxmxops</code> vale <code>true</code>, se realizan todas las operaciones entre
matrices o entre matrices y listas (pero no las operaciones 
entre matrices y escalares); si esta variable es <code>false</code> tales
operaciones no se realizan.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>domxnctimes</b>
<a name="IDX941"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>domxnctimes</code> vale <code>true</code>, se calculan los productos
no conmutativos entre matrices.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dontfactor</b>
<a name="IDX942"></a>
</dt>
<dd><p>Valor por defecto: <code>[]</code>
</p>
<p>En <code>dontfactor</code> puede guardarse una lista de variables respecto de
las cuales no se realizarán factorizaciones. Inicialmente, la lista
está vacía.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>doscmxops</b>
<a name="IDX943"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>doscmxops</code> vale <code>true</code>, se realizan las operaciones entre escalares y 
matrices.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>doscmxplus</b>
<a name="IDX944"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>doscmxplus</code> vale <code>true</code>, las operaciones entre
escalares y matrices dan como resultado una matriz.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dot0nscsimp</b>
<a name="IDX945"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>(Esta descripción no está clara en la versión inglesa original.)
</p>
</dd></dl>




<dl>
<dt><u>Variable opcional:</u> <b>dotassoc</b>
<a name="IDX946"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>dotassoc</code> vale <code>true</code>, una expresión como <code>(A.B).C</code> se transforma en
<code>A.(B.C)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotconstrules</b>
<a name="IDX947"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>dotconstrules</code> vale <code>true</code>, un producto no conmutativo de una
constante con otro término se transforma en un producto conmutativo.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotdistrib</b>
<a name="IDX948"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>dotdistrib</code> vale <code>true</code>, una expresión como <code>A.(B + C)</code> se transforma en <code>A.B + A.C</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotexptsimp</b>
<a name="IDX949"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Cuando <code>dotexptsimp</code> vale <code>true</code>, una expresión como <code>A.A</code> se transforma en <code>A^^2</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotident</b>
<a name="IDX950"></a>
</dt>
<dd><p>Valor por defecto: 1
</p>
<p>El valor de la variable <code>dotident</code> es el resultado devuelto por <code>X^^0</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>dotscrules</b>
<a name="IDX951"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Cuando <code>dotscrules</code> vale <code>true</code>, una expresión como <code>A.SC</code> o <code>SC.A</code> se transforma 
en <code>SC*A</code> y <code>A.(SC*B)</code> en <code>SC*(A.B)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>echelon</b><i> (<var>M</var>)</i>
<a name="IDX952"></a>
</dt>
<dd><p>Devuelve la forma escalonada de la matriz <var>M</var>, obtenida por eliminación gaussiana.
La forma escalonada se calcula a partir de <var>M</var> mediante operaciones elementales con sus filas,
de tal manera que el primer elemento no nulo de cada fila en la matriz 
resultado es la unidad y que cada elemento de la columna por debajo del primer uno de cada
fila sean todos ceros.
</p>
<p>La función <code>triangularize</code> también lleva a cabo la eliminación gaussiana, pero no 
normaliza el primer elemento no nulo de cada fila.
</p>
<p>Otras funciones, como <code>lu_factor</code> y <code>cholesky</code>, también dan como resultados
matrices triangularizadas.
</p>
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) echelon (M);
                  [ 1  - 8  - 5      - 2     ]
                  [                          ]
                  [         28       11      ]
                  [ 0   1   --       --      ]
(%o2)             [         37       37      ]
                  [                          ]
                  [              37 bb - 119 ]
                  [ 0   0    1   ----------- ]
                  [              37 aa - 313 ]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>eigenvalues</b><i> (<var>M</var>)</i>
<a name="IDX953"></a>
</dt>
<dt><u>Función:</u> <b>eivals</b><i> (<var>M</var>)</i>
<a name="IDX954"></a>
</dt>
<dd><p>Devuelve una lista con dos sublistas. La primera sublista la forman los
valores propios de la matriz <var>M</var> y la segunda sus multiplicidades correspondientes.
</p>
<p>El nombre <code>eivals</code> es un sinónimo de <code>eigenvalues</code>.
</p>
<p>La función <code>eigenvalues</code> llama a la función <code>solve</code> para calcular las raíces
del polinomio característico de la matriz. En ocasiones, <code>solve</code> no
podrá encontrar dichas raíces, en cuyo caso otras funciones de este paquete
no trabajarán correctamente, a excepción de <code>innerproduct</code>,
<code>unitvector</code>, <code>columnvector</code> y <code>gramschmidt</code>.
</p>
<p>En algunos casos los valores propios encontrados por <code>solve</code> serán
expresiones complicadas, las cuales se podrán simplificar haciendo uso
de otras funciones.
</p>
<p>El paquete <code>eigen.mac</code> se carga en memoria de forma automática cuando
se invocan <code>eigenvalues</code> o <code>eigenvectors</code>. Si <code>eigen.mac</code> no
está ya cargado, <code>load (&quot;eigen&quot;)</code> lo carga. Tras la carga, todas las
funciones y variables del paquete estarán activas.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>eigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX955"></a>
</dt>
<dt><u>Función:</u> <b>eivects</b><i> (<var>M</var>)</i>
<a name="IDX956"></a>
</dt>
<dd><p>Calcula los vectores propios de la matriz <var>M</var>.
El resultado devuelto es una lista con dos elementos;
el primero está formado por dos listas, la primera con los valores propios
de <var>M</var> y la segunda con sus respectivas multiplicidades, el segundo
elemento es una lista de listas de vectores propios, una por
cada valor propio, pudiendo haber uno o más vectores propios en cada lista.
</p>
<p>Tomando la matriz <var>M</var> como argumento, devuelve una lista de listas,
la primera de las cuales es la salida de <code>eigenvalues</code> y las 
siguientes son los vectorios propios de la matriz asociados a los
valores propios correspondientes. Los vectores propios calculados son los 
vectores propios por la derecha.
</p>
<p>El nombre <code>eivects</code> es un sinónimo de <code>eigenvectors</code>.
</p>
<p>El paquete <code>eigen.mac</code> se carga en memoria de forma automática cuando
se invocan <code>eigenvalues</code> o <code>eigenvectors</code>. Si <code>eigen.mac</code> no
está ya cargado, <code>load (&quot;eigen&quot;)</code> lo carga. Tras la carga, todas las
funciones y variables del paquete estarán activas.
</p>
<p>Las variables que afectan a esta función son: 
</p>
<p><code>nondiagonalizable</code> toma el valor <code>true</code> o <code>false</code> dependiendo
de si la matriz no es diagonalizable o diagonalizable tras la ejecución de
<code>eigenvectors</code>.
</p>
<p><code>hermitianmatrix</code>, si vale <code>true</code>, entonces los vectores propios 
degenerados de la matriz hermítica son ortogonalizados mediante el
algoritmo de Gram-Schmidt.
</p>
<p><code>knowneigvals</code>, si vale <code>true</code>, entonces el paquete <code>eigen</code> da por
sentado que los valores propios de la matriz son conocidos por el usuario y 
almacenados en la variable global <code>listeigvals</code>.  <code>listeigvals</code> debería
ser similar a la salida de <code>eigenvalues</code>.
</p>
<p>La función <code>algsys</code> se utiliza aquí para calcular los vectores propios. A
veces, <code>algsys</code> no podrá calcular una solución. En algunos casos, será posible
simplificar los valores propios calculándolos en primer lugar con <code>eigenvalues</code> y
luego utilizando otras funciones para simplificarlos. Tras la simplificación, 
<code>eigenvectors</code> podrá ser llamada otra vez con la variable <code>knowneigvals</code>
ajustada al valor <code>true</code>.
</p>
<p>Véase también <code>eigenvalues</code>.
</p>
<p>Ejemplos:
</p>
<p>Una matriz con un único vector propio por cada valor propio.
</p>
<pre class="example">(%i1) M1 : matrix ([11, -1], [1, 7]);
                           [ 11  - 1 ]
(%o1)                      [         ]
                           [ 1    7  ]
(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[9 - sqrt(3), sqrt(3) + 9], [1, 1]], 
                        [[[1, sqrt(3) + 2]], [[1, 2 - sqrt(3)]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                       val  = 9 - sqrt(3)
                          1

                            mult  = 1
                                1

                    vec  = [[1, sqrt(3) + 2]]
                       1

                       val  = sqrt(3) + 9
                          2

                            mult  = 1
                                2

                    vec  = [[1, 2 - sqrt(3)]]
                       2

(%o3)                         done
</pre>
<p>Una matriz con dos vectores propios para uno de los valores propios.
</p>
<pre class="example">(%i1) M1 : matrix ([0, 1, 0, 0], [0, 0, 0, 0], [0, 0, 2, 0], [0, 0, 0, 2]);
                         [ 0  1  0  0 ]
                         [            ]
                         [ 0  0  0  0 ]
(%o1)                    [            ]
                         [ 0  0  2  0 ]
                         [            ]
                         [ 0  0  0  2 ]
(%i2) [vals, vecs] : eigenvectors (M1);
(%o2) [[[0, 2], [2, 2]], [[[1, 0, 0, 0]],
                                   [[0, 0, 1, 0], [0, 0, 0, 1]]]]
(%i3) for i thru length (vals[1]) do disp (val[i] = vals[1][i],
  mult[i] = vals[2][i], vec[i] = vecs[i]);
                            val  = 0
                               1

                            mult  = 2
                                1

                      vec  = [[1, 0, 0, 0]]
                         1

                            val  = 2
                               2

                            mult  = 2
                                2

               vec  = [[0, 0, 1, 0], [0, 0, 0, 1]]
                  2

(%o3)                         done
</pre>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>ematrix</b><i> (<var>m</var>, <var>n</var>, <var>x</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX957"></a>
</dt>
<dd><p>Devuelve una matriz de orden <var>m</var> por <var>n</var>, con todos sus elementos 
nulos, excepto el que ocupa la posición <code>[<var>i</var>, <var>j</var>]</code>, que
es igual a <var>x</var>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>entermatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX958"></a>
</dt>
<dd><p>Devuelve una matriz de orden <var>m</var> por <var>n</var>, cuyos elementos
son leidos de forma interactiva.
</p>
<p>Si <var>n</var> es igual a <var>m</var>, Maxima pregunta por el tipo de
matriz (diagonal, simétrica, antisimétrica o general) y luego por
cada elemento. Cada respuesta introducida por el usuario debe terminar
con un punto y coma <code>;</code> o con un signo de dólar <code>$</code>.
</p>
<p>Si <var>n</var> y <var>m</var> no son iguales, Maxima pregunta
por el valor de cada elemento.
</p>
<p>Los elementos de la matriz pueden ser cualquier tipo de 
expresión, que en todo caso será evaluada.
<code>entermatrix</code> evalúa sus argumentos.
</p>
<pre class="example">(%i1) n: 3$
(%i2) m: entermatrix (n, n)$

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  
   4. General
Answer 1, 2, 3 or 4 : 
1$
Row 1 Column 1: 
(a+b)^n$
Row 2 Column 2: 
(a+b)^(n+1)$
Row 3 Column 3: 
(a+b)^(n+2)$

Matrix entered.
(%i3) m;
                [        3                     ]
                [ (b + a)      0         0     ]
                [                              ]
(%o3)           [                  4           ]
                [    0      (b + a)      0     ]
                [                              ]
                [                            5 ]
                [    0         0      (b + a)  ]
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>, <var>j_1</var>)</i>
<a name="IDX959"></a>
</dt>
<dt><u>Función:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>, <var>i_1</var>)</i>
<a name="IDX960"></a>
</dt>
<dt><u>Función:</u> <b>genmatrix</b><i> (<var>a</var>, <var>i_2</var>, <var>j_2</var>)</i>
<a name="IDX961"></a>
</dt>
<dd><p>Devuelve una matriz generada a partir de <var>a</var>, siendo <code><var>a</var>[<var>i_1</var>,<var>j_1</var>]</code> el elemento superior izquierdo y <code><var>a</var>[<var>i_2</var>,<var>j_2</var>]</code> el inferior derecho de la matriz. 
Aquí <var>a</var> se declara como una arreglo (creado por <code>array</code>,
pero no por <code>make_array</code>), o un array no declarado, o una función array, o una
expresión lambda de dos argumentos.
(An array function is created like other functions with <code>:=</code> or <code>define</code>,
but arguments are enclosed in square brackets instead of parentheses.)
</p>
<p>Si se omite <var>j_1</var>, entonces se le asigna el valor <var>i_1</var>. Si tanto <var>j_1</var> como <var>i_1</var> se omiten, a las dos variables se le asigna el valor 1.
</p>
<p>Si un elemento <code>i,j</code> del arreglo no está definido, se le asignará el elemento simbólico <code><var>a</var>[i,j]</code>.
</p>
<pre class="example">(%i1) h [i, j] := 1 / (i + j - 1);
                                    1
(%o1)                  h     := ---------
                        i, j    i + j - 1
(%i2) genmatrix (h, 3, 3);
                           [    1  1 ]
                           [ 1  -  - ]
                           [    2  3 ]
                           [         ]
                           [ 1  1  1 ]
(%o2)                      [ -  -  - ]
                           [ 2  3  4 ]
                           [         ]
                           [ 1  1  1 ]
                           [ -  -  - ]
                           [ 3  4  5 ]
(%i3) array (a, fixnum, 2, 2);
(%o3)                           a
(%i4) a [1, 1] : %e;
(%o4)                          %e
(%i5) a [2, 2] : %pi;
(%o5)                          %pi
(%i6) genmatrix (a, 2, 2);
                           [ %e   0  ]
(%o6)                      [         ]
                           [ 0   %pi ]
(%i7) genmatrix (lambda ([i, j], j - i), 3, 3);
                         [  0    1   2 ]
                         [             ]
(%o7)                    [ - 1   0   1 ]
                         [             ]
                         [ - 2  - 1  0 ]
(%i8) genmatrix (B, 2, 2);
                        [ B      B     ]
                        [  1, 1   1, 2 ]
(%o8)                   [              ]
                        [ B      B     ]
                        [  2, 1   2, 2 ]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>gramschmidt</b><i> (<var>x</var>)</i>
<a name="IDX962"></a>
</dt>
<dt><u>Función:</u> <b>gramschmidt</b><i> (<var>x</var>, <var>F</var>)</i>
<a name="IDX963"></a>
</dt>
<dd><p>Ejecuta el algoritmo de ortogonalización de Gram-Schmidt sobre <var>x</var>,
que puede ser una matriz o una lista de listas. La función 
<code>gramschmidt</code> no altera el valor de <var>x</var>.
El producto interno por defecto empleado en <code>gramschmidt</code> es
<code>innerproduct</code>, o <var>F</var>, si se ha hecho uso de esta opción.
</p>
<p>Si <var>x</var> es una matriz, el algoritmo se aplica a las filas de <var>x</var>. Si
<var>x</var> es una lista de listas, el algoritmo se aplica a las sublistas,
las cuales deben tener el mismo número de miembros. En cualquier caso,
el valor devuelto es una lista de listas, cuyas sublistas son ortogonales.
</p>
<p>La función <code>factor</code> es invocada  en cada paso del algoritmo para 
simplificar resultados intermedios. Como consecuencia, el valor retornado 
puede contener enteros factorizados.
</p>
<p>El nombre <code>gschmit</code> es sinónimo de <code>gramschmidt</code>.
</p>
<p>Es necesario cargar la función haciendo <code>load (&quot;eigen&quot;)</code>.
</p>
<p>Ejemplo:
</p>
<p>Algoritmo de Gram-Schmidt utilizando el producto interno por defecto.
</p>
<pre class="example">(%i1) load (eigen)$
(%i2) x: matrix ([1, 2, 3], [9, 18, 30], [12, 48, 60]);
                         [ 1   2   3  ]
                         [            ]
(%o2)                    [ 9   18  30 ]
                         [            ]
                         [ 12  48  60 ]
(%i3) y: gramschmidt (x);
                       2      2            4     3
                      3      3   3 5      2  3  2  3
(%o3)  [[1, 2, 3], [- ---, - --, ---], [- ----, ----, 0]]
                      2 7    7   2 7       5     5
(%i4) map (innerproduct, [y[1], y[2], y[3]], [y[2], y[3], y[1]]);
(%o4)                       [0, 0, 0]
</pre>
<p>Algoritmo de Gram-Schmidt utilizando un producto interno especificado
por el usuario.
</p>
<pre class="example">(%i1) load (eigen)$
(%i2) ip (f, g) := integrate (f * g, u, a, b);
(%o2)          ip(f, g) := integrate(f g, u, a, b)
(%i3) y : gramschmidt ([1, sin(u), cos(u)], ip), a= -%pi/2, b=%pi/2;
                               %pi cos(u) - 2
(%o3)              [1, sin(u), --------------]
                                    %pi
(%i4) map (ip, [y[1], y[2], y[3]], [y[2], y[3], y[1]]), a= -%pi/2, b=%pi/2;
(%o4)                       [0, 0, 0]
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>ident</b><i> (<var>n</var>)</i>
<a name="IDX964"></a>
</dt>
<dd><p>Devuelve la matriz identidad de orden <var>n</var>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>innerproduct</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX965"></a>
</dt>
<dt><u>Función:</u> <b>inprod</b><i> (<var>x</var>, <var>y</var>)</i>
<a name="IDX966"></a>
</dt>
<dd><p>Devuelve el producto interior o escalar de <var>x</var> por <var>y</var>, que deben ser listas de igual longitud, o ambas matrices columa o fila de igual longitud. El valor devuelto es <code>conjugate (x) . y</code>, donde <code>.</code> es el operador de multiplicación no conmutativa.
</p>
<p>Es necesario cargar la función haciendo <code>load (&quot;eigen&quot;)</code>.
</p>
<p>El nombre <code>inprod</code> es sinónimo de <code>innerproduct</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>invert</b><i> (<var>M</var>)</i>
<a name="IDX967"></a>
</dt>
<dd><p>Devuelve la inversa de la matriz <var>M</var>, calculada por el método del adjunto.
</p>
<p>La implementación actual no es eficiente para matrices de orden grande.
</p>
<p>Cuando <code>detout</code> vale <code>true</code>, el determinante se deja
 fuera de la inversa a modo de factor escalar.
</p>
<p>Los elementos de la matriz inversa no se expanden. Si <var>M</var> tiene elementos
polinómicos, se puede mejorar el aspecto del resultado haciendo 
<code>expand (invert (m)), detout</code>.
</p>
<p>Véase la descripción de <code>^^</code> (exponente no conmutativo) para 
información sobre otro método para invertir matrices.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>list_matrix_entries</b><i> (<var>M</var>)</i>
<a name="IDX968"></a>
</dt>
<dd><p>Devuelve una lista con todos los elementos de la matriz <var>M</var>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) list_matrix_entries(matrix([a,b],[c,d]));
(%o1)                     [a, b, c, d]
</pre>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>lmxchar</b>
<a name="IDX969"></a>
</dt>
<dd><p>Valor por defecto: <code>[</code>
</p>
<p>La variable <code>lmxchar</code> guarda el carácter a mostrar como delimitador izquierdo de la matriz.
Véase también <code>rmxchar</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) lmxchar: &quot;|&quot;$
(%i2) matrix ([a, b, c], [d, e, f], [g, h, i]);
                           | a  b  c ]
                           |         ]
(%o2)                      | d  e  f ]
                           |         ]
                           | g  h  i ]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>matrix</b><i> (<var>fila_1</var>, ..., <var>fila_n</var>)</i>
<a name="IDX970"></a>
</dt>
<dd><p>Devuelve una matriz rectangular con las filas  <var>fila_1</var>, ..., <var>fila_n</var>. Cada fila es una lista de expresiones. Todas las filas deben tener el mismo número de miembros.
</p>
<p>Las operaciones <code>+</code> (suma), <code>-</code> (resta), <code>*</code> (multiplicación) y <code>/</code> (división), se llevan a cabo elemento a elemento cuando los operandos son dos matrices, un escalar y una matriz o una matriz con un escalar. La operación <code>^</code> (exponenciación, equivalente a <code>**</code>) se lleva cabo también elemento a elemento si los operandos son un escalr y una matriz o uma matriz y un escalar, pero no si los operandos son dos matrices.
</p>
<p>El producto matricial se representa con el operador de multiplicación no conmutativa <code>.</code>. El correspondiente operador de exponenciación no conmutativa es <code>^^</code>. Dada la matriz <code><var>A</var></code>, <code><var>A</var>.<var>A</var> = <var>A</var>^^2</code> y <code><var>A</var>^^-1</code> es la inversa de <var>A</var>, si existe.
</p>
<p>Algunas variables controlan la simplificación de expresiones que incluyan estas operaciones: <code>doallmxops</code>, <code>domxexpt</code>, <code>domxmxops</code>, <code>doscmxops</code> y <code>doscmxplus</code>.
</p>
<p>Hay otras opciones adicionales relacionadas con matrices:
<code>lmxchar</code>, <code>rmxchar</code>, <code>ratmx</code>, <code>listarith</code>, <code>detout</code>,
<code>scalarmatrix</code> y <code>sparse</code>.
</p>
<p>Hay también algunas funciones que admiten matrices como argumentos o que devuelven resultados matriciales: <code>eigenvalues</code>, <code>eigenvectors</code>,
<code>determinant</code>,
<code>charpoly</code>, <code>genmatrix</code>, <code>addcol</code>, <code>addrow</code>, 
<code>copymatrix</code>, <code>transpose</code>, <code>echelon</code> y <code>rank</code>.
</p>
<p>Ejemplos:
</p>
<ul>
<li>
Construcción de matrices a partir de listas.
</li></ul>
<pre class="example">(%i1) x: matrix ([17, 3], [-8, 11]);
                           [ 17   3  ]
(%o1)                      [         ]
                           [ - 8  11 ]
(%i2) y: matrix ([%pi, %e], [a, b]);
                           [ %pi  %e ]
(%o2)                      [         ]
                           [  a   b  ]
</pre><ul>
<li>
Suma elemento a elemento.
</li></ul>
<pre class="example">(%i3) x + y;
                      [ %pi + 17  %e + 3 ]
(%o3)                 [                  ]
                      [  a - 8    b + 11 ]
</pre><ul>
<li>
Resta elemento a elemento.
</li></ul>
<pre class="example">(%i4) x - y;
                      [ 17 - %pi  3 - %e ]
(%o4)                 [                  ]
                      [ - a - 8   11 - b ]
</pre><ul>
<li>
Multiplicación elemento a elemento.
</li></ul>
<pre class="example">(%i5) x * y;
                        [ 17 %pi  3 %e ]
(%o5)                   [              ]
                        [ - 8 a   11 b ]
</pre><ul>
<li>
División elemento a elemento.
</li></ul>
<pre class="example">(%i6) x / y;
                        [ 17       - 1 ]
                        [ ---  3 %e    ]
                        [ %pi          ]
(%o6)                   [              ]
                        [   8    11    ]
                        [ - -    --    ]
                        [   a    b     ]
</pre><ul>
<li>
Matriz elevada a un exponente escalar, operación elemento a elemento.
</li></ul>
<pre class="example">(%i7) x ^ 3;
                         [ 4913    27  ]
(%o7)                    [             ]
                         [ - 512  1331 ]
</pre><ul>
<li>
Base escalar y exponente matricial, operación elemento a elemento.
</li></ul>
<pre class="example">(%i8) exp(y); 
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o8)                    [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre><ul>
<li>
Base y exponente matriciales. Esta operación no se realiza elemento a elemento.
</li></ul>
<pre class="example">(%i9) x ^ y;
                                [ %pi  %e ]
                                [         ]
                                [  a   b  ]
                     [ 17   3  ]
(%o9)                [         ]
                     [ - 8  11 ]
</pre><ul>
<li>
Multiplicación matricial no conmutativa.
</li></ul>
<pre class="example">(%i10) x . y;
                  [ 3 a + 17 %pi  3 b + 17 %e ]
(%o10)            [                           ]
                  [ 11 a - 8 %pi  11 b - 8 %e ]
(%i11) y . x;
                [ 17 %pi - 8 %e  3 %pi + 11 %e ]
(%o11)          [                              ]
                [  17 a - 8 b     11 b + 3 a   ]
</pre><ul>
<li>
Exponenciación matricial no conmutativa. Una base escalar <var>b</var> elevada a un exponente matricial <var>M</var> se lleva a cabo elemento a elemento y por lo tanto <code>b^^m</code> equivale a <code>b^m</code>.
</li></ul>
<pre class="example">(%i12) x ^^ 3;
                        [  3833   1719 ]
(%o12)                  [              ]
                        [ - 4584  395  ]
(%i13) %e ^^ y;
                         [   %pi    %e ]
                         [ %e     %e   ]
(%o13)                   [             ]
                         [    a     b  ]
                         [  %e    %e   ]
</pre><ul>
<li>
Una matriz elevada al exponente -1 con el operador de exponenciación no conmutativa equivale a la matriz inversa, si existe.
</li></ul>
<pre class="example">(%i14) x ^^ -1;
                         [ 11      3  ]
                         [ ---  - --- ]
                         [ 211    211 ]
(%o14)                   [            ]
                         [  8    17   ]
                         [ ---   ---  ]
                         [ 211   211  ]
(%i15) x . (x ^^ -1);
                            [ 1  0 ]
(%o15)                      [      ]
                            [ 0  1 ]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>matrixmap</b><i> (<var>f</var>, <var>M</var>)</i>
<a name="IDX971"></a>
</dt>
<dd><p>Devuelve una matriz con el elemento <code>i,j</code> igual a <code><var>f</var>(<var>M</var>[i,j])</code>.
</p>
<p>Véanse también <code>map</code>, <code>fullmap</code>, <code>fullmapl</code> y <code>apply</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>matrixp</b><i> (<var>expr</var>)</i>
<a name="IDX972"></a>
</dt>
<dd><p>Devuelve <code>true</code> si <var>expr</var> es una matriz, en caso contrario <code>false</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>matrix_element_add</b>
<a name="IDX973"></a>
</dt>
<dd><p>Valor por defecto: <code>+</code>
</p>
<p>La variable <code>matrix_element_add</code> guarda el símbolo del operador a ejecutar en lugar de la suma en el producto matricial; a <code>matrix_element_add</code> se le puede asignar cualquier operador n-ario (esto es, una función que admite cualquier número de argumentos). El valor asignado puede ser el nombre de un operador encerrado entre apóstrofos, el nombre de una función o una expresión lambda.
</p>
<p>Véanse también <code>matrix_element_mult</code> y <code>matrix_element_transpose</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) matrix_element_add: &quot;*&quot;$
(%i2) matrix_element_mult: &quot;^&quot;$
(%i3) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o3)                      [         ]
                           [ d  e  f ]
(%i4) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o4)                      [         ]
                           [ x  y  z ]
(%i5) aa . transpose (bb);
                     [  u  v  w   x  y  z ]
                     [ a  b  c   a  b  c  ]
(%o5)                [                    ]
                     [  u  v  w   x  y  z ]
                     [ d  e  f   d  e  f  ]
</pre>
</dd></dl>


<dl>
<dt><u>Variable opcional:</u> <b>matrix_element_mult</b>
<a name="IDX974"></a>
</dt>
<dd><p>Valor por defecto: <code>*</code>
</p>
<p>La variable <code>matrix_element_mult</code> guarda el símbolo del operador a ejecutar en lugar de la multiplicación en el producto matricial; a <code>matrix_element_mult</code> se le puede asignar cualquier operador binario. El valor asignado puede ser el nombre de un operador encerrado entre apóstrofos, el nombre de una función o una expresión lambda.
</p>
<p>El operador <code>.</code> puede ser una opción útil en determinados contextos.
</p>
<p>Véanse también <code>matrix_element_add</code> y <code>matrix_element_transpose</code>.
</p>
<p>Ejemplo:
</p>
<pre class="example">(%i1) matrix_element_add: lambda ([[x]], sqrt (apply (&quot;+&quot;, x)))$
(%i2) matrix_element_mult: lambda ([x, y], (x - y)^2)$
(%i3) [a, b, c] . [x, y, z];
                          2          2          2
(%o3)         sqrt((c - z)  + (b - y)  + (a - x) )
(%i4) aa: matrix ([a, b, c], [d, e, f]);
                           [ a  b  c ]
(%o4)                      [         ]
                           [ d  e  f ]
(%i5) bb: matrix ([u, v, w], [x, y, z]);
                           [ u  v  w ]
(%o5)                      [         ]
                           [ x  y  z ]
(%i6) aa . transpose (bb);
               [             2          2          2  ]
               [ sqrt((c - w)  + (b - v)  + (a - u) ) ]
(%o6)  Col 1 = [                                      ]
               [             2          2          2  ]
               [ sqrt((f - w)  + (e - v)  + (d - u) ) ]

                         [             2          2          2  ]
                         [ sqrt((c - z)  + (b - y)  + (a - x) ) ]
                 Col 2 = [                                      ]
                         [             2          2          2  ]
                         [ sqrt((f - z)  + (e - y)  + (d - x) ) ]
</pre>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>matrix_element_transpose</b>
<a name="IDX975"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>La variable <code>matrix_element_transpose</code> es una operación que se aplica a cada elemento de una matriz a la que se le calcula la transpuesta. A <code>matrix_element_mult</code> se le puede asignar cualquier operador unitario. El valor asignado puede ser el nombre de un operador encerrador entre apóstrofos, el nombre de una función o una expresión lambda.
</p>
<p>Cuando <code>matrix_element_transpose</code> es igual a <code>transpose</code>, la función <code>transpose</code> se aplica a cada elemento. Cuando  <code>matrix_element_transpose</code> es igual  a <code>nonscalars</code>, la función <code>transpose</code> se aplica a todos los elementos no escalares. Si alguno de los elementos es un átomo, la opción <code>nonscalars</code> se aplica 
<code>transpose</code> sólo si el átomo se declara no escalar, mientras que la opción <code>transpose</code> siempre aplica  <code>transpose</code>.
</p>
<p>La opción por defecto, <code>false</code>, significa que no se aplica ninguna operación.
</p>
<p>Véanse también <code>matrix_element_add</code> y <code>matrix_element_mult</code>.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) declare (a, nonscalar)$
(%i2) transpose ([a, b]);
                        [ transpose(a) ]
(%o2)                   [              ]
                        [      b       ]
(%i3) matrix_element_transpose: nonscalars$
(%i4) transpose ([a, b]);
                        [ transpose(a) ]
(%o4)                   [              ]
                        [      b       ]
(%i5) matrix_element_transpose: transpose$
(%i6) transpose ([a, b]);
                        [ transpose(a) ]
(%o6)                   [              ]
                        [ transpose(b) ]
(%i7) matrix_element_transpose: 
           lambda ([x], realpart(x) - %i*imagpart(x))$
(%i8) m: matrix ([1 + 5*%i, 3 - 2*%i], [7*%i, 11]);
                     [ 5 %i + 1  3 - 2 %i ]
(%o8)                [                    ]
                     [   7 %i       11    ]
(%i9) transpose (m);
                      [ 1 - 5 %i  - 7 %i ]
(%o9)                 [                  ]
                      [ 2 %i + 3    11   ]
</pre>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>mattrace</b><i> (<var>M</var>)</i>
<a name="IDX976"></a>
</dt>
<dd><p>Devuelve la traza (esto es, la suma de los elementos de la diagonal principal) de la matriz cuadrada <var>M</var>.  
</p>
<p>Para disponer de esta función es necesario cargar el paquete haciendo <code>load (&quot;nchrpl&quot;)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>minor</b><i> (<var>M</var>, <var>i</var>, <var>j</var>)</i>
<a name="IDX977"></a>
</dt>
<dd><p>Devuelve el menor <code>(<var>i</var>, <var>j</var>)</code> de la matriz <var>M</var>.  Esto es, la propia matriz <var>M</var>, una vez extraídas la fila <var>i</var> y la columna <var>j</var>.
</p>
</dd></dl>



<dl>
<dt><u>Función:</u> <b>ncharpoly</b><i> (<var>M</var>, <var>x</var>)</i>
<a name="IDX978"></a>
</dt>
<dd><p>Devuelve el polinomio característico de la matriz <var>M</var> respecto de la variable <var>x</var>. Es una alternativa a la función <code>charpoly</code> de Maxima.
</p>
<p>La función <code>ncharpoly</code> opera calculando trazas de las potencias de la matriz dada, que son iguales a las sumas de las potencias de las raíces del polinomio característico. A partir de estas cantidades se pueden calcular las funciones simétricas de las raíces, que no son otra cosa sino los coeficientes del polinomio característico. La función   <code>charpoly</code> opera calculando el determinante de  by <code><var>x</var> * ident [n] - a</code>. La función <code>ncharpoly</code> es m'as eficiente en el caso de matrices grandes y densas.
</p>
<p>Para disponer de esta función es necesario cargar el paquete haciendo <code>load (&quot;nchrpl&quot;)</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>newdet</b><i> (<var>M</var>)</i>
<a name="IDX979"></a>
</dt>
<dd><p>Calcula el determinante de la matriz <var>M</var> por el algoritmo del árbol menor
de Johnson-Gentleman. El resultado devuelto por <code>newdet</code> tiene formato CRE.
</p></dd></dl>



<dl>
<dt><u>Función:</u> <b>permanent</b><i> (<var>M</var>)</i>
<a name="IDX980"></a>
</dt>
<dd><p>Calcula la permanente de la matriz <var>M</var> por el algoritmo del árbol menor de
Johnson-Gentleman. La permanente es como un determinante pero sin cambios de signo.
El resultado devuelto por <code>permanent</code> tiene formato CRE.
</p>
<p>Véase también <code>newdet</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>rank</b><i> (<var>M</var>)</i>
<a name="IDX981"></a>
</dt>
<dd><p>Calcula el rango de la matriz <var>M</var>.  Esto es, el orden del mayor subdeterminante no singular de <var>M</var>.
</p>
<p>La función <var>rango</var> puede retornar una respuesta errónea si no detecta que un elemento de la matriz equivalente a cero lo es.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>ratmx</b>
<a name="IDX982"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>ratmx</code> vale <code>false</code>, el determinante y la suma, resta y producto matriciales se calculan cuando las matrices se expresan en términos de sus elementos, pero no se calcula la inversión matricial en su representación general.
</p>
<p>Si <code>ratmx</code> vale <code>true</code>, las cuatro operaciones citadas más arriba se calculan en el formato CRE y el resultado de la matriz inversa también se da en formato CRE. Esto puede hacer que se expandan los elementos de la matriz, dependiendo del valor de <code>ratfac</code>, lo que quizás no sea siempre deseable.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>row</b><i> (<var>M</var>, <var>i</var>)</i>
<a name="IDX983"></a>
</dt>
<dd><p>Devuelve la <var>i</var>-ésima fila de la matriz <var>M</var>. El valor que devuelve tiene formato de matriz.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>rmxchar</b>
<a name="IDX984"></a>
</dt>
<dd><p>Valor por defecto: <code>]</code>
</p>
<p>La variable <code>rmxchar</code> es el carácter que se dibuja al lado derecho de una matriz.
</p>
<p>Véase también <code>lmxchar</code>.
</p>
</dd></dl>



<dl>
<dt><u>Variable opcional:</u> <b>scalarmatrixp</b>
<a name="IDX985"></a>
</dt>
<dd><p>Valor por defecto: <code>true</code>
</p>
<p>Si <code>scalarmatrixp</code> vale <code>true</code>, entonces siempre que una matriz 1 x 1 se produce como resultado del cálculo del producto no conmutativo de matrices se cambia al formato escalar.
</p>
<p>Si <code>scalarmatrixp</code> vale <code>all</code>, entonces todas las matrices 1 x 1 se simplifican a escalares.
</p>
<p>Si <code>scalarmatrixp</code> vale <code>false</code>, las matrices 1 x 1 no se convierten en escalares.
</p>
</dd></dl>


<dl>
<dt><u>Función:</u> <b>setelmx</b><i> (<var>x</var>, <var>i</var>, <var>j</var>, <var>M</var>)</i>
<a name="IDX986"></a>
</dt>
<dd><p>Asigna el valor <var>x</var> al (<var>i</var>, <var>j</var>)-ésimo elemento de la matriz <var>M</var> y devuelve la matriz actualizada.
</p>
<p>La llamada <code><var>M</var> [<var>i</var>, <var>j</var>]: <var>x</var></code> hace lo mismo, pero devuelve  <var>x</var> en lugar de <var>M</var>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>similaritytransform</b><i> (<var>M</var>)</i>
<a name="IDX987"></a>
</dt>
<dt><u>Función:</u> <b>simtran</b><i> (<var>M</var>)</i>
<a name="IDX988"></a>
</dt>
<dd><p>La función <code>similaritytransform</code> calcula la transformada de similitud de la matriz <code>M</code>. Devuelve una lista que es la salida de la instrucción <code>uniteigenvectors</code>. Además, si la variable <code>nondiagonalizable</code> vale <code>false</code> entonces se calculan dos matrices globales <code>leftmatrix</code> y <code>rightmatrix</code>. Estas matrices tienen la propiedad de que <code>leftmatrix . <var>M</var> . rightmatrix</code> es una matriz diagonal con los valores propios de <var>M</var> en su diagonal.  Si <code>nondiagonalizable</code> vale <code>true</code> entonces no se calculan estas matrices.
</p>
<p>Si la variable <code>hermitianmatrix</code> vale <code>true</code> entonces <code>leftmatrix</code> es el conjugado complejo de la transpuesta de <code>rightmatrix</code>.  En otro caso <code>leftmatrix</code> es la inversa de <code>rightmatrix</code>.
</p>
<p>Las columnas de la matriz <code>rightmatrix</code> son los vectores propios de <var>M</var>.  Las otras variables (véanse <code>eigenvalues</code> y <code>eigenvectors</code>) tienen el mismo efecto, puesto que <code>similaritytransform</code> llama a las otras funciones del paquete para poder formar <code>rightmatrix</code>.
</p>
<p>Estas funciones se cargan con <code>load (&quot;eigen&quot;)</code>.
</p>
<p>El nombre <code>simtran</code> es sinónimo de <code>similaritytransform</code>.
</p>
</dd></dl>

<dl>
<dt><u>Variable opcional:</u> <b>sparse</b>
<a name="IDX989"></a>
</dt>
<dd><p>Valor por defecto: <code>false</code>
</p>
<p>Si <code>sparse</code> vale <code>true</code> y si <code>ratmx</code> vale <code>true</code>, entonces <code>determinant</code>
utilizará rutinas especiales para calcular determinantes dispersos.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>submatrix</b><i> (<var>i_1</var>, ..., <var>i_m</var>, <var>M</var>, <var>j_1</var>, ..., <var>j_n</var>)</i>
<a name="IDX990"></a>
</dt>
<dt><u>Función:</u> <b>submatrix</b><i> (<var>i_1</var>, ..., <var>i_m</var>, <var>M</var>)</i>
<a name="IDX991"></a>
</dt>
<dt><u>Función:</u> <b>submatrix</b><i> (<var>M</var>, <var>j_1</var>, ..., <var>j_n</var>)</i>
<a name="IDX992"></a>
</dt>
<dd><p>Devuelve una nueva matriz formada a partir de la matriz <var>M</var> pero cuyas filas <var>i_1</var>, ..., <var>i_m</var> y columnas  <var>j_1</var>, ..., <var>j_n</var> han sido eliminadas.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>transpose</b><i> (<var>M</var>)</i>
<a name="IDX993"></a>
</dt>
<dd><p>Calcula la transpuesta de <var>M</var>.
</p>
<p>Si <var>M</var> es una matriz, el valor devuelto es otra matriz <var>N</var> tal que <code>N[i,j] = M[j,i]</code>.
</p>
<p>Si <var>M</var> es una lista, el valor devuelto es una matriz <var>N</var> de <code>length (m)</code> filas y 1 columna, tal que <code>N[i,1] = M[i]</code>.
</p>
<p>En caso de no ser <var>M</var> ni matriz ni lista, se devuelve la
expresión nominal <code>'transpose (<var>M</var>)</code>.
</p></dd></dl>

<dl>
<dt><u>Función:</u> <b>triangularize</b><i> (<var>M</var>)</i>
<a name="IDX994"></a>
</dt>
<dd><p>Devuelve la forma triangular superior de la matriz <code>M</code>, obtenida por eliminación gaussiana.
El resultado es el mismo que el devuelto por <code>echelon</code>, con la salvedad de que el primer elemento no nulo de cada fila no se normaliza a 1.
</p>
<p>Las funciones <code>lu_factor</code> y <code>cholesky</code> también triangularizan matrices.
</p>
<pre class="example">(%i1) M: matrix ([3, 7, aa, bb], [-1, 8, 5, 2], [9, 2, 11, 4]);
                       [  3   7  aa  bb ]
                       [                ]
(%o1)                  [ - 1  8  5   2  ]
                       [                ]
                       [  9   2  11  4  ]
(%i2) triangularize (M);
             [ - 1   8         5            2      ]
             [                                     ]
(%o2)        [  0   - 74     - 56         - 22     ]
             [                                     ]
             [  0    0    626 - 74 aa  238 - 74 bb ]
</pre>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>uniteigenvectors</b><i> (<var>M</var>)</i>
<a name="IDX995"></a>
</dt>
<dt><u>Función:</u> <b>ueivects</b><i> (<var>M</var>)</i>
<a name="IDX996"></a>
</dt>
<dd><p>Calcula los vectores propios unitarios de la matriz <var>M</var>. El valor que devuelve es una lista de listas, la primera de las cuales es la salida de la función <code>eigenvalues</code> y el resto de sublistas son los vectores propios unitarios de la matriz correspondiente a esos valores propios, respectivamente.
</p>
<p>Las variables citadas en la descripción de la función <code>eigenvectors</code> tienen los mismos efectos en <code>uniteigenvectors</code>.
</p>
<p>Si <code>knowneigvects</code> vale <code>true</code>, el paquete <code>eigen</code> da por supuesto que el usuario conoce los vectores propios de la matriz y que están guardados en la variable global <code>listeigvects</code>, en tal caso el contenido de  <code>listeigvects</code> debe ser una lista de estructura similar a la que devuelve la función <code>eigenvectors</code>.
</p>
<p>Si <code>knowneigvects</code> vale <code>true</code> y la lista de vectores propios está en la variable <code>listeigvects</code>, el valor de la variable <code>nondiagonalizable</code> puede que no sea el correcto. Si tal es el caso, debe asignarsele el valor correcto. </p>
<p>Para utilizar esta fucnión es necesario cargarla haciendo <code>load (&quot;eigen&quot;)</code>.
</p>
<p>El nombre <code>ueivects</code> es sinónimo de <code>uniteigenvectors</code>.
</p>
</dd></dl>

<dl>
<dt><u>Función:</u> <b>unitvector</b><i> (<var>x</var>)</i>
<a name="IDX997"></a>
</dt>
<dt><u>Función:</u> <b>uvect</b><i> (<var>x</var>)</i>
<a name="IDX998"></a>
</dt>
<dd><p>Devuelve <em><var>x</var>/norm(<var>x</var>)</em>, esto es, el vector unitario de igual dirección y sentido que <var>x</var>.
</p>
<p><code>load (&quot;eigen&quot;)</code> loads this function.
</p>
<p>Para utilizar esta fucnión es necesario cargarla haciendo <code>load (&quot;eigen&quot;)</code>.
</p>
<p>El nombre <code>uvect</code> es sinónimo de <code>unitvector</code>.
</p>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>vectorpotential</b><i> (<var>givencurl</var>)</i>
<a name="IDX999"></a>
</dt>
<dd><p>Devuelve el vector potencial de un vector rotacional en el sistema
de coordenadas actual. 
<code>potentialzeroloc</code> tiene un rol similar al de <code>potential</code>, 
pero el orden del miembro izquierdo de las ecuaciones debe ser una
permutación cíclica de las coordenadas. 
</p>
</dd></dl>




<dl>
<dt><u>Función:</u> <b>vectorsimp</b><i> (<var>expr</var>)</i>
<a name="IDX1000"></a>
</dt>
<dd><p>Realiza simplificaciones y expansiones de acuerdo con los valores de las siguientes variables globales:
</p>
<p><code>expandall</code>, <code>expanddot</code>, <code>expanddotplus</code>, <code>expandcross</code>, <code>expandcrossplus</code>,
<code>expandcrosscross</code>, <code>expandgrad</code>, <code>expandgradplus</code>, <code>expandgradprod</code>,
<code>expanddiv</code>, <code>expanddivplus</code>, <code>expanddivprod</code>, <code>expandcurl</code>, <code>expandcurlplus</code>,
<code>expandcurlcurl</code>, <code>expandlaplacian</code>, <code>expandlaplacianplus</code> y <code>expandlaplacianprod</code>.
</p>
<p>Todas estas variables tienen por defecto el valor <code>false</code>. El sufijo <code>plus</code> se refiere al uso de la suma o la distributividad.  El sufijo <code>prod</code> se refiere a la expansión de operadores que realizan cualquier tipo de producto.
</p>
<dl compact="compact">
<dt> <code>expandcrosscross</code></dt>
<dd><p>Simplifica <em>p ~ (q ~ r)</em> en <em>(p . r)*q - (p . q)*r</em>.
</p></dd>
<dt> <code>expandcurlcurl</code></dt>
<dd><p>Simplifica <em>curl curl p</em> en <em>grad div p + div grad p</em>.
</p></dd>
<dt> <code>expandlaplaciantodivgrad</code></dt>
<dd><p>Simplifica <em>laplacian p</em> en <em>div grad p</em>.
</p></dd>
<dt> <code>expandcross</code></dt>
<dd><p>Activa <code>expandcrossplus</code> y <code>expandcrosscross</code>.
</p></dd>
<dt> <code>expandplus</code></dt>
<dd><p>Activa <code>expanddotplus</code>, <code>expandcrossplus</code>, <code>expandgradplus</code>,
<code>expanddivplus</code>, <code>expandcurlplus</code> y <code>expandlaplacianplus</code>.
</p></dd>
<dt> <code>expandprod</code></dt>
<dd><p>Activa <code>expandgradprod</code>, <code>expanddivprod</code> y <code>expandlaplacianprod</code>.
</p></dd>
</dl>

<p>Estas variables están declaradas como <code>evflag</code>.
</p>

</dd></dl>




<dl>
<dt><u>Función:</u> <b>zeromatrix</b><i> (<var>m</var>, <var>n</var>)</i>
<a name="IDX1001"></a>
</dt>
<dd><p>Devuelve una matriz rectangular <var>m</var> por <var>n</var> con todos sus elementos iguales a cero.
</p>
</dd></dl>

<dl>
<dt><u>Símbolo especial:</u> <b>[</b>
<a name="IDX1002"></a>
</dt>
<dt><u>Símbolo especial:</u> <b>[</b>
<a name="IDX1003"></a>
</dt>
<dd><p>Los símbolos <code>[</code> y <code>]</code> marcan el comienzo y final, respectivamente, de una lista.
</p>
<p>Los símbolos <code>[</code> y <code>]</code> también se utilizan para indicar los subíndices de los elementos de una lista, arreglo o función arreglo.
</p>
<p>Ejemplos:
</p>
<pre class="example">(%i1) x: [a, b, c];
(%o1)                       [a, b, c]
(%i2) x[3];
(%o2)                           c
(%i3) array (y, fixnum, 3);
(%o3)                           y
(%i4) y[2]: %pi;
(%o4)                          %pi
(%i5) y[2];
(%o5)                          %pi
(%i6) z['foo]: 'bar;
(%o6)                          bar
(%i7) z['foo];
(%o7)                          bar
(%i8) g[k] := 1/(k^2+1);
                                  1
(%o8)                     g  := ------
                           k     2
                                k  + 1
(%i9) g[10];
                                1
(%o9)                          ---
                               101
</pre>
</dd></dl>


<hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC127" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_24.html#SEC133" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[<a href="maxima_80.html#SEC380" title="Index">Index</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>Robert Dodier</em> on <em>abril, 9 2015</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>.
 </font>
 <br>

</p>
</body>
</html>
