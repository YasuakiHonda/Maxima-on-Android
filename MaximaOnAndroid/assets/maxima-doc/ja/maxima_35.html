<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on 5月, 20 2015 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima 5.36.1 Manual: 35. Sets</title>

<meta name="description" content="Maxima 5.36.1 Manual: 35. Sets">
<meta name="keywords" content="Maxima 5.36.1 Manual: 35. Sets">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="figures/favicon.ico"/>

<script type="text/javascript"><!--

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-510249-14']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

--></script>
</head>

<body lang="ja" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Sets"></a>
<a name="SEC187"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_34.html#SEC186" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_34.html#SEC184" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 35. Sets </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC188">35.1 Introduction to Sets</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC193">35.2 Functions and Variables for Sets</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p><a name="Item_003a-Introduction-to-Sets"></a>
</p><hr size="6">
<a name="Introduction-to-Sets"></a>
<a name="SEC188"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC187" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC189" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC187" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 35.1 Introduction to Sets </h2>

<p>Maximaは、
明示的な列挙によって定義された有限集合用に、積集合や和集合のような集合関数を提供します。
Maximaはリストと集合を別のオブジェクトとして扱います。
この特長は、要素がリストであったり集合であったりする集合を扱うことを可能にします。
</p>
<p>有限集合のための関数に加えて、 Maximaは組み合わせ論に関係したいくつかの関数を提供します;
これらは、第一種と第二種スターリング数、ベル数、第一種と第二種の多項係数、
非負整数の分割、と2,3の他の関数を含みます。
Maximaはクロネッカーのデルタ関数も定義します。
</p>
<hr size="6">
<a name="SEC189"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC188" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC190" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.1 Usage </h3>

<p>要素 <code>a_1, ..., a_n</code>の集合を構成するには、
<code>set(a_1, ..., a_n)</code>または <code>{a_1, ..., a_n}</code>と書いてください;
空集合を構成するには <code>set()</code>または <code>{}</code>を書いてください。
入力では <code>set(...)</code>と <code>{ ... }</code>は同値です。
集合はいつも中括弧で表示されます。
</p>
<p>もし要素が一度以上リストされているなら、整理によって冗長な要素は消去されます。
</p>
<pre class="example">(%i1) set();
(%o1)                          {}
(%i2) set(a, b, a);
(%o2)                        {a, b}
(%i3) set(a, set(b));
(%o3)                       {a, {b}}
(%i4) set(a, [b]);
(%o4)                       {a, [b]}
(%i5) {};
(%o5)                          {}
(%i6) {a, b, a};
(%o6)                        {a, b}
(%i7) {a, {b}};
(%o7)                       {a, {b}}
(%i8) {a, [b]};
(%o8)                       {a, [b]}
</pre>
<p>２つの要素候補 <var>x</var>と <var>y</var>は、
<code>is(<var>x</var> = <var>y</var>)</code>が <code>true</code>をもたらす
(すなわち、集合構成の目的で同じと見なされる)時だけ冗長です。
<code>is(<var>x</var> = <var>y</var>)</code>が <code>false</code>をもたらす一方、
<code>is(equal(<var>x</var>, <var>y</var>))</code>は <code>true</code>をもたらす可能性があることに
注意してください;
その場合、要素 <var>x</var>と <var>y</var>は異なったものと見なされます。
</p>
<pre class="example">(%i1) x: a/c + b/c;
                              b   a
(%o1)                         - + -
                              c   c
(%i2) y: a/c + b/c;
                              b   a
(%o2)                         - + -
                              c   c
(%i3) z: (a + b)/c;
                              b + a
(%o3)                         -----
                                c
(%i4) is (x = y);
(%o4)                         true
(%i5) is (y = z);
(%o5)                         false
(%i6) is (equal (y, z));
(%o6)                         true
(%i7) y - z;
                           b + a   b   a
(%o7)                    - ----- + - + -
                             c     c   c
(%i8) ratsimp (%);
(%o8)                           0
(%i9) {x, y, z};
                          b + a  b   a
(%o9)                    {-----, - + -}
                            c    c   c
</pre>
<p>リストの要素から集合を構成するには <code>setify</code>を使ってください。
</p>
<pre class="example">(%i1) setify ([b, a]);
(%o1)                        {a, b}
</pre>
<p>もし <code>is(x = y)</code>が <code>true</code>に評価されるなら、
集合の要素 <code>x</code>と <code>y</code>は等しいです。
従って <code>rat(x)</code>と <code>x</code>は集合の元として等しいです;
結果として
</p>
<pre class="example">(%i1) {x, rat(x)};
(%o1)                          {x}
</pre>
<p>さらに、
<code>is((x - 1)*(x + 1) = x^2 - 1)</code>は <code>false</code>に評価されるので、
<code>(x - 1)*(x + 1)</code>と <code>x^2 - 1</code>は集合の異なる要素です;
従って
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
</pre>
<p>この集合を 1要素集合に縮小するには、
<code>rat</code>を集合の元それぞれに適用してください:
</p>
<pre class="example">(%i1) {(x - 1)*(x + 1), x^2 - 1};
                                       2
(%o1)               {(x - 1) (x + 1), x  - 1}
(%i2) map (rat, %);
                              2
(%o2)/R/                    {x  - 1}
</pre>
<p>他の集合から冗長性を取り除くために他の整理関数を使う必要があるかもしれません。
以下は <code>trigsimp</code>を使った例です:
</p>
<pre class="example">(%i1) {1, cos(x)^2 + sin(x)^2};
                            2         2
(%o1)                {1, sin (x) + cos (x)}
(%i2) map (trigsimp, %);
(%o2)                          {1}
</pre>
<p>元が冗長でなく、並べ換えられている時、集合は整理されてます。
集合関数の現在のバージョンは
集合を順に並べるためにMaxima関数 <code>orderlessp</code>を使います;
しかしながら、
<i>集合関数の将来のバージョンは、違う並び替え関数を使うかもしれません。</i>
</p>
<p>代入のような集合に関するいくつかの演算は、再整理を自動的に強制します;
例えば、
</p>
<pre class="example">(%i1) s: {a, b, c}$
(%i2) subst (c=a, s);
(%o2)                        {a, b}
(%i3) subst ([a=x, b=x, c=x], s);
(%o3)                          {x}
(%i4) map (lambda ([x], x^2), set (-1, 0, 1));
(%o4)                        {0, 1}
</pre>
<p>Maximaはリストと集合を異なるオブジェクトとして扱います;
<code>union</code>や <code>intersection</code>のような関数は、
もし引数のいずれかが集合でないなら文句を言います。
もしリストに集合関数を適用する必要があるなら、
集合に変換するために <code>setify</code>関数を使ってください。
例えば、
</p>
<pre class="example">(%i1) union ([1, 2], {a, b});
Function union expects a set, instead found [1,2]
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i2) union (setify ([1, 2]), {a, b});
(%o2)                     {1, 2, a, b}
</pre>
<p>集合 <code>s</code>の集合要素のうち述語論理 <code>f</code>を満たすすべての要素を抽出するためには、
<code>subset(s, f)</code>を使ってください。
(<i>述語論理</i>はブーリアン値関数です。)
例えば、
与えられた集合の中で変数 <code>z</code>に依存しない等式を見つけるには、
以下を使ってください。
</p>
<pre class="example">(%i1) subset ({x + y + z, x - y + 4, x + y - 5},
                                    lambda ([e], freeof (z, e)));
(%o1)               {- y + x + 4, y + x - 5}
</pre>
<p>節 <a href="#SEC193">Functions and Variables for Sets</a>には
Maximaの集合関数すべてがリストされます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
<hr size="6">
<a name="SEC190"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC189" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC191" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.2 Set Member Iteration </h3>

<p>集合の要素上を反復する２つの方法があります。
１つの方法は <code>map</code>の使用です;
例えば:
</p>
<pre class="example">(%i1) map (f, {a, b, c});
(%o1)                  {f(a), f(b), f(c)}
</pre>
<p>他の方法は
<code>for <var>x</var> in <var>s</var> do</code>を使うことです。
</p>
<pre class="example">(%i1) s: {a, b, c};
(%o1)                       {a, b, c}
(%i2) for si in s do print (concat (si, 1));
a1
b1
c1
(%o2)                         done
</pre>
<p>Maxima関数 <code>first</code>と <code>rest</code>は集合に対して正しく機能します。
集合に適用されると、
<code>first</code>は最初に表示される集合の要素を返します;
それは実装依存かもしれません。
もし <code>s</code>が集合なら、
<code>rest(s)</code>は <code>disjoin(first(s), s)</code>と同値です。
今は、集合に対して正しく機能する Maxima関数が他にもあります。
集合関数の将来のバージョンでは、
<code>first</code>と <code>rest</code>は今と違うように動くかもしれませんし、
全く動かないかもしれません。
</p>
<hr size="6">
<a name="SEC191"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC190" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC192" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.3 Bugs </h3>

<p>集合関数は集合の要素を並び換えるために Maxima関数 <code>orderlessp</code>を使い、
集合の要素の同一性をテストするために (Lispレベルの)関数 <code>like</code>を使います。
これらの関数両方に既知のバグがあり、
もし標準有理式 (CRE)形式の式を含むリストや行列を要素に持つ集合を使おうとするなら、
バグが現れるかもしれません。
例は以下の通りです。
</p>
<pre class="example">(%i1) {[x], [rat (x)]};
Maxima encountered a Lisp error:

  The value #:X1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>この式は Maximaがエラーで停止する原因となります。
(エラーメッセージは Maximaが使う Lispのバージョンに依ります。)
もう１つの例は以下の通りです。
</p>
<pre class="example">(%i1) setify ([[rat(a)], [rat(b)]]);
Maxima encountered a Lisp error:

  The value #:A1440 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
</pre>
<p>これらのバグは <code>orderlessp</code>と <code>like</code>の中にあるバグに起因します;
それらは集合関数の中のバグが原因ではありません。
例証するには以下の式を試してください。
</p>
<pre class="example">(%i1) orderlessp ([rat(a)], [rat(b)]);
Maxima encountered a Lisp error:

  The value #:B1441 is not of type LIST.

Automatically continuing.
To reenable the Lisp debugger set *debugger-hook* to nil.
(%i2) is ([rat(a)] = [rat(a)]);
(%o2)                         false
</pre>
<p>これらのバグが直されるまで、
CRE形式の式を含むリストや行を要素に持つ集合を構成しないでください;
しかしながら、 CRE形式の要素を持つ集合は問題ないはずです:
</p>
<pre class="example">(%i1) {x, rat (x)};
(%o1)                          {x}
</pre>
<p>Maximaの <code>orderlessp</code>には、
集合関数で問題の原因となる可能性がある別のバグがあります。
それは、すなわち、順序付け述語論理 <code>orderlessp</code>が推移的でないことです。
これを示す最も簡単な既知の例は以下の通りです。
</p>
<pre class="example">(%i1) q: x^2$
(%i2) r: (x + 1)^2$
(%i3) s: x*(x + 2)$
(%i4) orderlessp (q, r);
(%o4)                         true
(%i5) orderlessp (r, s);
(%o5)                         true
(%i6) orderlessp (q, s);
(%o6)                         false
</pre>
<p>このバグは、一般的に
Maximaの関数はもちろん、集合関数すべてにおいて問題の原因となる可能性があります。
確実ではありませんが、
もし集合の要素すべてが CRE形式であるか、
<code>ratsimp</code>を使って整理されていれるなら、このバグはたぶん避けられます。
</p>
<p>Maximaの <code>orderless</code>と
<code>ordergreat</code>メカニズムは集合関数と互換性がありません。
もし <code>orderless</code>か <code>ordergreat</code>のいずれかを使う必要があるなら、
どんなものでも集合を構成する前にこれらの関数をコールしてください。
そして <code>unorder</code>をコールしないでください。
</p>

<p>もし集合関数のバグかもしれないと思う何かを見つけたら、
どうか Maximaのバグデータベースに報告してください。
<code>bug_report</code>を参照してください。
</p>
<hr size="6">
<a name="SEC192"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC191" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC193" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC188" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 35.1.4 Authors </h3>

<p>マサチューセッツ州ケンブリッジ市の Stavros Macrakisと
ネブラスカ大学カーニー校(UNK)の Barton Willisが
Maximaの集合関数とそれらのドキュメンテーションを書きました。
</p>
<p><a name="Item_003a-Functions-and-Variables-for-Sets"></a>
</p><hr size="6">
<a name="Functions-and-Variables-for-Sets"></a>
<a name="SEC193"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC192" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC187" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 35.2 Functions and Variables for Sets </h2>

<p><a name="adjoin"></a>
<a name="Item_003a-adjoin"></a>
</p><dl>
<dt><u>関数:</u> <b>adjoin</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX1274"></a>
</dt>
<dd><p>集合 <var>a</var>に要素 <code>{<var>x</var>}</code>を加えた集合を返します。
</p>
<p>もし <var>a</var>が集合リテラルでないなら <code>adjoin</code>は文句を言います。
</p>
<p><code>adjoin(<var>x</var>, <var>a</var>)</code>と <code>union(set(<var>x</var>), <var>a</var>)</code>は同値です;
しかし <code>adjoin</code>は <code>union</code>より幾分早いかもしれません。
</p>
<p><code>disjoin</code>も参照してください。
</p>
<p>例:
</p>
<pre class="example">(%i1) adjoin (c, {a, b});
(%o1)                       {a, b, c}
(%i2) adjoin (a, {a, b});
(%o2)                        {a, b}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="belln"></a>
<a name="Item_003a-belln"></a>
</p><dl>
<dt><u>関数:</u> <b>belln</b><i> (<var>n</var>)</i>
<a name="IDX1275"></a>
</dt>
<dd><p><em>n</em>番目のベル数を返します。
<code>belln(n)</code>は <var>n</var>個のメンバーを持つ集合の分割の数です。
</p>
<p>非負整数 <var>n</var>の場合、
<code>belln(<var>n</var>)</code>は <em>n</em>番目のベル数に整理されます。
他の引数の場合どんなものでも <code>belln</code>は整理されません。
</p>

<p><code>belln</code>は等式、リスト、行列、集合上に分配されます。
</p>
<p>例:
</p>
<p>非負整数に適用された <code>belln</code>。
</p>
<pre class="example">(%i1) makelist (belln (i), i, 0, 6);
(%o1)               [1, 1, 2, 5, 15, 52, 203]
(%i2) is (cardinality (set_partitions ({})) = belln (0));
(%o2)                         true
(%i3) is (cardinality (set_partitions ({1, 2, 3, 4, 5, 6})) =
                       belln (6));
(%o3)                         true
</pre>
<p>非負整数でない引数に適用された <code>belln</code>。
</p>
<pre class="example">(%i1) [belln (x), belln (sqrt(3)), belln (-9)];
(%o1)        [belln(x), belln(sqrt(3)), belln(- 9)]
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="cardinality"></a>
<a name="Item_003a-cardinality"></a>
</p><dl>
<dt><u>関数:</u> <b>cardinality</b><i> (<var>a</var>)</i>
<a name="IDX1276"></a>
</dt>
<dd><p>集合 <var>a</var>の異なる要素の数を返します。
</p>
<p>整理がディセーブルされた時でも <code>cardinality</code>は冗長な要素を無視します。
</p>
<p>例:
</p>
<pre class="example">(%i1) cardinality ({});
(%o1)                           0
(%i2) cardinality ({a, a, b, c});
(%o2)                           3
(%i3) simp : false;
(%o3)                         false
(%i4) cardinality ({a, a, b, c});
(%o4)                           3
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="cartesian_005fproduct"></a>
<a name="Item_003a-cartesian_005fproduct"></a>
</p><dl>
<dt><u>関数:</u> <b>cartesian_product</b><i> (<var>b_1</var>, ... , <var>b_n</var>)</i>
<a name="IDX1277"></a>
</dt>
<dd><p>形式 <code>[<var>x_1</var>, ..., <var>x_n</var>]</code>のリストの集合を返します。
ここで <var>x_1</var>, ..., <var>x_n</var>はそれぞれ集合
<var>b_1</var>, ... , <var>b_n</var>の要素です。
</p>
<p>もし任意の引数が集合リテラルでないなら <code>cartesian_product</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) cartesian_product ({0, 1});
(%o1)                      {[0], [1]}
(%i2) cartesian_product ({0, 1}, {0, 1});
(%o2)           {[0, 0], [0, 1], [1, 0], [1, 1]}
(%i3) cartesian_product ({x}, {y}, {z});
(%o3)                      {[x, y, z]}
(%i4) cartesian_product ({x}, {-1, 0, 1});
(%o4)              {[x, - 1], [x, 0], [x, 1]}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>


<p><a name="disjoin"></a>
<a name="Item_003a-disjoin"></a>
</p><dl>
<dt><u>関数:</u> <b>disjoin</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX1278"></a>
</dt>
<dd><p>要素 <var>x</var>を持たない集合 <var>a</var>を返します。
もし <var>x</var>が <var>a</var>のメンバーでないなら <var>a</var>をそのまま返します。
</p>
<p>もし <var>a</var>が集合リテラルでないなら <code>disjoin</code>は文句を言います。
</p>
<p><code>disjoin(<var>x</var>, <var>a</var>)</code>, <code>delete(<var>x</var>, <var>a</var>)</code>,
<code>setdifference(<var>a</var>, set(<var>x</var>))</code>はすべて同値です。
これらの中で <code>disjoin</code>は一般的に他より速いです。
</p>
<p>例:
</p>
<pre class="example">(%i1) disjoin (a, {a, b, c, d});
(%o1)                       {b, c, d}
(%i2) disjoin (a + b, {5, z, a + b, %pi});
(%o2)                      {5, %pi, z}
(%i3) disjoin (a - b, {5, z, a + b, %pi});
(%o3)                  {5, %pi, b + a, z}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="disjointp"></a>
<a name="Item_003a-disjointp"></a>
</p><dl>
<dt><u>関数:</u> <b>disjointp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1279"></a>
</dt>
<dd><p>集合 <var>a</var>と <var>b</var>が交わらないなら <code>true</code>を返します。
</p>
<p>もし <var>a</var>か <var>b</var>が集合リテラルでないなら <code>disjointp</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) disjointp ({a, b, c}, {1, 2, 3});
(%o1)                         true
(%i2) disjointp ({a, b, 3}, {1, 2, 3});
(%o2)                         false
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Predicate-functions">Predicate functions</a>
</div>
</p>
</dd></dl>

<p><a name="divisors"></a>
<a name="Item_003a-divisors"></a>
</p><dl>
<dt><u>関数:</u> <b>divisors</b><i> (<var>n</var>)</i>
<a name="IDX1280"></a>
</dt>
<dd><p><var>n</var>の約数の集合を表します。
</p>
<p><var>n</var>がゼロでない整数の時、
<code>divisors(<var>n</var>)</code>は整数の集合に整理されます。
約数の集合は要素 1と <var>n</var>を含みます。
負の整数の約数はその絶対値の約数です。
</p>
<p><code>divisors</code>は等式、リスト、行列、集合上に分配されます。
</p>
<p>例:
</p>
<p>28は完全数であることを検証できます:
(自身を除いた)約数が 28です。
</p>
<pre class="example">(%i1) s: divisors(28);
(%o1)                 {1, 2, 4, 7, 14, 28}
(%i2) lreduce (&quot;+&quot;, args(s)) - 28;
(%o2)                          28
</pre>
<p><code>divisors</code>は整理関数です。
<code>divisors(a)</code>の中で <code>a</code>に8を代入することは、
<code>divisors(8)</code>を再評価せずに約数をもたらします。
</p>
<pre class="example">(%i1) divisors (a);
(%o1)                      divisors(a)
(%i2) subst (8, a, %);
(%o2)                     {1, 2, 4, 8}
</pre>
<p><code>divisors</code>は等式、リスト、行列、集合上に分配されます。
</p>
<pre class="example">(%i1) divisors (a = b);
(%o1)               divisors(a) = divisors(b)
(%i2) divisors ([a, b, c]);
(%o2)        [divisors(a), divisors(b), divisors(c)]
(%i3) divisors (matrix ([a, b], [c, d]));
                  [ divisors(a)  divisors(b) ]
(%o3)             [                          ]
                  [ divisors(c)  divisors(d) ]
(%i4) divisors ({a, b, c});
(%o4)        {divisors(a), divisors(b), divisors(c)}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Integers">Integers</a>
</div>
</p>
</dd></dl>

<p><a name="elementp"></a>
<a name="Item_003a-elementp"></a>
</p><dl>
<dt><u>関数:</u> <b>elementp</b><i> (<var>x</var>, <var>a</var>)</i>
<a name="IDX1281"></a>
</dt>
<dd><p><var>x</var>が集合 <var>a</var>の要素の場合だけ <code>true</code>を返します。
</p>
<p>もし <var>a</var>が集合リテラルでないなら <code>elementp</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) elementp (sin(1), {sin(1), sin(2), sin(3)});
(%o1)                         true
(%i2) elementp (sin(1), {cos(1), cos(2), cos(3)});
(%o2)                         false
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Predicate-functions">Predicate functions</a>
</div>
</p>
</dd></dl>

<p><a name="emptyp"></a>
<a name="Item_003a-emptyp"></a>
</p><dl>
<dt><u>関数:</u> <b>emptyp</b><i> (<var>a</var>)</i>
<a name="IDX1282"></a>
</dt>
<dd><p><var>a</var>が空の集合か空のリストの場合だけ <code>true</code>を返します。
</p>
<p>例:
</p>
<pre class="example">(%i1) map (emptyp, [{}, []]);
(%o1)                     [true, true]
(%i2) map (emptyp, [a + b, {{}}, %pi]);
(%o2)                 [false, false, false]
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Predicate-functions">Predicate functions</a>
</div>
</p>
</dd></dl>

<p><a name="equiv_005fclasses"></a>
<a name="Item_003a-equiv_005fclasses"></a>
</p><dl>
<dt><u>関数:</u> <b>equiv_classes</b><i> (<var>s</var>, <var>F</var>)</i>
<a name="IDX1283"></a>
</dt>
<dd><p>集合 <var>s</var>の同値関係 <var>F</var>に関する同値クラスの集合を返します。
</p>
<p><var>F</var>は <var>s</var>の <var>s</var>との直積集合上の２変数関数です。
<var>F</var>の戻り値は <code>true</code>か <code>false</code>、もしくは
<code>is(<var>expr</var>)</code>が <code>true</code>か <code>false</code>のような
式 <var>expr</var>です。
</p>
<p><var>F</var>が同値関数でない時、
<code>equiv_classes</code>は不平なくそれを受け入れますが、
その場合、結果は一般に正しくありません。
</p>

<p>例:
</p>
<p>同値関係が <code>true</code>か <code>false</code>を返すラムダ式です。
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0},
                        lambda ([x, y], is (equal (x, y))));
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>同値関係が、<code>is</code>が <code>true</code>か <code>false</code>に評価される
関係関数の名前です。
</p>
<pre class="example">(%i1) equiv_classes ({1, 1.0, 2, 2.0, 3, 3.0}, equal);
(%o1)            {{1, 1.0}, {2, 2.0}, {3, 3.0}}
</pre>
<p>同値クラスが 3の倍数だけ違う数です。
</p>
<pre class="example">(%i1) equiv_classes ({1, 2, 3, 4, 5, 6, 7},
                     lambda ([x, y], remainder (x - y, 3) = 0));
(%o1)              {{1, 4, 7}, {2, 5}, {3, 6}}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="every"></a>
<a name="Item_003a-every"></a>
</p><dl>
<dt><u>関数:</u> <b>every</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>every</tt> (<var>f</var>, <var>s</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>every</tt> (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</i>
<a name="IDX1284"></a>
</dt>
<dd><p>もし述語論理 <var>f</var>が与えられた引数すべてで <code>true</code>なら、
<code>true</code>を返します。
</p>
<p>ある集合が二番目の引数として与えられたとして、
もし <code>is(<var>f</var>(<var>a_i</var>))</code>が
<var>s</var>の中の <var>a_i</var>すべてに関して <code>true</code>を返すなら、
<code>every(<var>f</var>, <var>s</var>)</code>は <code>true</code>です。
<code>every</code>は <var>s</var>の中の <var>a_i</var>すべてに関して
<var>f</var>を評価するかどうかわかりません。
集合は順序付けされていないので、
<code>every</code>は任意の順序で <code><var>f</var>(<var>a_i</var>)</code>を評価します。
</p>
<p>引数に１つか複数のリストが与えられたとして、
もし <code>is(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>))</code>が
<var>L_1</var>, ..., <var>L_n</var>それぞれの中の <var>x_1</var>, ..., <var>x_n</var>すべてに対して
<code>true</code>を返すなら、
<code>every(<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code>は <code>true</code>を返します。
<code>every</code>は、
<var>x_1</var>, ..., <var>x_n</var>のすべての組み合わせに対して
<var>f</var>を評価するかどうかわかりません。
<code>every</code>はインデックスを増やす順序でリストを評価します。
</p>
<p>空の集合 <code>{}</code>または空のリスト <code>[]</code>が引数に与えられると、
<code>every</code>は <code>true</code>を返します。
</p>
<p>グローバルフラグ <code>maperror</code>が <code>true</code>の時、
リスト <var>L_1</var>, ..., <var>L_n</var>すべては長さが等しくなければいけません。
<code>maperror</code>が <code>false</code>の時、
リスト引数は最短のリストの長さに効果的に切り詰められます。
</p>
<p><code>true</code>か <code>false</code>以外の何かに
(<code>is</code>を介して)評価される述語論理 <var>f</var>の戻り値は、
<code>prederror</code>が決定します。
<code>prederror</code>が <code>true</code>の時、
そんな値は <code>false</code>として扱われ、
<code>every</code>の戻り値は <code>false</code>です。
<code>prederror</code>が <code>false</code>の時、
そんな値は <code>unknown</code>として扱われ、
<code>every</code>の戻り値は <code>unknown</code>です。
</p>
<p>例:
</p>
<p>１つの集合に適用された <code>every</code>。
述語論理は１引数関数です。
</p>
<pre class="example">(%i1) every (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) every (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         false
</pre>
<p>２つのリストに適用された <code>every</code>。
述語論理は２引数関数です。
</p>
<pre class="example">(%i1) every (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) every (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p><code>true</code>か <code>false</code>以外の何かに評価される
述語論理 <var>f</var>の戻り値はグローバルフラグ
<code>prederror</code>が決定します。
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z],
                   [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) prederror : true;
(%o4)                         true
(%i5) every (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o5)                         false
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="extremal_005fsubset"></a>
<a name="Item_003a-extremal_005fsubset"></a>
</p><dl>
<dt><u>関数:</u> <b>extremal_subset</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>extremal_subset</tt> (<var>s</var>, <var>f</var>, max) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>extremal_subset</tt> (<var>s</var>, <var>f</var>, min)</i>
<a name="IDX1285"></a>
</dt>
<dd><p>要素に関数 <var>f</var>を適用した結果が最大または最小値になるような
<var>s</var>の部分集合を返します。
</p>
<p><code>extremal_subset(<var>s</var>, <var>f</var>, max)</code>は、
実数値関数 <var>f</var>が最大値を取る、
集合またはリスト <var>s</var>の部分集合を返します。
</p>
<p><code>extremal_subset(<var>s</var>, <var>f</var>, min)</code>は、
実数値関数 <var>f</var>が最小値を取る、
集合またはリスト <var>s</var>の部分集合を返します。
</p>
<p>例:
</p>
<pre class="example">(%i1) extremal_subset ({-2, -1, 0, 1, 2}, abs, max);
(%o1)                       {- 2, 2}
(%i2) extremal_subset ({sqrt(2), 1.57, %pi/2}, sin, min);
(%o2)                       {sqrt(2)}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="flatten"></a>
<a name="Item_003a-flatten"></a>
</p><dl>
<dt><u>関数:</u> <b>flatten</b><i> (<var>expr</var>)</i>
<a name="IDX1286"></a>
</dt>
<dd><p><var>expr</var>と同じ演算子を持つ部分式の引数を集め、これらの集めた引数から式を構成します。
</p>
<p><code>expr</code>の主演算子と違った演算子の部分式は、
たとえそれらが逆に <code>expr</code>に関するものと同じ演算子の部分式を含んだとしても、
変更なしにコピーされます。
</p>
<p>引数の数が演算子に関して宣言された引数と違う式を
<code>flatten</code>が構成する可能性があるかもしれません;
これは整理器や評価器からのエラーメッセージを起こさせるかもしれません。
<code>flatten</code>はそんな状況を検出しようとしません。
</p>
<p>特別な表現の式、例えば、標準有理式 (CRE)はflattenできません;
そんな場合、<code>flatten</code>は引数を変更なしに返します。
</p>
<p>例:
</p>
<p>リストに適用すると、 <code>flatten</code>はリストの要素すべてを集めます。
</p>
<pre class="example">(%i1) flatten ([a, b, [c, [d, e], f], [[g, h]], i, j]);
(%o1)            [a, b, c, d, e, f, g, h, i, j]
</pre>
<p>集合に適用すると、 <code>flatten</code>は集合の要素すべてを集めます。
</p>
<pre class="example">(%i1) flatten ({a, {b}, {{c}}});
(%o1)                       {a, b, c}
(%i2) flatten ({a, {[a], {a}}});
(%o2)                       {a, [a]}
</pre>
<p><code>flatten</code>は主演算子を n項に宣言する効果に似ています。
しかしながら、<code>flatten</code>は主演算子と違う演算子を持つ部分式上に影響を持ちません。
一方、 n項宣言はそれらに影響します。
</p>
<pre class="example">(%i1) expr: flatten (f (g (f (f (x)))));
(%o1)                     f(g(f(f(x))))
(%i2) declare (f, nary);
(%o2)                         done
(%i3) ev (expr);
(%o3)                      f(g(f(x)))
</pre>
<p><code>flatten</code>は他の任意の演算子と同じように添字付き関数を扱います。
</p>
<pre class="example">(%i1) flatten (f[5] (f[5] (x, y), z));
(%o1)                      f (x, y, z)
                            5
</pre>
<p>引数の数が演算子に関して宣言された引数と違う式を
<code>flatten</code>が構成する可能性があるかもしれません;
</p>
<pre class="example">(%i1) 'mod (5, 'mod (7, 4));
(%o1)                   mod(5, mod(7, 4))
(%i2) flatten (%);
(%o2)                     mod(5, 7, 4)
(%i3) ''%, nouns;
Wrong number of arguments to mod
 -- an error.  Quitting.  To debug this try debugmode(true);
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="full_005flistify"></a>
<a name="Item_003a-full_005flistify"></a>
</p><dl>
<dt><u>関数:</u> <b>full_listify</b><i> (<var>a</var>)</i>
<a name="IDX1287"></a>
</dt>
<dd><p><var>a</var>の中のすべての集合演算子をリスト演算子で置き換え、結果を返します。
<code>full_listify</code>は、たとえ主演算子が <code>set</code>でなくても
入れ子の部分式の中の集合演算子を置き換えます。
</p>
<p><code>listify</code>は主演算子だけを置き換えます。
</p>
<p>例:
</p>
<pre class="example">(%i1) full_listify ({a, b, {c, {d, e, f}, g}});
(%o1)               [a, b, [c, [d, e, f], g]]
(%i2) full_listify (F (G ({a, b, H({c, d, e})})));
(%o2)              F(G([a, b, H([c, d, e])]))
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="fullsetify"></a>
<a name="Item_003a-fullsetify"></a>
</p><dl>
<dt><u>関数:</u> <b>fullsetify</b><i> (<var>a</var>)</i>
<a name="IDX1288"></a>
</dt>
<dd><p><var>a</var>がリストの時、リスト演算子を集合演算子で置き換え、
<code>fullsetify</code>を集合であるメンバーそれぞれに適用します。
<var>a</var>がリストでない時、変更なしで返します。
</p>
<p><code>setify</code>は主演算子だけを置き換えます。
</p>
<p>例:
</p>

<p><code>f([b])</code>の主演算子はリストでないので、行 <code>(%o2)</code>で
<code>f</code>の引数は集合に変換されません。
</p>
<pre class="example">(%i1) fullsetify ([a, [a]]);
(%o1)                       {a, {a}}
(%i2) fullsetify ([a, f([b])]);
(%o2)                      {a, f([b])}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="identity"></a>
<a name="Item_003a-identity"></a>
</p><dl>
<dt><u>関数:</u> <b>identity</b><i> (<var>x</var>)</i>
<a name="IDX1289"></a>
</dt>
<dd><p>任意の引数 <var>x</var>に対して <var>x</var>を返します。
</p>
<p>例:
</p>
<p><code>identity</code>は、引数が既にブーリアン値の時、述語論理として使うことができます。
</p>
<pre class="example">(%i1) every (identity, [true, true]);
(%o1)                         true
</pre></dd></dl>

<p><a name="integer_005fpartitions"></a>
<a name="Item_003a-integer_005fpartitions"></a>
</p><dl>
<dt><u>関数:</u> <b>integer_partitions</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>integer_partitions</tt> (<var>n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>integer_partitions</tt> (<var>n</var>, <var>len</var>)</i>
<a name="IDX1290"></a>
</dt>
<dd><p><var>n</var>の整数分割を返します。
すなわち、和が <var>n</var>になる整数のリストです。
</p>
<p><code>integer_partitions(<var>n</var>)</code>は整数 <var>n</var>の分割すべての集合を返します。
分割それぞれは大きい順に並べられたリストです。
</p>
<p><code>integer_partitions(<var>n</var>, <var>len</var>)</code>は、長さ
<var>len</var>以下の分割すべてを返します;
この場合、
<var>len</var>より少ない項を持つ分割それぞれには、
厳密に <var>len</var>項持つ分割にするようにゼロが足されます。
分割それぞれは大きい順に並べられたリストです。
</p>
<p>リスト <em>[a_1, ..., a_m]</em>は、
(1) <em>a_i</em>それぞれが非ゼロ整数、かつ、
(2) <em>a_1 + ... + a_m = n.</em>
の時、非負整数 <em>n</em>の分割です。
従って 0は分割を持ちません。
</p>
<p>例:
</p>
<pre class="example">(%i1) integer_partitions (3);
(%o1)               {[1, 1, 1], [2, 1], [3]}
(%i2) s: integer_partitions (25)$
(%i3) cardinality (s);
(%o3)                         1958
(%i4) map (lambda ([x], apply (&quot;+&quot;, x)), s);
(%o4)                         {25}
(%i5) integer_partitions (5, 3);
(%o5) {[2, 2, 1], [3, 1, 1], [3, 2, 0], [4, 1, 0], [5, 0, 0]}
(%i6) integer_partitions (5, 2);
(%o6)               {[3, 2], [4, 1], [5, 0]}
</pre>
<p>条件を満たす分割すべてを見つけるには、
関数 <code>subset</code>を使ってください;
以下は素数から成る 10の分割すべてを見つける例です。
</p>
<pre class="example">(%i1) s: integer_partitions (10)$
(%i2) cardinality (s);
(%o2)                          42
(%i3) xprimep(x) := integerp(x) and (x &gt; 1) and primep(x)$
(%i4) subset (s, lambda ([x], every (xprimep, x)));
(%o4) {[2, 2, 2, 2, 2], [3, 3, 2, 2], [5, 3, 2], [5, 5], [7, 3]}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Integers">Integers</a>
</div>
</p>
</dd></dl>

<p><a name="intersect"></a>
<a name="Item_003a-intersect"></a>
</p><dl>
<dt><u>関数:</u> <b>intersect</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1291"></a>
</dt>
<dd><p><code>intersect</code>は以下に見る <code>intersection</code>と同じです。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="intersection"></a>
<a name="Item_003a-intersection"></a>
</p><dl>
<dt><u>関数:</u> <b>intersection</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1292"></a>
</dt>
<dd><p>集合 <var>a_1</var>から <var>a_n</var>までに共通な要素を含む集合を返します。
</p>
<p>もし引数のいずれかが集合リテラルでないなら <code>intersection</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, d};
(%o1)                     {a, b, c, d}
(%i2) S_2 : {d, e, f, g};
(%o2)                     {d, e, f, g}
(%i3) S_3 : {c, d, e, f};
(%o3)                     {c, d, e, f}
(%i4) S_4 : {u, v, w};
(%o4)                       {u, v, w}
(%i5) intersection (S_1, S_2);
(%o5)                          {d}
(%i6) intersection (S_2, S_3);
(%o6)                       {d, e, f}
(%i7) intersection (S_1, S_2, S_3);
(%o7)                          {d}
(%i8) intersection (S_1, S_2, S_3, S_4);
(%o8)                          {}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="Item_003a-kron_005fdelta"></a>
</p><dl>
<dt><u>関数:</u> <b>kron_delta</b><i> (<var>x</var>, <var>y</var>, &hellip;, <var>xp</var>)</i>
<a name="IDX1293"></a>
</dt>
<dd><p>クロネッカーのデルタ関数を表します。
</p>
<p><code>kron_delta</code>は、 <var>xi</var>と <var>yj</var>が引数のすべての対で等しい時
1に整理され、
<var>xi</var>と <var>yj</var>が引数のある対で等しくない時
0に整理されます。
等号は <code>is(equal(xi,j))</code>を使って決定され、
不等号は <code>is(notsqual(xi,xj))</code>を使って決定されます。
引数が1つの場合、 <code>kron_delta</code>はエラーをシグナルします。
</p>
<p>例:
</p>
<pre class="example">(%i1) kron_delta(a,a);
(%o1)                                  1
(%i2) kron_delta(a,b,a,b);
(%o2)                          kron_delta(a, b)
(%i3) kron_delta(a,a,b,a+1);
(%o3)                                  0
(%i4) assume(equal(x,y));
(%o4)                            [equal(x, y)]
(%i5) kron_delta(x,y);
(%o5)                                  1
</pre>

</dd></dl>

<p><a name="listify"></a>
<a name="Item_003a-listify"></a>
</p><dl>
<dt><u>関数:</u> <b>listify</b><i> (<var>a</var>)</i>
<a name="IDX1294"></a>
</dt>
<dd><p><var>a</var>が集合の時、<var>a</var>の要素を含むリストを返します。
そうでないなら、 <code>listify</code>は <var>a</var>を返します。
</p>
<p><code>full_listify</code>は <var>a</var>の中の集合演算子をリスト演算子に置き換えます。
</p>
<p>例:
</p>
<pre class="example">(%i1) listify ({a, b, c, d});
(%o1)                     [a, b, c, d]
(%i2) listify (F ({a, b, c, d}));
(%o2)                    F({a, b, c, d})
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="lreduce"></a>
<a name="Item_003a-lreduce"></a>
</p><dl>
<dt><u>Function:</u> <b>lreduce</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>lreduce</tt> (<var>F</var>, <var>s</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>lreduce</tt> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1295"></a>
</dt>
<dd><p>二項関数 <var>F</var>を合成によって n項関数に拡張します。
ここで <var>s</var>はリストです。
</p>
<p><code>lreduce(<var>F</var>, <var>s</var>)</code>は
<code>F(... F(F(s_1, s_2), s_3), ... s_n)</code>を返します。
</p>
<p>オプション引数 <var>s_0</var>が存在する時、
結果は <code>lreduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>))</code>と同値です。
</p>
<p>関数 <var>F</var>は、最初の <i>leftmost</i>の要素に適用されます。
だから &quot;lreduce&quot;と名付けられています。
</p>
<p><code>rreduce</code>, <code>xreduce</code>, <code>tree_reduce</code>も参照してください。
</p>
<p>例:
</p>
<p>オプション引数なしの <code>lreduce</code>。
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3]);
(%o1)                     f(f(1, 2), 3)
(%i2) lreduce (f, [1, 2, 3, 4]);
(%o2)                  f(f(f(1, 2), 3), 4)
</pre>
<p>オプション引数ありの <code>lreduce</code>。
</p>
<pre class="example">(%i1) lreduce (f, [1, 2, 3], 4);
(%o1)                  f(f(f(4, 1), 2), 3)
</pre>
<p>組み込み二項演算子に適用された <code>lreduce</code>。
<code>/</code>は割り算演算子。
</p>
<pre class="example">(%i1) lreduce (&quot;^&quot;, args ({a, b, c, d}));
                               b c d
(%o1)                       ((a ) )
(%i2) lreduce (&quot;/&quot;, args ({a, b, c, d}));
                                a
(%o2)                         -----
                              b c d
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="makeset"></a>
<a name="Item_003a-makeset"></a>
</p><dl>
<dt><u>関数:</u> <b>makeset</b><i> (<var>expr</var>, <var>x</var>, <var>s</var>)</i>
<a name="IDX1296"></a>
</dt>
<dd><p>式 <var>expr</var>から生成された要素を持つ集合を返します。
ここで <var>x</var>は <var>expr</var>の中の変数のリストであり、
<var>s</var>はリストの集合かリストのリストです。
集合の要素それぞれを生成するために、
変数 <var>x</var>を並列に <var>s</var>の要素にバインドして
<var>expr</var>を評価します。
</p>
<p><var>s</var>の要素それぞれは
<var>x</var>と同じ長さを持たなければいけません。
変数 <var>x</var>のリストは添字の付かないシンボルのリストでなければいけません。
たとえシンボルが１つしかない場合でも、 <var>x</var>は１要素のリストでなければいけなく、
<var>s</var>の要素それぞれは１要素のリストでなければいけません。
</p>

<p><code>makelist</code>も参照してください。
</p>
<p>例:
</p>
<pre class="example">(%i1) makeset (i/j, [i, j], [[1, a], [2, b], [3, c], [4, d]]);
                           1  2  3  4
(%o1)                     {-, -, -, -}
                           a  b  c  d
(%i2) S : {x, y, z}$
(%i3) S3 : cartesian_product (S, S, S);
(%o3) {[x, x, x], [x, x, y], [x, x, z], [x, y, x], [x, y, y],
[x, y, z], [x, z, x], [x, z, y], [x, z, z], [y, x, x],
[y, x, y], [y, x, z], [y, y, x], [y, y, y], [y, y, z],
[y, z, x], [y, z, y], [y, z, z], [z, x, x], [z, x, y],
[z, x, z], [z, y, x], [z, y, y], [z, y, z], [z, z, x],
[z, z, y], [z, z, z]}
(%i4) makeset (i + j + k, [i, j, k], S3);
(%o4) {3 x, 3 y, y + 2 x, 2 y + x, 3 z, z + 2 x, z + y + x,
                                       z + 2 y, 2 z + x, 2 z + y}
(%i5) makeset (sin(x), [x], {[1], [2], [3]});
(%o5)               {sin(1), sin(2), sin(3)}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="moebius"></a>
<a name="Item_003a-moebius"></a>
</p><dl>
<dt><u>関数:</u> <b>moebius</b><i> (<var>n</var>)</i>
<a name="IDX1297"></a>
</dt>
<dd><p>メビウス関数を表します。
</p>
<p><var>n</var>が <em>k</em>個の異なる素数の積の時、
<code>moebius(<var>n</var>)</code>は <em>(-1)^k</em>に整理されます;
<em><var>n</var> = 1</em>の時 1に整理されます;
他の正の数すべてに対しては 0に整理されます。
</p>
<p><code>moebius</code>は等式、リスト、行列、集合上に分配されます。
</p>
<p>例:
</p>
<pre class="example">(%i1) moebius (1);
(%o1)                           1
(%i2) moebius (2 * 3 * 5);
(%o2)                          - 1
(%i3) moebius (11 * 17 * 29 * 31);
(%o3)                           1
(%i4) moebius (2^32);
(%o4)                           0
(%i5) moebius (n);
(%o5)                      moebius(n)
(%i6) moebius (n = 12);
(%o6)                    moebius(n) = 0
(%i7) moebius ([11, 11 * 13, 11 * 13 * 15]);
(%o7)                      [- 1, 1, 1]
(%i8) moebius (matrix ([11, 12], [13, 14]));
                           [ - 1  0 ]
(%o8)                      [        ]
                           [ - 1  1 ]
(%i9) moebius ({21, 22, 23, 24});
(%o9)                      {- 1, 0, 1}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Integers">Integers</a>
</div>
</p>
</dd></dl>

<p><a name="multinomial_005fcoeff"></a>
<a name="Item_003a-multinomial_005fcoeff"></a>
</p><dl>
<dt><u>関数:</u> <b>multinomial_coeff</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>multinomial_coeff</tt> (<var>a_1</var>, ..., <var>a_n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>multinomial_coeff</tt> ()</i>
<a name="IDX1298"></a>
</dt>
<dd><p>多項係数を返します。
</p>
<p><var>a_k</var>それぞれが非負の整数の時、
多項係数は、
<code><var>a_1</var> + ... + <var>a_n</var></code>個の別々のオブジェクトを
<em>k</em>番目の枠の中に <var>a_k</var>の要素を持つ <em>n</em>個の枠に置く方法の数を与えます。
</p>
<p>一般に、 <code>multinomial_coeff (<var>a_1</var>, ..., <var>a_n</var>)</code>は
<code>(<var>a_1</var> + ... + <var>a_n</var>)!/(<var>a_1</var>! ... <var>a_n</var>!)</code>と同値です。
</p>
<p><code>multinomial_coeff()</code> (引数なし)は 1に評価されます。
</p>
<p><code>minfactorial</code>は <code>multinomial_coeff</code>が返す値を整理することができます。
</p>
<p>例:
</p>
<pre class="example">(%i1) multinomial_coeff (1, 2, x);
                            (x + 3)!
(%o1)                       --------
                              2 x!
(%i2) minfactorial (%);
                     (x + 1) (x + 2) (x + 3)
(%o2)                -----------------------
                                2
(%i3) multinomial_coeff (-6, 2);
                             (- 4)!
(%o3)                       --------
                            2 (- 6)!
(%i4) minfactorial (%);
(%o4)                          10
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Integers">Integers</a>
</div>
</p>
</dd></dl>

<p><a name="num_005fdistinct_005fpartitions"></a>
<a name="Item_003a-num_005fdistinct_005fpartitions"></a>
</p><dl>
<dt><u>関数:</u> <b>num_distinct_partitions</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>num_distinct_partitions</tt> (<var>n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>num_distinct_partitions</tt> (<var>n</var>, list)</i>
<a name="IDX1299"></a>
</dt>
<dd><p><var>n</var>が非負の整数の時、
<var>n</var>の異なる整数分割の数を返します。
そうでないなら <code>num_distinct_partitions</code>は名詞形を返します。
</p>
<p><code>num_distinct_partitions(<var>n</var>, list)</code>は、
1, 2, 3, ..., <var>n</var>の異なる分割の数のリストを返します。
</p>
<p><var>n</var>の異なる分割は、
<em><var>n</var> = k_1 + ... + k_m</em>となるような
異なる正の整数 <em>k_1</em>, ..., <em>k_m</em>のリストです。
</p>
<p>例:
</p>
<pre class="example">(%i1) num_distinct_partitions (12);
(%o1)                          15
(%i2) num_distinct_partitions (12, list);
(%o2)      [1, 1, 1, 2, 2, 3, 4, 5, 6, 8, 10, 12, 15]
(%i3) num_distinct_partitions (n);
(%o3)              num_distinct_partitions(n)
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Integers">Integers</a>
</div>
</p>
</dd></dl>

<p><a name="num_005fpartitions"></a>
<a name="Item_003a-num_005fpartitions"></a>
</p><dl>
<dt><u>関数:</u> <b>num_partitions</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>num_partitions</tt> (<var>n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>num_partitions</tt> (<var>n</var>, list)</i>
<a name="IDX1300"></a>
</dt>
<dd><p><var>n</var>が非負の整数の時、
<var>n</var>の整数分割の数を返します。
そうでないなら <code>num_partitions</code>は名詞式を返します。
</p>
<p><code>num_partitions(<var>n</var>, list)</code>は、
1, 2, 3, ..., <var>n</var>の整数分割の数のリストを返します。
</p>
<p>非負の整数 <var>n</var>に対して、
<code>num_partitions(<var>n</var>)</code>は
<code>cardinality(integer_partitions(<var>n</var>))</code>と等しいです;
しかしながら、 <code>num_partitions</code>は
分割の集合を実際には構成しないのではるかに速いです。
</p>
<p>例:
</p>
<pre class="example">(%i1) num_partitions (5) = cardinality (integer_partitions (5));
(%o1)                         7 = 7
(%i2) num_partitions (8, list);
(%o2)            [1, 1, 2, 3, 5, 7, 11, 15, 22]
(%i3) num_partitions (n);
(%o3)                   num_partitions(n)
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Integers">Integers</a>
</div>
</p>
</dd></dl>



<p><a name="partition_005fset"></a>
<a name="Item_003a-partition_005fset"></a>
</p><dl>
<dt><u>関数:</u> <b>partition_set</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX1301"></a>
</dt>
<dd><p>集合 <var>a</var>を述語論理 <var>f</var>に従って分割します。
</p>
<p><code>partition_set</code>は２つの集合のリストを返します。
最初の集合は
<var>f</var>が <code>false</code>に評価される
<var>a</var>の要素から成り、
二番目は <var>a</var>の他の要素すべてから成ります。
<code>partition_set</code>は
<code>is</code>を <var>f</var>の戻り値に適用しません。
</p>
<p>もし <var>a</var>が集合リテラルなら
<code>partition_set</code>は文句を言います。
</p>
<p><code>subset</code>も参照してください。
</p>
<p>例:
</p>
<pre class="example">(%i1) partition_set ({2, 7, 1, 8, 2, 8}, evenp);
(%o1)                   [{1, 7}, {2, 8}]
(%i2) partition_set ({x, rat(y), rat(y) + z, 1},
                     lambda ([x], ratp(x)));
(%o2)/R/              [{1, x}, {y, y + z}]
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="permutations"></a>
<a name="Item_003a-permutations"></a>
</p><dl>
<dt><u>関数:</u> <b>permutations</b><i> (<var>a</var>)</i>
<a name="IDX1302"></a>
</dt>
<dd><p>リストまたは集合 <var>a</var>の要素の異なる順列すべての集合を返します。
順列それぞれは集合でなくリストです。
</p>
<p><var>a</var>がリストの時、
<var>a</var>の重複した要素が順列の中に含まれます。
</p>
<p>もし <var>a</var>がリストリテラルや集合リテラルでないなら、
<code>permutations</code>は文句を言います。
</p>
<p><code>random_permutation</code>も参照してください。
</p>
<p>例:
</p>
<pre class="example">(%i1) permutations ([a, a]);
(%o1)                       {[a, a]}
(%i2) permutations ([a, a, b]);
(%o2)           {[a, a, b], [a, b, a], [b, a, a]}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="powerset"></a>
<a name="Item_003a-powerset"></a>
</p><dl>
<dt><u>関数:</u> <b>powerset</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>powerset</tt> (<var>a</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>powerset</tt> (<var>a</var>, <var>n</var>)</i>
<a name="IDX1303"></a>
</dt>
<dd><p><var>a</var>の部分集合すべての集合、またはその集合の部分集合を返します。
</p>
<p><code>powerset(<var>a</var>)</code>は
集合 <var>a</var>の部分集合すべての集合を返します。
<code>powerset(<var>a</var>)</code>は<code>2^cardinality(<var>a</var>)</code>個の要素を持ちます。
</p>
<p><code>powerset(<var>a</var>, <var>n</var>)</code>は、
濃度 <var>n</var>を持つ <var>a</var>の部分集合すべての集合を返します。
</p>
<p>もし <var>a</var>が集合リテラルでないか <var>n</var>が非負の整数でないなら、
<code>powerset</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) powerset ({a, b, c});
(%o1) {{}, {a}, {a, b}, {a, b, c}, {a, c}, {b}, {b, c}, {c}}
(%i2) powerset ({w, x, y, z}, 4);
(%o2)                    {{w, x, y, z}}
(%i3) powerset ({w, x, y, z}, 3);
(%o3)     {{w, x, y}, {w, x, z}, {w, y, z}, {x, y, z}}
(%i4) powerset ({w, x, y, z}, 2);
(%o4)   {{w, x}, {w, y}, {w, z}, {x, y}, {x, z}, {y, z}}
(%i5) powerset ({w, x, y, z}, 1);
(%o5)                 {{w}, {x}, {y}, {z}}
(%i6) powerset ({w, x, y, z}, 0);
(%o6)                         {{}}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="Item_003a-random_005fpermutation"></a>
</p><dl>
<dt><u>関数:</u> <b>random_permutation</b><i> (<var>a</var>)</i>
<a name="IDX1304"></a>
</dt>
<dd><p>クヌースのシャッフルアルゴリズムで構成されるような、
集合またはリスト <var>a</var>のランダムな順列を返します。
</p>
<p>戻り値は、たとえ要素すべてが偶然同じでも引数とは別の新しいリストです。
しかしながら引数の要素はコピーされません。
</p>
<p>例:
</p>
<pre class="example">(%i1) random_permutation ([a, b, c, 1, 2, 3]);
(%o1)                  [c, 1, 2, 3, a, b]
(%i2) random_permutation ([a, b, c, 1, 2, 3]);
(%o2)                  [b, 3, 1, c, a, 2]
(%i3) random_permutation ({x + 1, y + 2, z + 3});
(%o3)                 [y + 2, z + 3, x + 1]
(%i4) random_permutation ({x + 1, y + 2, z + 3});
(%o4)                 [x + 1, y + 2, z + 3]
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="rreduce"></a>
<a name="Item_003a-rreduce"></a>
</p><dl>
<dt><u>関数:</u> <b>rreduce</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>rreduce</tt> (<var>F</var>, <var>s</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>rreduce</tt> (<var>F</var>, <var>s</var>, <var>s_{n + 1}</var>)</i>
<a name="IDX1305"></a>
</dt>
<dd><p>合成によって二項関数 <var>F</var>を n項関数に拡張します。
ここで <var>s</var>はリストです。
</p>
<p><code>rreduce(<var>F</var>, <var>s</var>)</code>は
<code>F(s_1, ... F(s_{n - 2}, F(s_{n - 1}, s_n)))</code>を返します。
オプション引数 <var>s_{n + 1}</var>が存在する時、
結果は <code>rreduce(<var>F</var>, endcons(<var>s_{n + 1}</var>, <var>s</var>))</code>
と同値です。
</p>
<p>関数 <var>F</var>は、最初 <i>rightmost</i>のリスト要素に適用されます。
だから名前が &quot;rreduce&quot;です。
</p>
<p><code>lreduce</code>, <code>tree_reduce</code>, <code>xreduce</code>も参照してください。
</p>
<p>例:
</p>
<p>オプション引数なしの <code>rreduce</code>。
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3]);
(%o1)                     f(1, f(2, 3))
(%i2) rreduce (f, [1, 2, 3, 4]);
(%o2)                  f(1, f(2, f(3, 4)))
</pre>
<p>オプション引数ありの <code>rreduce</code>。
</p>
<pre class="example">(%i1) rreduce (f, [1, 2, 3], 4);
(%o1)                  f(1, f(2, f(3, 4)))
</pre>
<p>組み込み二項演算子に適用された <code>rreduce</code>。
<code>/</code>は割り算演算子。
</p>
<pre class="example">(%i1) rreduce (&quot;^&quot;, args ({a, b, c, d}));
                                 d
                                c
                               b
(%o1)                         a
(%i2) rreduce (&quot;/&quot;, args ({a, b, c, d}));
                               a c
(%o2)                          ---
                               b d
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="setdifference"></a>
<a name="Item_003a-setdifference"></a>
</p><dl>
<dt><u>関数:</u> <b>setdifference</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1306"></a>
</dt>
<dd><p>集合 <var>a</var>の中にあり、集合 <var>b</var>にない要素を含む集合を返します。
</p>
<p>もし <var>a</var>か <var>b</var>が集合リテラルでないなら、
<code>setdifference</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) S_1 : {a, b, c, x, y, z};
(%o1)                  {a, b, c, x, y, z}
(%i2) S_2 : {aa, bb, c, x, y, zz};
(%o2)                 {aa, bb, c, x, y, zz}
(%i3) setdifference (S_1, S_2);
(%o3)                       {a, b, z}
(%i4) setdifference (S_2, S_1);
(%o4)                     {aa, bb, zz}
(%i5) setdifference (S_1, S_1);
(%o5)                          {}
(%i6) setdifference (S_1, {});
(%o6)                  {a, b, c, x, y, z}
(%i7) setdifference ({}, S_1);
(%o7)                          {}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="setequalp"></a>
<a name="Item_003a-setequalp"></a>
</p><dl>
<dt><u>関数:</u> <b>setequalp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1307"></a>
</dt>
<dd><p>集合 <var>a</var>と <var>b</var>が同じ要素数を持ち、
<code>listify</code>が決定した順序で考えて
<var>a</var>の要素の中の <code>x</code>と
<var>b</var>の要素の中の <code>y</code>に対して
<code>is(<var>x</var> = <var>y</var>)</code>が<code>true</code>なら、
<code>true</code>を返します。
そうでないなら <code>setequalp</code>は <code>false</code>を返します。
</p>
<p>例:
</p>
<pre class="example">(%i1) setequalp ({1, 2, 3}, {1, 2, 3});
(%o1)                         true
(%i2) setequalp ({a, b, c}, {1, 2, 3});
(%o2)                         false
(%i3) setequalp ({x^2 - y^2}, {(x + y) * (x - y)});
(%o3)                         false
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Predicate-functions">Predicate functions</a>
</div>
</p>
</dd></dl>

<p><a name="setify"></a>
<a name="Item_003a-setify"></a>
</p><dl>
<dt><u>関数:</u> <b>setify</b><i> (<var>a</var>)</i>
<a name="IDX1308"></a>
</dt>
<dd><p>リスト <var>a</var>の要素から集合を構成します。
リスト <var>a</var>の重複した要素は削除され、
要素は述語論理 <code>orderlessp</code>に従って並び替えられます。
</p>
<p>もし <var>a</var>が集合リテラルでないなら、
<code>setify</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) setify ([1, 2, 3, a, b, c]);
(%o1)                  {1, 2, 3, a, b, c}
(%i2) setify ([a, b, c, a, b, c]);
(%o2)                       {a, b, c}
(%i3) setify ([7, 13, 11, 1, 3, 9, 5]);
(%o3)                {1, 3, 5, 7, 9, 11, 13}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="setp"></a>
<a name="Item_003a-setp"></a>
</p><dl>
<dt><u>関数:</u> <b>setp</b><i> (<var>a</var>)</i>
<a name="IDX1309"></a>
</dt>
<dd><p><var>a</var>が Maximaの集合の時だけ <code>true</code>を返します。
</p>
<p><code>setp</code>は、
整理された集合はもちろん、未整理の集合(すなわち、冗長な元を持つ集合)に対して、
<code>true</code>を返します。
</p>
<p><code>setp</code>は Maxima関数
<code>setp(a) := not atom(a) and op(a) = 'set</code>
と同値です。
</p>
<p>例:
</p>
<pre class="example">(%i1) simp : false;
(%o1)                         false
(%i2) {a, a, a};
(%o2)                       {a, a, a}
(%i3) setp (%);
(%o3)                         true
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Predicate-functions">Predicate functions</a>
</div>
</p>
</dd></dl>

<p><a name="set_005fpartitions"></a>
<a name="Item_003a-set_005fpartitions"></a>
</p><dl>
<dt><u>関数:</u> <b>set_partitions</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>set_partitions</tt> (<var>a</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>set_partitions</tt> (<var>a</var>, <var>n</var>)</i>
<a name="IDX1310"></a>
</dt>
<dd><p><var>a</var>の分割すべての集合、またはその集合の部分集合を返します。
</p>
<p><code>set_partitions(<var>a</var>, <var>n</var>)</code>は
<var>n</var>個の空でない交わらない部分集合への
<var>a</var>の分解すべての集合を返します。
</p>
<p><code>set_partitions(<var>a</var>)</code>は分割すべての集合を返します。
</p>
<p><code>stirling2</code>は集合の分割の集合の濃度を返します。
</p>
<p>集合の集合<em>P</em>は
</p>
<ol>
<li>
<em>P</em>の要素それぞれが空でない集合
</li><li>
<em>P</em>の別の要素が交わらない
</li><li>
<em>P</em>の要素の和集合が <em>S</em>に等しい
</li></ol>
<p>時、
集合 <em>S</em>の分割です。
</p>
<p>例:
</p>
<p>条件 1と 2が空ゆえに真なので、空集合はそれ自身の分割です。
</p>
<pre class="example">(%i1) set_partitions ({});
(%o1)                         {{}}
</pre>
<p>集合の分割の集合の濃度は <code>stirling2</code>を使って見つけられます。
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$
(%i3) cardinality(p) = stirling2 (6, 3);
(%o3)                        90 = 90
</pre>
<p><code>p</code>の要素それぞれは
<var>n</var> = 3個の要素を持たなければいけません;
チェックしましょう。
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$
(%i3) map (cardinality, p);
(%o3)                          {3}
</pre>
<p>最後に、
<code>p</code>の要素それぞれに対して、
元の和集合は <code>s</code>に等しくなければいけません;
チェックしましょう。
</p>
<pre class="example">(%i1) s: {0, 1, 2, 3, 4, 5}$
(%i2) p: set_partitions (s, 3)$
(%i3) map (lambda ([x], apply (union, listify (x))), p);
(%o3)                 {{0, 1, 2, 3, 4, 5}}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="some"></a>
<a name="Item_003a-some"></a>
</p><dl>
<dt><u>関数:</u> <b>some</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>some</tt> (<var>f</var>, <var>a</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>some</tt> (<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</i>
<a name="IDX1311"></a>
</dt>
<dd><p>もし与えられた引数のうち１つ以上で述語論理 <var>f</var>が <code>true</code>なら
<code>true</code>を返します。
</p>
<p>二番目の引数として集合１つが与えられたとして、
もし
<var>s</var>の中の１つ以上の <var>a_i</var>に対して
<code>is(<var>f</var>(<var>a_i</var>))</code>が <code>true</code>を返すなら、
<code>some(<var>f</var>, <var>s</var>)</code>は <code>true</code>を返します。
<code>some</code>は <var>s</var>の中の <var>a_i</var>すべてに対して
<var>f</var>を評価するかどうかわかりません。
集合は順序がないので、
<code>some</code>は任意の順序で <code><var>f</var>(<var>a_i</var>)</code>評価するかもしれません。
</p>
<p>引数として 1つ以上のリストが与えられたとして、
もし <var>L_1</var>, ..., <var>L_n</var>それぞれの中の１つ以上の <var>x_1</var>, ..., <var>x_n</var>で
<code>is(<var>f</var>(<var>x_1</var>, ..., <var>x_n</var>))</code>が <code>true</code>を返すなら、
<code>some(<var>f</var>, <var>L_1</var>, ..., <var>L_n</var>)</code>は <code>true</code>を返します。
<code>some</code>はいくつかの組み合わせ <var>x_1</var>, ..., <var>x_n</var>に対して
<var>f</var>を評価するかどうかわかりません。
<code>some</code>はインデックスを増加する順序でリストを評価します。
</p>
<p>引数として空集合 <code>{}</code>か空のリスト <code>[]</code>が与えられる場合、
<code>some</code>は <code>false</code>を返します。
</p>
<p>グローバルフラグ <code>maperror</code>が <code>true</code>の時、
すべてのリスト <var>L_1</var>, ..., <var>L_n</var>は同じ長さを持たなければいけません。
<code>maperror</code>が <code>false</code>の時、
リスト引数は最短のリストの長さに効果的に切り詰められます。
</p>
<p>(<code>is</code>を介して) <code>true</code>か <code>false</code>以外の何かに評価される
述語論理 <var>f</var>の戻り値は、
グローバルフラグ <code>prederror</code>が決定します。
<code>prederror</code>が <code>true</code>の時、
そんな値は <code>false</code>として扱われます。
<code>prederror</code>が <code>false</code>の時、
そんな値は <code>unknown</code>として扱われます。
</p>
<p>例:
</p>
<p>集合１つに適用された <code>some</code>。
述語論理は引数１つの関数です。
</p>
<pre class="example">(%i1) some (integerp, {1, 2, 3, 4, 5, 6});
(%o1)                         true
(%i2) some (atom, {1, 2, sin(3), 4, 5 + y, 6});
(%o2)                         true
</pre>
<p>２つのリストに適用された <code>some</code>。
述語論理は引数２つの関数です。
</p>
<pre class="example">(%i1) some (&quot;=&quot;, [a, b, c], [a, b, c]);
(%o1)                         true
(%i2) some (&quot;#&quot;, [a, b, c], [a, b, c]);
(%o2)                         false
</pre>
<p><code>true</code>か <code>false</code>以外の何かに評価される述語論理
<var>f</var>の戻り値は、グローバルフラグ <code>prederror</code>が決定します。
</p>
<pre class="example">(%i1) prederror : false;
(%o1)                         false
(%i2) map (lambda ([a, b], is (a &lt; b)), [x, y, z],
           [x^2, y^2, z^2]);
(%o2)              [unknown, unknown, unknown]
(%i3) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o3)                        unknown
(%i4) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o4)                         true
(%i5) prederror : true;
(%o5)                         true
(%i6) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z^2]);
(%o6)                         false
(%i7) some (&quot;&lt;&quot;, [x, y, z], [x^2, y^2, z + 1]);
(%o7)                         true
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="stirling1"></a>
<a name="Item_003a-stirling1"></a>
</p><dl>
<dt><u>関数:</u> <b>stirling1</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1312"></a>
</dt>
<dd><p>第一種のスターリング数を表します。
</p>
<p><var>n</var>と <var>m</var>が非負の整数の時、
<code>stirling1 (<var>n</var>, <var>m</var>)</code>の大きさは
<var>m</var>個の巡回置換を持つ <var>n</var>個の元を持つ集合の順列の数です。
</p>
<p><code>stirling1</code>は整理関数です。
Maximaは以下の恒等式を知っています:
</p>
<ol>
<li>
<em>stirling1(1,k) = kron_delta(1,k), k &gt;= 0</em>,(see <a href="http://dlmf.nist.gov/26.8.E2">http://dlmf.nist.gov/26.8.E2</a>)
</li><li>
<em>stirling1(n,n) = 1, n &gt;= 0</em> (see <a href="http://dlmf.nist.gov/26.8.E1">http://dlmf.nist.gov/26.8.E1</a>)
</li><li>
<em>stirling1(n,n-1) = -binomial(n,2), n &gt;= 1</em>, (see <a href="http://dlmf.nist.gov/26.8.E16">http://dlmf.nist.gov/26.8.E16</a>)
</li><li>
<em>stirling1(n,0) = kron_delta(n,0), n &gt;=0</em>  (see <a href="http://dlmf.nist.gov/26.8.E14">http://dlmf.nist.gov/26.8.E14</a> and
   <a href="http://dlmf.nist.gov/26.8.E1">http://dlmf.nist.gov/26.8.E1</a>)
</li><li>
<em>stirling1(n,1) =(-1)^(n-1) (n-1)!, n &gt;= 1</em> (see <a href="http://dlmf.nist.gov/26.8.E14">http://dlmf.nist.gov/26.8.E14</a>)
</li><li>
<em>stirling1(n,k) = 0, n &gt;= 0</em> and <em>k &gt; n</em>.
</li></ol>

<p>これらの恒等式は
引数が、整数リテラルまたは整数と宣言されたシンボルで、かつ、
最初の引数が非負の時、
適用されます。
<code>stirling1</code>は、非整数引数に対して整理しません。
</p>

<p>例:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling1 (n, n);
(%o3)                           1
</pre>

<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Integers">Integers</a>
</div>
</p>
</dd></dl>

<p><a name="stirling2"></a>
<a name="Item_003a-stirling2"></a>
</p><dl>
<dt><u>関数:</u> <b>stirling2</b><i> (<var>n</var>, <var>m</var>)</i>
<a name="IDX1313"></a>
</dt>
<dd><p>第二種スターリング数を表します。
</p>
<p><var>n</var>と <var>m</var>が非負の整数の時、
<code>stirling2 (<var>n</var>, <var>m</var>)</code>は、
濃度 <var>n</var>の集合が <var>m</var>個のばらばらの部分集合に分割できる方法の数です。
</p>
<p><code>stirling2</code>は整理関数です。
Maximaは以下の恒等式を知っています。
</p>
<ol>
<li> <em>stirling2(n,0) = 1, n &gt;= 1</em> (see <a href="http://dlmf.nist.gov/26.8.E17">http://dlmf.nist.gov/26.8.E17</a> and stirling2(0,0) = 1)
</li><li> <em>stirling2(n,n) = 1, n &gt;= 0</em>, (see <a href="http://dlmf.nist.gov/26.8.E4">http://dlmf.nist.gov/26.8.E4</a>)
</li><li> <em>stirling2(n,1) = 1, n &gt;= 1</em>, (see <a href="http://dlmf.nist.gov/26.8.E17">http://dlmf.nist.gov/26.8.E17</a> and stirling2(0,1) = 0)
</li><li> <em>stirling2(n,2) = 2^(n-1) -1, n &gt;= 1</em>, (see <a href="http://dlmf.nist.gov/26.8.E17">http://dlmf.nist.gov/26.8.E17</a>)
</li><li> <em>stirling2(n,n-1) = binomial(n,2), n&gt;= 1</em> (see <a href="http://dlmf.nist.gov/26.8.E16">http://dlmf.nist.gov/26.8.E16</a>)
</li><li> <em>stirling2(n,k) = 0, n &gt;= 0</em> and <em>k &gt; n</em>.
</li></ol>

<p>引数が整数リテラルまたは整数と宣言されたシンボルで、かつ、最初の引数が非負の時、
これらの恒等式が適用されます。
<code>stirling2</code>は非整数引数に対して整理されません。
</p>
<p>例:
</p>
<pre class="example">(%i1) declare (n, integer)$
(%i2) assume (n &gt;= 0)$
(%i3) stirling2 (n, n);
(%o3)                           1
</pre>
<p><code>stirling2</code>は非整数引数に対して整理されません。
</p>
<pre class="example">(%i1) stirling2 (%pi, %pi);
(%o1)                  stirling2(%pi, %pi)
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Integers">Integers</a>
</div>
</p>
</dd></dl>

<p><a name="subset"></a>
<a name="Item_003a-subset"></a>
</p><dl>
<dt><u>関数:</u> <b>subset</b><i> (<var>a</var>, <var>f</var>)</i>
<a name="IDX1314"></a>
</dt>
<dd><p>述語論理 <var>f</var>を満たす集合 <var>a</var>の部分集合を返します。
</p>
<p><code>subset</code>は、
<var>a</var>の要素のうち、<var>f</var>が <code>false</code>以外の何かを返す要素の集合を返します。
<code>subset</code>は <code>is</code>を <var>f</var>の戻り値に適用しません。
</p>
<p>もし <var>a</var>が集合リテラルでないなら <code>subset</code>は文句を言います。
</p>
<p><code>partition_set</code>も参照してください。
</p>
<p>例:
</p>
<pre class="example">(%i1) subset ({1, 2, x, x + y, z, x + y + z}, atom);
(%o1)                     {1, 2, x, z}
(%i2) subset ({1, 2, 7, 8, 9, 14}, evenp);
(%o2)                      {2, 8, 14}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="subsetp"></a>
<a name="Item_003a-subsetp"></a>
</p><dl>
<dt><u>関数:</u> <b>subsetp</b><i> (<var>a</var>, <var>b</var>)</i>
<a name="IDX1315"></a>
</dt>
<dd><p>集合 <var>a</var>が <var>b</var>の部分集合の時だけ <code>true</code>を返します。
</p>
<p>もし <var>a</var>か <var>b</var>のいずれかが集合リテラルでないなら、
<code>subsetp</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) subsetp ({1, 2, 3}, {a, 1, b, 2, c, 3});
(%o1)                         true
(%i2) subsetp ({a, 1, b, 2, c, 3}, {1, 2, 3});
(%o2)                         false
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Predicate-functions">Predicate functions</a>
</div>
</p>
</dd></dl>

<p><a name="symmdifference"></a>
<a name="Item_003a-symmdifference"></a>
</p><dl>
<dt><u>関数:</u> <b>symmdifference</b><i> (<var>a_1</var>, &hellip;, <var>a_n</var>)</i>
<a name="IDX1316"></a>
</dt>
<dd><p>集合 <var>a_1</var>, &hellip;, <var>a_n</var>の対称差を返します。
</p>
<p>２つの引数が与えられたとして、
<code>symmdifference ( <var>a</var>, <var>b</var>)</code>は
<code>union (setdifference ( <var>a</var>, <var>b</var>), setdifference (<var>b</var>, <var>a</var>))</code>と同じです。
</p>
<p>もし引数が集合リテラルでないなら、
<code>symmdifference</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) S_1 : {a, b, c};
(%o1)                       {a, b, c}
(%i2) S_2 : {1, b, c};
(%o2)                       {1, b, c}
(%i3) S_3 : {a, b, z};
(%o3)                       {a, b, z}
(%i4) symmdifference ();
(%o4)                          {}
(%i5) symmdifference (S_1);
(%o5)                       {a, b, c}
(%i6) symmdifference (S_1, S_2);
(%o6)                        {1, a}
(%i7) symmdifference (S_1, S_2, S_3);
(%o7)                        {1, b, z}
(%i8) symmdifference ({}, S_1, S_2, S_3);
(%o8)                        {1,b, z}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="tree_005freduce"></a>
<a name="Item_003a-tree_005freduce"></a>
</p><dl>
<dt><u>関数:</u> <b>tree_reduce</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>tree_reduce</tt> (<var>F</var>, <var>s</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>tree_reduce</tt> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1317"></a>
</dt>
<dd><p>合成によって二項関数 <var>F</var>を n項関数に拡張します。
ここで <var>s</var>は集合かリストです。
</p>
<p><code>tree_reduce</code>は以下と同値です:
新しいリスト
<code>[<var>F</var>(<var>s_1</var>, <var>s_2</var>), <var>F</var>(<var>s_3</var>, <var>s_4</var>), ...]</code>を形成するために
<var>F</var>を要素の連続する対に適用します。
もし奇数個の要素があるなら、
最後の要素は変化なしに通過させます。
そして、リストが１つの要素になるまで繰り返します。１つの要素になった時、それが戻り値です。
</p>
<p>オプションの引数 <var>s_0</var>がある時，
結果は <code>tree_reduce(<var>F</var>, cons(<var>s_0</var>, <var>s</var>))</code>と同値です。
</p>
<p>浮動小数点数の足し算に関して、
<code>tree_reduce</code>は <code>rreduce</code>や
<code>lreduce</code>よりも小さな丸め誤差を持つ和を返します。
</p>
<p><var>s</var>の要素と部分的な結果は
最小深度の二項木の中に配列されます。
だから名前が &quot;tree_reduce&quot;です。
</p>
<p>例:
</p>
<p>偶数個の要素を持つリストに適用された <code>tree_reduce</code>。
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d]);
(%o1)                  f(f(a, b), f(c, d))
</pre>
<p>奇数個の要素を持つリストに適用された <code>tree_reduce</code>。
</p>
<pre class="example">(%i1) tree_reduce (f, [a, b, c, d, e]);
(%o1)               f(f(f(a, b), f(c, d)), e)
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="union"></a>
<a name="Item_003a-union"></a>
</p><dl>
<dt><u>関数:</u> <b>union</b><i> (<var>a_1</var>, ..., <var>a_n</var>)</i>
<a name="IDX1318"></a>
</dt>
<dd><p>集合 <var>a_1</var>から <var>a_n</var>の和集合を返します。
</p>
<p><code>union()</code> (引数なし)は空集合を返します。
</p>
<p>もし引数が集合リテラルでないなら、<code>union</code>は文句を言います。
</p>
<p>例:
</p>
<pre class="example">(%i1) S_1 : {a, b, c + d, %e};
(%o1)                   {%e, a, b, d + c}
(%i2) S_2 : {%pi, %i, %e, c + d};
(%o2)                 {%e, %i, %pi, d + c}
(%i3) S_3 : {17, 29, 1729, %pi, %i};
(%o3)                {17, 29, 1729, %i, %pi}
(%i4) union ();
(%o4)                          {}
(%i5) union (S_1);
(%o5)                   {%e, a, b, d + c}
(%i6) union (S_1, S_2);
(%o6)              {%e, %i, %pi, a, b, d + c}
(%i7) union (S_1, S_2, S_3);
(%o7)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
(%i8) union ({}, S_1, S_2, S_3);
(%o8)       {17, 29, 1729, %e, %i, %pi, a, b, d + c}
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a>
</div>
</p>
</dd></dl>

<p><a name="xreduce"></a>
<a name="Item_003a-xreduce"></a>
</p><dl>
<dt><u>関数:</u> <b>xreduce</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>xreduce</tt> (<var>F</var>, <var>s</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>xreduce</tt> (<var>F</var>, <var>s</var>, <var>s_0</var>)</i>
<a name="IDX1319"></a>
</dt>
<dd><p>合成によって関数 <var>F</var>を n項関数に拡張します。
または、もし <var>F</var>が既に n項関数なら <var>F</var>を <var>s</var>に適用します。
<var>F</var>が n項関数でない時、
<code>xreduce</code>は <code>lreduce</code>と同じです。
引数 <var>s</var>はリストです。
</p>
<p>n項関数として知られている関数は、
足し算 <code>+</code>, 掛け算 <code>*</code>, <code>and</code>, <code>or</code>, <code>max</code>,
<code>min</code>, <code>append</code>を含みます。
関数は、
<code>declare(<var>F</var>, nary)</code>によっても n項と宣言されるかもしれません。
これらの関数に対して、
<code>xreduce</code>は <code>rreduce</code>や <code>lreduce</code>よりも速いことが期待されます。
</p>
<p>オプション引数 <var>s_0</var>がある時、
結果は <code>xreduce(<var>s</var>, cons(<var>s_0</var>, <var>s</var>))</code>と同値です。
</p>
<p>浮動小数点の足し算は、厳密には結合的ではありません;
そうはそうかもしれませんが、
<var>s</var>が浮動小数点を含む時、
<code>xreduce</code>は Maximaの n項足し算を適用します。
</p>
<p>例:
</p>
<p>n項と知られている関数に適用された <code>xreduce</code>。
<code>F</code>は引数すべてで一度コールされます。
</p>
<pre class="example">(%i1) declare (F, nary);
(%o1)                         done
(%i2) F ([L]) := L;
(%o2)                      F([L]) := L
(%i3) xreduce (F, [a, b, c, d, e]);
(%o3)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
</pre>
<p>n項とわかっていない関数に適用された <code>xreduce</code>。
<code>G</code>は毎回２つの引数で複数回コールされます。
</p>
<pre class="example">(%i1) G ([L]) := L;
(%o1)                      G([L]) := L
(%i2) xreduce (G, [a, b, c, d, e]);
(%o2)         [[[[[(&quot;[&quot;, simp), a], b], c], d], e]
(%i3) lreduce (G, [a, b, c, d, e]);
(%o3)                 [[[[a, b], c], d], e]
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Sets">Sets</a> &middot;
<a href="maxima_100.html#Category_003a-Lists">Lists</a>
</div>
</p>
</dd></dl>

<p><a name="Item_003a-Function-Definition"></a>
</p><hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_36.html#SEC194" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  この文書は<em>市川 雄二</em>によって<em>5月, 20 2015</em>に<a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>を用いて生成されました。
 </font>
 <br>

</p>
</body>
</html>
