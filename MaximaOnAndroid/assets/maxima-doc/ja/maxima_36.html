<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on 5月, 20 2015 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima 5.36.1 Manual: 36. Function Definition</title>

<meta name="description" content="Maxima 5.36.1 Manual: 36. Function Definition">
<meta name="keywords" content="Maxima 5.36.1 Manual: 36. Function Definition">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="figures/favicon.ico"/>

<script type="text/javascript"><!--

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-510249-14']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

--></script>
</head>

<body lang="ja" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="Function-Definition"></a>
<a name="SEC194"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_35.html#SEC193" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC195" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_35.html#SEC187" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 36. Function Definition </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC195">36.1 Introduction to Function Definition</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC196">36.2 Function</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC199">36.3 Macros</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top"><a href="#SEC200">36.4 Functions and Variables for Function Definition</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p><a name="Item_003a-Introduction-to-Function-Definition"></a>
</p><hr size="6">
<a name="Introduction-to-Function-Definition"></a>
<a name="SEC195"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC194" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC194" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.1 Introduction to Function Definition </h2>

<p><a name="Item_003a-Function"></a>
</p><hr size="6">
<a name="Function"></a>
<a name="SEC196"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC195" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC197" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC194" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.2 Function </h2>

<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a> &middot;
<a href="maxima_100.html#Category_003a-Programming">Programming</a>
</div>
</p>
<hr size="6">
<a name="SEC197"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC196" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC198" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 36.2.1 Ordinary functions </h3>

<p>Maximaの中で関数を定義するためには <code>:=</code>演算子を使います。
例えば、
</p>
<pre class="example">f(x) := sin(x)
</pre>

<p>は関数 <code>f</code>を定義します。
匿名関数も <code>lambda</code>を使って生成することができます。
例えば、
</p>
<pre class="example">f(i,j) := block ([], ...);
</pre>

<p>なる <code>f</code>の代わりに
</p>
<pre class="example">lambda ([i, j], ...)
</pre>

<p>を使うことができます。
</p>
<pre class="example">map (lambda ([i], i+1), l)
</pre>

<p>は項目それぞれに1を加算したリストを返します。
</p>
<p>余分な引数のリストに割り当てられる最後の引数を持つことで、引数が可変の関数も定義できます:
</p>
<p>(訳注:
最後の引数変数を<code>[]</code>でくくると、残りの引数のリストがその引数変数に割り当てられます。)
</p>
<pre class="example">(%i1) f ([u]) := u;
(%o1)                      f([u]) := u
(%i2) f (1, 2, 3, 4);
(%o2)                     [1, 2, 3, 4]
(%i3) f (a, b, [u]) := [a, b, u];
(%o3)               f(a, b, [u]) := [a, b, u]
(%i4) f (1, 2, 3, 4, 5, 6);
(%o4)                 [1, 2, [3, 4, 5, 6]]
</pre>
<p>関数の右辺は式です。
従って、もし一連の式が欲しいなら、
</p>
<pre class="example">f(x) := (expr1, expr2, ...., exprn);
</pre>
<p>とします。 <var>exprn</var>の値が関数が返すものになります。
</p>
<p>もし関数内部のある式から <code>return</code>したいなら、
<code>block</code>と <code>return</code>を使わなければいけません。
</p>
<pre class="example">block ([], expr1, ..., if (a &gt; 10) then return(a), ..., exprn)
</pre>
<p>はそれ自身式で、関数定義の右辺にとって代わることができます。
この際、最後の式よりも早く returnが起こるかもしれません。
</p>
<p>ブロックの中の最初の <code>[]</code>は、
<code>[a: 3, b, c: []]</code>のように変数と変数割り当てのリストを含むかもしれません。
<code>[a: 3, b, c: []]</code>とすると、
<code>block</code>内部や <code>block</code>内部からコールされた関数内部でコードが実行される限り、
３つの変数 <code>a</code>,<code>b</code>,<code>c</code>がグローバル値ではなく
特別な値を参照するようになります。
変数がブロックの開始から抜ける時間まで続くので、これは <i>動的</i>バインドと呼ばれます。
一旦 <code>block</code>から戻るかそこから出ると、(もし存在するなら）変数の古い値に戻されます。
この方法で変数を保護することは確かによい考えです。
ブロック変数に関する割り当ては並列に行われることに注意してください。
これは、もし先に <code>c: a</code>を使ったら、
ブロックにちょうど入った時、<code>c</code>の値は
<code>a</code>がバインドされる前の<code>a</code>の値であることを意味します。
例えば、
</p>
<pre class="example">block ([a: a], expr1, ... a: a+3, ..., exprn)
</pre>
<p>のような何かを実行することは、
<code>a</code>の外部の値を変更されないよう保護しますが、その値がなんだったかアクセス可能にします。
割り当ての右辺はバインドが起こる前に入る文脈の中で評価されます。
ただ <code>block ([x], ...)</code>を使うことは、ちょうどまるで新しい
Maximaセッションに入ったかのように <code>x</code>がそれ自身を値として持つようにします。
</p>
<p>関数の実際の引数は、ブロックの変数と厳密に同じ方法で扱われます。
例えば、
</p>
<pre class="example">f(x) := (expr1, ..., exprn);
</pre>
<p>と
</p>
<pre class="example">f(1);
</pre>
<p>では、式の評価に関して、まるで
</p>
<pre class="example">block ([x: 1], expr1, ..., exprn)
</pre>
<p>を実行したかのような類似の文脈を持ちます。
</p>
<p>定義の右辺がランタイムで計算される時、
関数内部では <code>define</code>とたぶん <code>buildq</code>を使うことが役に立ちます。
</p>
<hr size="6">
<a name="SEC198"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC197" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC199" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC196" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h3 class="subsection"> 36.2.2 Array functions </h3>

<p>配列関数は、与えられた引数で初めてコールされた時、関数値を記憶し、
同じ引数が与えられた時、再計算することなしに記憶した値を返します。
そんな関数はしばしば<i>メモ化関数</i>と呼ばれます。
</p>
<p>配列関数名は(グローバルリスト <code>functions</code>ではなく)グローバルリスト
<code>arrays</code>に追加されます。
</p>
<p><code>arrayinfo</code>は記憶された値を持つ引数のリストを返し、
<code>listarray</code>は記憶された値を返します。
<code>dispfun</code>と <code>fundef</code>は配列関数の定義を返します。
</p>
<p><code>arraymake</code>は、通常の関数に対する
<code>funmake</code>のように配列関数コールを構成します。
<code>arrayapply</code>は、
通常の関数に対する <code>apply</code>のように、
配列関数をその引数に適用します。
配列関数に対して <code>map</code>に厳密に似たものはありません。
<code>map(lambda([<var>x</var>], <var>a</var>[<var>x</var>]), <var>L</var>)</code>または
<code>makelist(<var>a</var>[<var>x</var>], <var>x</var>, <var>L</var>)</code>
―<var>L</var>はリストです―は、目的からそれほど遠くありませんけれども。
</p>
<p><code>remarray</code>は、通常の関数に対する
<code>remfunction</code>のように
(記憶された関数値も含めて、)配列関数の定義を削除します。
</p>
<p><code>kill(<var>a</var>[<var>x</var>])</code>は、配列関数 <var>a</var>の引数
<var>x</var>に関して記憶された値を削除します;
次回、引数 <var>x</var>で <var>a</var>がコールされた時、関数値は再計算されます。
しかしながら、関数定義も削除する
<code>kill(<var>a</var>)</code>か <code>remarray(<var>a</var>)</code>を除いて、
記憶された値すべてを一度に削除する方法はありません。
</p>
<p><a name="Item_003a-Macros"></a>
</p><hr size="6">
<a name="Macros"></a>
<a name="SEC199"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC198" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC200" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC194" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.3 Macros </h2>

<p><a name="buildq"></a>
<a name="Item_003a-buildq"></a>
</p><dl>
<dt><u>関数:</u> <b>buildq</b><i> (<var>L</var>, <var>expr</var>)</i>
<a name="IDX1320"></a>
</dt>
<dd><p>リスト <var>L</var>で指名された変数を式 <var>expr</var>に並列に代入します。
<var>expr</var>は評価しません。
<code>buildq</code>が代入を実行した後、結果の式は整理はされますが評価されません。
</p>
<p><var>L</var>の要素はシンボルまたは割り当て式 <code><var>symbol</var>: <var>value</var></code>です。
割り当て式は並列に評価されます。
すなわち、ある変数が割り当ての右辺へバインドされるのは、
<code>buildq</code>がコールされた文脈でのバインドです。
変数リスト <var>L</var>内でその変数がバインドされるのではありません。
もし <var>L</var>の中のある変数に明示的な割り当てがないなら、
<code>buildq</code>でのバインドは、
<code>buildq</code>がコールされた文脈でのそれと同じです。
</p>
<p>そして <var>L</var>で指名された変数は並列に <var>expr</var>に代入されます。
すなわち、すべての変数への代入は他の代入がされる前に決まります。
だから１つの変数の代入は他には一切効果を持ちません。
</p>
<p>もし任意の変数 <var>x</var>が <var>expr</var>の中で <code>splice (<var>x</var>)</code>のように現れるなら、
<var>x</var>はリストにバインドされなければいけませんし、
リストは代入の代わりに <var>expr</var> に接合(内挿)されます。
</p>
<p><var>expr</var>の中の <var>L</var>に現れない任意の変数は、
たとえそれらが
<code>buildq</code>がコールされた文脈の中でバインドを持っていても、逐語的に結果に繰り越されます。
</p>
<p>例
</p>
<p><code>a</code>は明示的に <code>x</code>にバインドされ、
一方で <code>b</code>は、コールする文脈で同じバインド(すなわち29)を持ち、
<code>c</code>は逐語的に繰り越されます。
結果の式は、明示的な評価 <code>''%</code>まで評価されません。
</p>
<pre class="example">(%i1) (a: 17, b: 29, c: 1729)$
(%i2) buildq ([a: x, b], a + b + c);
(%o2)                      x + c + 29
(%i3) ''%;
(%o3)                       x + 1758
</pre>
<p><code>e</code>はリストにバインドされ、
<code>foo</code>の引数の中でそのように現れ、
<code>bar</code>の引数の中に内挿されます。
</p>
<pre class="example">(%i1) buildq ([e: [a, b, c]], foo (x, e, y));
(%o1)                 foo(x, [a, b, c], y)
(%i2) buildq ([e: [a, b, c]], bar (x, splice (e), y));
(%o2)                  bar(x, a, b, c, y)
</pre>
<p>代入の後、結果は整理されます。
もし代入の前に整理が適用されたら、これら２つの結果は同じになったはずです。
</p><pre class="example">(%i1) buildq ([e: [a, b, c]], splice (e) + splice (e));
(%o1)                    2 c + 2 b + 2 a
(%i2) buildq ([e: [a, b, c]], 2 * splice (e));
(%o2)                        2 a b c
</pre>
<p><var>L</var>の中の変数は並列にバインドされます;
もし順次バインドされたなら、
最初の結果は <code>foo (b, b)</code>になったはずです。
代入は並列に実行されます;
二番目の結果を <code>subst</code>の結果と比較してください。
<code>subst</code>は代入を順次実行します。
</p>
<pre class="example">(%i1) buildq ([a: b, b: a], foo (a, b));
(%o1)                       foo(b, a)
(%i2) buildq ([u: v, v: w, w: x, x: y, y: z, z: u],
              bar (u, v, w, x, y, z));
(%o2)                 bar(v, w, x, y, z, u)
(%i3) subst ([u=v, v=w, w=x, x=y, y=z, z=u],
             bar (u, v, w, x, y, z));
(%o3)                 bar(u, u, u, u, u, u)
</pre>
<p>変数や式が左辺に、それらの値が右辺にある等式のリストを構成します。
<code>macroexpand</code>は <code>show_values</code>が返す式を表示します。
</p>
<pre class="example">(%i1) show_values ([L]) ::= buildq ([L], map (&quot;=&quot;, 'L, L));
(%o1)   show_values([L]) ::= buildq([L], map(&quot;=&quot;, 'L, L))
(%i2) (a: 17, b: 29, c: 1729)$
(%i3) show_values (a, b, c - a - b);
(%o3)          [a = 17, b = 29, c - b - a = 1683]
(%i4) macroexpand (show_values (a, b, c - a - b));
(%o4)    map(=, '([a, b, c - b - a]), [a, b, c - b - a])
</pre>
<p>複数の引数を持つ関数が与えられたとして、
引数のいくつかが固定されたもう１つの関数を生成します。
</p>
<pre class="example">(%i1) curry (f, [a]) :=
        buildq ([f, a], lambda ([[x]], apply (f, append (a, x))))$
(%i2) by3 : curry (&quot;*&quot;, 3);
(%o2)        lambda([[x]], apply(*, append([3], x)))
(%i3) by3 (a + b);
(%o3)                       3 (b + a)
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a>
</div>
</p></dd></dl>

<p><a name="macroexpand"></a>
<a name="Item_003a-macroexpand"></a>
</p><dl>
<dt><u>関数:</u> <b>macroexpand</b><i> (<var>expr</var>)</i>
<a name="IDX1321"></a>
</dt>
<dd><p><code>expr</code>がマクロ関数コールの時、
<var>expr</var>のマクロ展開を評価はせずに返します。
そうでないなら <code>macroexpand</code>は <var>expr</var>を返します。
</p>
<p>もし <var>expr</var>の展開が別のマクロ関数コールをもたらすなら、
そのマクロ関数コールも展開されます。
</p>
<p><code>macroexpand</code>は引数をクォートします。
しかしながら、もしマクロ関数コールの展開が副作用を持つなら，
それらの副作用が実行されます。
</p>
<p><code>::=</code>, <code>macros</code>, <code>macroexpand1</code>も参照してください。
</p>
<p>例
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand (h (y));
                              y - a
(%o4)                         -----
                               99
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-application">Function application</a>
</div>
</p></dd></dl>

<p><a name="macroexpand1"></a>
<a name="Item_003a-macroexpand1"></a>
</p><dl>
<dt><u>関数:</u> <b>macroexpand1</b><i> (<var>expr</var>)</i>
<a name="IDX1322"></a>
</dt>
<dd><p><code>expr</code>がマクロ関数コールの時、
<var>expr</var>のマクロ展開を評価せずに返します。
そうでないなら <code>macroexpand1</code>は <var>expr</var>を返します。
</p>
<p><code>macroexpand</code>は引数をクォートします。
しかし、もしマクロ関数コールの展開が副作用を持つなら，
それらの副作用が実行されます。
</p>
<p>もし <var>expr</var>の展開が別のマクロ関数コールをもたらすなら、
そのマクロ関数コールは展開されません。
</p>
<p><code>::=</code>, <code>macros</code>, <code>macroexpand</code>も参照してください。
</p>
<p>例
</p>
<pre class="example">(%i1) g (x) ::= x / 99;
                                    x
(%o1)                      g(x) ::= --
                                    99
(%i2) h (x) ::= buildq ([x], g (x - a));
(%o2)            h(x) ::= buildq([x], g(x - a))
(%i3) a: 1234;
(%o3)                         1234
(%i4) macroexpand1 (h (y));
(%o4)                       g(y - a)
(%i5) h (y);
                            y - 1234
(%o5)                       --------
                               99
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-application">Function application</a>
</div>
</p></dd></dl>

<p><a name="macros"></a>
<a name="Item_003a-macros"></a>
</p><dl>
<dt><u>Global variable:</u> <b>macros</b>
<a name="IDX1323"></a>
</dt>
<dd><p>デフォルト値: <code>[]</code>
</p>
<p><code>macros</code>はユーザー定義のマクロ関数のリストです。
マクロ関数定義演算子 <code>::=</code>は、このリストに新しいマクロ関数を入れ、
<code>kill</code>, <code>remove</code>, <code>remfunction</code>はリストからマクロ関数を削除します。
</p>
<p><code>infolists</code>も参照してください。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a> &middot;
<a href="maxima_100.html#Category_003a-Global-variables">Global variables</a>
</div>
</p></dd></dl>

<p><a name="splice"></a>
<a name="Item_003a-splice"></a>
</p><dl>
<dt><u>関数:</u> <b>splice</b><i> (<var>a</var>)</i>
<a name="IDX1324"></a>
</dt>
<dd><p><code>splice</code>が <code>buildq</code>内部に現れた時だけ、
アトム <var>a</var>で指名されたリストを式に接合(内挿)します;
そうでないなら <code>splice</code>は未定義関数として扱われます。
もし <code>buildq</code>内部で <var>a</var>単独として (<code>splice</code>なしに)現れたら、
<var>a</var>はリストとして、結果の中に代入されます(内挿されません)。
<code>splice</code>の引数はアトムだけを取り得ます;
リストリテラルやリストをもたらす式を取ることはできません。
</p>
<p>通常、<code>splice</code>は関数や演算子の引数を提供します。
関数 <code>f</code>に対して、
<code>buildq</code>内部の式 <code>f (splice (<var>a</var>))</code>は、
<code>f (<var>a</var>[1], <var>a</var>[2], <var>a</var>[3], ...)</code>に展開されます。
演算子 <code>o</code>に対して、
<code>buildq</code>内部の式 <code>&quot;o&quot; (splice (<var>a</var>))</code>は、
<code>&quot;o&quot; (<var>a</var>[1], <var>a</var>[2], <var>a</var>[3], ...)</code>に展開されます。
ここで<code>o</code>は、任意のタイプの演算子を取り得ます(通常は複数の引数を取るものです)。
演算子はダブルクォート <code>&quot;</code>でくくられなければいけないことに注意してください。
</p>
<p>例
</p>
<pre class="example">(%i1) buildq ([x: [1, %pi, z - y]], foo (splice (x)) / length (x));
                       foo(1, %pi, z - y)
(%o1)                -----------------------
                     length([1, %pi, z - y])
(%i2) buildq ([x: [1, %pi]], &quot;/&quot; (splice (x)));
                                1
(%o2)                          ---
                               %pi
(%i3) matchfix (&quot;&lt;&gt;&quot;, &quot;&lt;&gt;&quot;);
(%o3)                          &lt;&gt;
(%i4) buildq ([x: [1, %pi, z - y]], &quot;&lt;&gt;&quot; (splice (x)));
(%o4)                   &lt;&gt;1, %pi, z - y&lt;&gt;
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a>
</div>
</p></dd></dl>


<p><a name="Item_003a-Functions-and-Variables-for-Function-Definition"></a>
</p><hr size="6">
<a name="Functions-and-Variables-for-Function-Definition"></a>
<a name="SEC200"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC199" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC194" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 36.4 Functions and Variables for Function Definition </h2>

<p><a name="apply"></a>
<a name="Item_003a-apply"></a>
</p><dl>
<dt><u>関数:</u> <b>apply</b><i> (<var>F</var>, [<var>x_1</var>, ..., <var>x_n</var>])</i>
<a name="IDX1325"></a>
</dt>
<dd><p><code><var>F</var>(<var>x_1</var>, ..., <var>x_n</var>)</code>を構成し評価します。
</p>
<p><code>apply</code>は配列関数を通常の関数と区別しようとはしません;
<var>F</var>が配列関数の名前の時、 <code>apply</code>は
<code><var>F</var>(...)</code>(カギ括弧の代わりに括弧での関数コール）を評価します。
<code>arrayapply</code>は、この場合、カギ括弧ありで関数コールを評価します。
</p>
<p>例:
</p>
<p><code>apply</code>は引数を評価します。
この例では <code>min</code>が <code>L</code>の値に適用されます。
</p>
<pre class="example">(%i1) L : [1, 5, -10.2, 4, 3];
(%o1)                 [1, 5, - 10.2, 4, 3]
(%i2) apply (min, L);
(%o2)                        - 10.2
</pre>
<p><code>apply</code>は、たとえ関数 <var>F</var>が引数をクォートする場合でも引数を評価します。
</p>
<pre class="example">(%i1) F (x) := x / 1729;
                                   x
(%o1)                     F(x) := ----
                                  1729
(%i2) fname : F;
(%o2)                           F
(%i3) dispfun (F);
                                   x
(%t3)                     F(x) := ----
                                  1729

(%o3)                         [%t3]
(%i4) dispfun (fname);
fname is not the name of a user function.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) apply (dispfun, [fname]);
                                   x
(%t5)                     F(x) := ----
                                  1729
(%o5)                         [%t5]
</pre>
<p><code>apply</code>は関数名 <var>F</var>を評価します。
シングルクオート <code>'</code>は評価を無効にします。
<code>demoivre</code>はグローバル変数の名前であり、また関数でもあります。
</p>
<pre class="example">(%i1) demoivre;
(%o1)                         false
(%i2) demoivre (exp (%i * x));
(%o2)                  %i sin(x) + cos(x)
(%i3) apply (demoivre, [exp (%i * x)]);
demoivre evaluates to false
Improper name or value in functional position.
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i4) apply ('demoivre, [exp (%i * x)]);
(%o4)                  %i sin(x) + cos(x)
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-application">Function application</a>
</div>
</p></dd></dl>

<p><a name="block"></a>
<a name="Item_003a-block"></a>
</p><dl>
<dt><u>関数:</u> <b>block</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>block</tt> ([<var>v_1</var>, &hellip;, <var>v_m</var>], <var>expr_1</var>, &hellip;, <var>expr_n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>block</tt> (<var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1326"></a>
</dt>
<dd><p><code>block</code>は
<var>expr_1</var>, ..., <var>expr_n</var>を順に評価し、評価された最後の式の値を返します。
順序は <code>go</code>, <code>throw</code>, <code>return</code>関数で変更することができます。
<code>return</code>か <code>throw</code>を含む式が評価されないなら、最後の式は <var>expr_n</var>です。
変数 <var>v_1</var>, ..., <var>v_m</var>がブロックにローカルに宣言できます;
これらは同じ名前のグローバル変数と区別されます。
変数がローカルに宣言されないならリストは省略できます。
ブロック内では <var>v_1</var>, ..., <var>v_m</var>以外の変数はグローバル変数です。
</p>
<p><code>block</code>は（存在するなら）変数 <var>v_1</var>, ..., <var>v_m</var>の現在の値を保存し、
変数がそれ自身に評価されるよう変数のバインドを解除します。
ローカル変数はブロック内部で任意の値にバインドできますが、
ブロックが終了するとき保存された値が戻され、
ブロック内で割り当てられた値は失われます。
</p>
<p><code>block</code>内部の宣言 <code>local(<var>v_1</var>, ..., <var>v_m</var>)</code>は
シンボル <var>v_1</var>, ..., <var>v_m</var>に関連付けられた性質を保存し、
他の式を評価する前に性質を取り除き、ブロック終了時に元に戻します。
いくつかの宣言は
<code>:=</code>、<code>array</code>, <code>dependencies</code>, <code>atvalue</code>,
<code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>,
<code>nonscalar</code>その他を含むシンボルの性質として実装されます。
<code>local</code>の効果はブロック内部のみで有効な宣言を作ります;
そうでないならブロック内部の宣言は実際にグローバル宣言となります。
</p>
<p><code>block</code>は他の <code>block</code>内部でも現れます。
新しいブロックが評価されるたびにローカル変数が確立されます。
ローカル変数は内包するブロック内ではグローバルです。
ブロックの中で変数がローカルでないなら、
その値は内包するブロックによって割り当てられた最新の値です。
そうでないならグローバル環境の変数の値になります。
このポリシーは「動的スコープ」の普通の理解と一致します。
</p>
<p>ブロックの値は、最後の文もしくはブロックから明示的に終了するのに使われる関数
<code>return</code>の引数の値です。
関数 <code>go</code>は <code>go</code>の引数でタグされたブロックの文に制御を移すのに使われます。
例えば <code>block ([x], x:1, loop, x: x+1, ..., go(loop), ...)</code>。
<code>go</code>の引数はブロック内部に現れるタグの名前でなければなりません。
<code>go</code>を含んだブロック以外のブロック内部のタグへ飛ぶのに
<code>go</code>を使うことはできません。
</p>
<p>ブロックは、典型的な場合、関数定義の右辺に現れますが、他の場所でも使うことができます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Expressions">Expressions</a> &middot;
<a href="maxima_100.html#Category_003a-Programming">Programming</a>
</div>
</p></dd></dl>


<p><a name="break"></a>
<a name="Item_003a-break"></a>
</p><dl>
<dt><u>関数:</u> <b>break</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1327"></a>
</dt>
<dd><p><var>expr_1</var>, ..., <var>expr_n</var>を評価し、印字し、
それからユーザーが環境を検査し変更できるところで Maximaブレイクを引き起こします。
<code>exit;</code>とタイプすると計算を再開します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Debugging">Debugging</a>
</div>
</p></dd></dl>


<p><a name="catch"></a>
<a name="Item_003a-catch"></a>
</p><dl>
<dt><u>関数:</u> <b>catch</b><i> (<var>expr_1</var>, ..., <var>expr_n</var>)</i>
<a name="IDX1328"></a>
</dt>
<dd><p><var>expr_1</var>, ..., <var>expr_n</var>を１つずつ評価します;
もしどれかが形式 <code>throw (arg)</code>の式の評価に至るなら、
<code>catch</code>の値は <code>throw (arg)</code>の値であり、もう式は評価されません。
ここ「非局所的リターン」は入れ子の任意の深さを通過して、
<code>throw</code>を含む最も近い <code>catch</code>に飛びます。
もし <code>throw</code>を含む <code>catch</code>がないなら、
エラーメッセージが印字されます。
</p>
<p>もし引数の評価がいかなる <code>throw</code>の評価にも至らないなら、
<code>catch</code>の値は <var>expr_n</var>の値です。
</p>
<pre class="example">(%i1) lambda ([x], if x &lt; 0 then throw(x) else f(x))$
(%i2) g(l) := catch (map (''%, l))$
(%i3) g ([1, 2, 3, 7]);
(%o3)               [f(1), f(2), f(3), f(7)]
(%i4) g ([1, 2, -3, 7]);
(%o4)                          - 3
</pre>
<p>もし <code>l</code>が非負数だけから成るなら、
<code>l</code>の要素それぞれの <code>f</code>のリストを返します;
そうでないなら <code>g</code>は
<code>l</code>の最初の負の要素を「キャッチ」して、それを「スロー」します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Programming">Programming</a>
</div>
</p></dd></dl>

<p><a name="compfile"></a>
<a name="Item_003a-compfile"></a>
</p><dl>
<dt><u>関数:</u> <b>compfile</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>compfile</tt> (<var>filename</var>, <var>f_1</var>, &hellip;, <var>f_n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>compfile</tt> (<var>filename</var>, functions) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>compfile</tt> (<var>filename</var>, all)</i>
<a name="IDX1329"></a>
</dt>
<dd><p>Maxima関数を Lispに翻訳し、翻訳したコードをファイル <var>filename</var>に書き込みます。
</p>
<p><code>compfile(<var>filename</var>, <var>f_1</var>, ..., <var>f_n</var>)</code>は
指定された関数を翻訳します。
<code>compfile (<var>filename</var>, functions)</code>と
<code>compfile (<var>filename</var>, all)</code>はユーザー定義関数をすべて翻訳します。
</p>
<p>Lisp翻訳は評価されず、出力ファイルは Lispコンパイラによって処理もされません。
<code>translate</code>は Lisp翻訳を生成し評価します。
<code>compile_file</code>は Maximaを Lispに翻訳し、 Lispコンパイラを実行します。
</p>
<p><code>translate</code>, <code>translate_file</code>, <code>compile_file</code>も参照してください。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>


<p><a name="compile"></a>
<a name="Item_003a-compile"></a>
</p><dl>
<dt><u>関数:</u> <b>compile</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>compile</tt> (<var>f_1</var>, &hellip;, <var>f_n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>compile</tt> (functions) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>compile</tt> (all)</i>
<a name="IDX1330"></a>
</dt>
<dd><p>Maxima関数 <var>f_1</var>, ..., <var>f_n</var>を Lispに翻訳し、
Lisp翻訳を評価し、翻訳された関数それぞれについて Lisp関数 <code>COMPILE</code>をコールします。
<code>compile</code>はコンパイルされた関数名のリストを返します。
</p>
<p><code>compile (all)</code>や
<code>compile (functions)</code>はユーザー定義関数すべてをコンパイルします。
</p>
<p><code>compile</code>は引数をクォートします;
クォートクォート演算子 <code>''</code>はクォートに優先します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>

<p><a name="define"></a>
<a name="Item_003a-define"></a>
</p><dl>
<dt><u>関数:</u> <b>define</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>define</tt> (<var>f</var>(<var>x_1</var>, &hellip;, <var>x_n</var>), <var>expr</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>define</tt> (<var>f</var>[<var>x_1</var>, &hellip;, <var>x_n</var>], <var>expr</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>define</tt> (<var>f</var>[<var>x_1</var>, &hellip;, <var>x_n</var>](<var>y_1</var>, &hellip;, <var>y_m</var>), <var>expr</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>define</tt> (funmake (<var>f</var>, [<var>x_1</var>, &hellip;, <var>x_n</var>]), <var>expr</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>define</tt> (arraymake (<var>f</var>, [<var>x_1</var>, &hellip;, <var>x_n</var>]), <var>expr</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>define</tt> (ev (<var>expr_1</var>), <var>expr_2</var>)</i>
<a name="IDX1331"></a>
</dt>
<dd><p>引数 <var>x_1</var>, &hellip;, <var>x_n</var>を持ち、
<var>expr</var>の中身を持つ <var>f</var>という名前の関数を定義します。
<code>define</code>は（明示的にクオートされていない限り）いつも２番目の引数を評価します。
定義された関数は（かっこでくくられた引数を持つ）通常の
Maxima関数か（カギ括弧でくくられた引数を持つ）配列関数です。
</p>
<p>最後の関数の引数 <var>x_n</var>が要素１つのリストの時、
<code>define</code>によって定義される関数は可変な数の引数を受け付けます。
実際の引数は、形式的な引数  <var>x_1</var>, ..., <var>x_(n - 1)</var>に１対１に割り当てられます。
実際の引数がさらに存在するなら <var>x_n</var>にリストとして割り当てられます。
</p>
<p><code>define</code>の最初の引数が <code><var>f</var>(<var>x_1</var>, ..., <var>x_n</var>)</code>か
<code><var>f</var>[<var>x_1</var>, ..., <var>x_n</var>]</code>の形の式の時、
関数の引数は評価されますが、既にその名前の関数や変数があったとしても
<var>f</var>は評価されません。
</p>
<p>最初の引数が演算子 <code>funmake</code>か <code>arraymake</code>, <code>ev</code>を伴う式の時、
最初の引数は評価されます；これは、本体だけでなく、関数名が計算されることを許します。
</p>
<p>すべての関数定義は同じ名前空間で現れます;
関数 <code>g</code>の中で関数 <code>f</code>を定義することは、
<code>f</code>のスコープを<code>g</code>に自動的に限定することにはなりません。
しかし、 <code>local(f)</code>は関数 <code>f</code>の定義を
<code>local</code>が現れたブロックや他の合成式内部でのみ有効とします。
</p>
<p>もしある形式的な引数 <var>x_k</var>が（評価の後）クォートされたシンボルなら、
<code>define</code>によって定義される関数は対応する実際の引数を評価しません。
そうでないならすべての実際の引数は評価されます。
</p>
<p><code>:=</code>や <code>::=</code>も参照してください。
</p>
<p>例:
</p>
<p><code>define</code>は(明示的にクォートされない限り)いつも二番目の引数を評価します。
</p>
<pre class="example">(%i1) expr : cos(y) - sin(x);
(%o1)                    cos(y) - sin(x)
(%i2) define (F1 (x, y), expr);
(%o2)              F1(x, y) := cos(y) - sin(x)
(%i3) F1 (a, b);
(%o3)                    cos(b) - sin(a)
(%i4) F2 (x, y) := expr;
(%o4)                   F2(x, y) := expr
(%i5) F2 (a, b);
(%o5)                    cos(y) - sin(x)
</pre>
<p><code>define</code>が定義する関数は通常の Maxima関数も配列関数も取り得ます。
</p>
<pre class="example">(%i1) define (G1 (x, y), x.y - y.x);
(%o1)               G1(x, y) := x . y - y . x
(%i2) define (G2 [x, y], x.y - y.x);
(%o2)                G2     := x . y - y . x
                       x, y
</pre>
<p>最後の引数か唯一の引数 <var>x_n</var>が１要素のリストの時、
<code>define</code>が定義した関数は可変の数の引数を受け付けます。
</p>
<pre class="example">(%i1) define (H ([L]), '(apply (&quot;+&quot;, L)));
(%o1)                H([L]) := apply(&quot;+&quot;, L)
(%i2) H (a, b, c);
(%o2)                       c + b + a
</pre>
<p>最初の引数が演算子 <code>funmake</code>か, <code>arraymake</code>,
<code>ev</code>を含む式なら最初の引数は評価されます。
</p>
<pre class="example">(%i1) [F : I, u : x];
(%o1)                        [I, x]
(%i2) funmake (F, [u]);
(%o2)                         I(x)
(%i3) define (funmake (F, [u]), cos(u) + 1);
(%o3)                  I(x) := cos(x) + 1
(%i4) define (arraymake (F, [u]), cos(u) + 1);
(%o4)                   I  := cos(x) + 1
                         x
(%i5) define (foo (x, y), bar (y, x));
(%o5)                foo(x, y) := bar(y, x)
(%i6) define (ev (foo (x, y)), sin(x) - cos(y));
(%o6)             bar(y, x) := sin(x) - cos(y)
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a>
</div>
</p></dd></dl>


<p><a name="define_005fvariable"></a>
<a name="Item_003a-define_005fvariable"></a>
</p><dl>
<dt><u>関数:</u> <b>define_variable</b><i> (<var>name</var>, <var>default_value</var>, <var>mode</var>)</i>
<a name="IDX1332"></a>
</dt>
<dd><p>グローバル変数を Maxima環境に導入します。
<code>define_variable</code>はユーザーが書いたパッケージで役に立ちます。
パッケージはしばしば翻訳されたりコンパイルされたりします。
</p>
<p><code>define_variable</code>は以下のステップを実行します:
</p>
<ol>
<li>
<code>mode_declare (<var>name</var>, <var>mode</var>)</code>は
<var>name</var>のモードを翻訳器に宣言します。
可能なモードのリストについては <code>mode_declare</code>を参照してください。

</li><li>
もし変数がバインドされていないなら
<var>default_value</var>が <var>name</var>に割り当てられます。

</li><li>
<var>name</var>が宣言されたモードのただ１つの割り当てられた値であることを保証するために、
<var>name</var>をテスト関数に関連づけます。

</li></ol>



<p><code>value_check</code>プロパティは、
<code>define_variable</code>を介して
<code>any</code>以外のモードに定義された任意の変数に割り当てることができます。
<code>value_check</code>プロパティは１変数のラムダ式または関数名です。
それは値を変数に割り当てようとする時にコールされます。
<code>value_check</code>関数の引数は期待値です。
</p>
<p><code>define_variable</code>は <code>default_value</code>を評価し、
<code>name</code>と <code>mode</code>をクォートします。
<code>define_variable</code>は <code>name</code>の現在値を返します。
それは、もし <code>name</code>がそこでバインドされてないなら <code>default_value</code>で、
そうでないなら <code>name</code>の以前の値です。
</p>
<p>例:
</p>
<p><code>foo</code>はブーリアン変数で、初期値 <code>true</code>を持ちます。
</p>
<pre class="example">(%i1) define_variable (foo, true, boolean);
(%o1)                         true
(%i2) foo;
(%o2)                         true
(%i3) foo: false;
(%o3)                         false
(%i4) foo: %pi;
Error: foo was declared mode boolean, has value: %pi
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i5) foo;
(%o5)                         false
</pre>
<p><code>bar</code>は整数変数で、素数でなければいけません。
</p>
<pre class="example">(%i1) define_variable (bar, 2, integer);
(%o1)                           2
(%i2) qput (bar, prime_test, value_check);
(%o2)                      prime_test
(%i3) prime_test (y) := if not primep(y) then
                           error (y, &quot;is not prime.&quot;);
(%o3) prime_test(y) := if not primep(y)

                                   then error(y, &quot;is not prime.&quot;)
(%i4) bar: 1439;
(%o4)                         1439
(%i5) bar: 1440;
1440 is not prime.
#0: prime_test(y=1440)
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) bar;
(%o6)                         1439
</pre>
<p><code>baz_quux</code>は値を割り当てられない変数です。
モード <code>any_check</code>は <code>any</code>のようですが、
<code>any_check</code>は <code>value_check</code>メカニズムを可能にしますが、
<code>any</code>はそうしません。
</p>
<pre class="example">(%i1) define_variable (baz_quux, 'baz_quux, any_check);
(%o1)                       baz_quux
(%i2) F: lambda ([y], if y # 'baz_quux then
                 error (&quot;Cannot assign to `baz_quux'.&quot;));
(%o2) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i3) qput (baz_quux, ''F, value_check);
(%o3) lambda([y], if y # 'baz_quux

                        then error(Cannot assign to `baz_quux'.))
(%i4) baz_quux: 'baz_quux;
(%o4)                       baz_quux
(%i5) baz_quux: sqrt(2);
Cannot assign to `baz_quux'.
#0: lambda([y],if y # 'baz_quux then
                 error(&quot;Cannot assign to `baz_quux'.&quot;))(y=sqrt(2))
 -- an error.  Quitting.  To debug this try debugmode(true);
(%i6) baz_quux;
(%o6)                       baz_quux
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>

<p><a name="dispfun"></a>
<a name="Item_003a-dispfun"></a>
</p><dl>
<dt><u>関数:</u> <b>dispfun</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>dispfun</tt> (<var>f_1</var>, &hellip;, <var>f_n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>dispfun</tt> (all)</i>
<a name="IDX1333"></a>
</dt>
<dd><p>ユーザー定義関数 <var>f_1</var>, ..., <var>f_n</var>の定義を表示します。
引数それぞれは、 (<code>::=</code>で定義された)マクロ名、
(<code>:=</code>や <code>define</code>で定義された)通常の関数、
(<code>:=</code>や <code>define</code>で定義された、しかし引数をカギ括弧
<code>[ ]</code>でくくった)配列関数、
(<code>:=</code>や <code>define</code>で定義された、しかしいくつかの引数をカギ括弧
<code>[ ]</code>で、他の引数を括弧 <code>( )</code>でくくった)添字付き関数、
特別な添字の値で選択された添字付き関数の族の１つ、定数添字で定義された添字付き関数、
のいずれかを取り得ます。
</p>
<p><code>dispfun (all)</code>は、リスト <code>functions</code>, <code>arrays</code>,
<code>macros</code>で与えられるようなユーザー定義関数すべてを表示します。
定数添字で定義された添字付き関数は除きます。
</p>
<p><code>dispfun</code>は表示された関数それぞれのために
(<code>%t1</code>, <code>%t2</code>, など)
中間式ラベルを生成し、関数定義をラベルに割り当てます。
対照的に <code>fundef</code>は関数定義を返します。
</p>
<p><code>dispfun</code>は引数をクォートします;
クォートクォート演算子 <code>''</code>はクォートに優先します。
<code>dispfun</code>は表示された関数に対応する中間式ラベルのリストを返します。
</p>
<p>例:
</p>
<pre class="example">(%i1) m(x, y) ::= x^(-y);
                                     - y
(%o1)                   m(x, y) ::= x
(%i2) f(x, y) :=  x^(-y);
                                     - y
(%o2)                    f(x, y) := x
(%i3) g[x, y] :=  x^(-y);
                                    - y
(%o3)                     g     := x
                           x, y
(%i4) h[x](y) :=  x^(-y);
                                    - y
(%o4)                     h (y) := x
                           x
(%i5) i[8](y) :=  8^(-y);
                                    - y
(%o5)                     i (y) := 8
                           8
(%i6) dispfun (m, f, g, h, h[5], h[10], i[8]);
                                     - y
(%t6)                   m(x, y) ::= x
                                     - y
(%t7)                    f(x, y) := x

                                    - y
(%t8)                     g     := x
                           x, y

                                    - y
(%t9)                     h (y) := x
                           x

                                    1
(%t10)                     h (y) := --
                            5        y
                                    5

                                     1
(%t11)                    h  (y) := ---
                           10         y
                                    10

                                    - y
(%t12)                    i (y) := 8
                           8

(%o12)       [%t6, %t7, %t8, %t9, %t10, %t11, %t12]
(%i12) ''%;
                     - y              - y            - y
(%o12) [m(x, y) ::= x   , f(x, y) := x   , g     := x   ,
                                            x, y
                  - y           1              1             - y
        h (y) := x   , h (y) := --, h  (y) := ---, i (y) := 8   ]
         x              5        y   10         y   8
                                5             10
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a> &middot;
<a href="maxima_100.html#Category_003a-Display-functions">Display functions</a>
</div>
</p></dd></dl>

<p><a name="fullmap"></a>
<a name="Item_003a-fullmap"></a>
</p><dl>
<dt><u>関数:</u> <b>fullmap</b><i> (<var>f</var>, <var>expr_1</var>, &hellip;)</i>
<a name="IDX1334"></a>
</dt>
<dd><p><code>map</code>と似ていますが、
<code>fullmap</code>は主演算子が同じでなくなるまで部分式すべてに再帰的にマッピングを続けます。
</p>
<p><code>fullmap</code>はある行列操作のための整理に使われています;
このように、 Maximaは時々、たとえ ユーザーが 明示的に
<code>fullmap</code>をコールしなくても、
<code>fullmap</code>に関係したエラーメッセージを生成します。
</p>
<p>例:
</p>
<pre class="example">(%i1) a + b * c;
(%o1)                        b c + a
(%i2) fullmap (g, %);
(%o2)                   g(b) g(c) + g(a)
(%i3) map (g, %th(2));
(%o3)                     g(b c) + g(a)
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-application">Function application</a> &middot;
<a href="maxima_100.html#Category_003a-Expressions">Expressions</a>
</div>
</p></dd></dl>

<p><a name="fullmapl"></a>
<a name="Item_003a-fullmapl"></a>
</p><dl>
<dt><u>関数:</u> <b>fullmapl</b><i> (<var>f</var>, <var>list_1</var>, &hellip;)</i>
<a name="IDX1335"></a>
</dt>
<dd><p><code>fullmap</code>に似ていますが、 <code>fullmapl</code>はリストや行列にのみマップします。
</p>
<p>例:
</p>
<pre class="example">(%i1) fullmapl (&quot;+&quot;, [3, [4, 5]], [[a, 1], [0, -1.5]]);
(%o1)                [[a + 3, 4], [4, 3.5]]
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-application">Function application</a> &middot;
<a href="maxima_100.html#Category_003a-Expressions">Expressions</a>
</div>
</p></dd></dl>

<p><a name="functions"></a>
<a name="Item_003a-functions"></a>
</p><dl>
<dt><u>システム変数:</u> <b>functions</b>
<a name="IDX1336"></a>
</dt>
<dd><p>デフォルト値: <code>[]</code>
</p>
<p><code>functions</code>は現在のセッションでの通常の Maxima関数のリストです。
通常の関数は <code>define</code>や <code>:=</code>で構成された関数であり、
括弧 <code>()</code>を使ってコールされます。
関数は Maximaプロンプトで定義することができ、また、
<code>load</code>や <code>batch</code>がロードする Maximaファイルの中で定義することができます。
</p>
<p>(例えば <code>F[x]</code>のように、カギ括弧でコールされる)配列関数と
(例えば <code>F[x](y)</code>のように、カギ括弧と括弧でコールされる)添字付き関数は、
<code>functions</code>ではなくグローバル変数 <code>arrays</code>にリストされます。
</p>
<p>Lisp関数はどのリストにも保持されません。
</p>
<p>例:
</p>
<pre class="example">(%i1) F_1 (x) := x - 100;
(%o1)                   F_1(x) := x - 100
(%i2) F_2 (x, y) := x / y;
                                      x
(%o2)                    F_2(x, y) := -
                                      y
(%i3) define (F_3 (x), sqrt (x));
(%o3)                   F_3(x) := sqrt(x)
(%i4) G_1 [x] := x - 100;
(%o4)                    G_1  := x - 100
                            x
(%i5) G_2 [x, y] := x / y;
                                     x
(%o5)                     G_2     := -
                             x, y    y
(%i6) define (G_3 [x], sqrt (x));
(%o6)                    G_3  := sqrt(x)
                            x
(%i7) H_1 [x] (y) := x^y;
                                      y
(%o7)                     H_1 (y) := x
                             x
(%i8) functions;
(%o8)              [F_1(x), F_2(x, y), F_3(x)]
(%i9) arrays;
(%o9)                 [G_1, G_2, G_3, H_1]
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a> &middot;
<a href="maxima_100.html#Category_003a-Global-variables">Global variables</a>
</div>
</p></dd></dl>

<p><a name="fundef"></a>
<a name="Item_003a-fundef"></a>
</p><dl>
<dt><u>関数:</u> <b>fundef</b><i> (<var>f</var>)</i>
<a name="IDX1337"></a>
</dt>
<dd><p>関数 <var>f</var>の定義を返します。
</p>
<p>引数は、 (<code>::=</code>で定義された）マクロの名前か、
(<code>:=</code>や <code>define</code>で定義された）通常の関数か、
(<code>:=</code>や <code>define</code>で定義され、引数がカギ括弧でくくられた）配列関数か、
(<code>:=</code>や <code>define</code>で定義され、
いくつかの引数がカギ括弧でくくられ、残りがかっこでくくられた）添字関数か、
特別な添字の値によって選択された添字関数族の１つか、一定の添字で定義された添字関数です。
</p>
<p><code>fundef</code>は引数をクォートします;
クォートクォート演算子 <code>''</code>はクォートに優先します。
</p>
<p><code>fundef (<var>f</var>)</code>は <var>f</var>の定義を返します。
対照的に、 <code>dispfun (<var>f</var>)</code>は中間式ラベルを生成し、ラベルに定義を割り当てます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a>
</div>
</p></dd></dl>

<p><a name="funmake"></a>
<a name="Item_003a-funmake"></a>
</p><dl>
<dt><u>関数:</u> <b>funmake</b><i> (<var>F</var>, [<var>arg_1</var>, &hellip;, <var>arg_n</var>])</i>
<a name="IDX1338"></a>
</dt>
<dd><p>式 <code><var>F</var>(<var>arg_1</var>, ..., <var>arg_n</var>)</code>を返します。
戻り値は整理されますが、評価されません。
だから関数 <var>F</var>はたとえ存在してもコールされません。
</p>
<p><code>funmake</code>は配列関数と通常の関数を区別しようとしません;
<var>F</var>が配列関数名の時、
<code>funmake</code>は <code><var>F</var>(...)</code>を返します
(すなわち、カギ括弧の代わりに括弧での関数コール)。
<code>arraymake</code>は、この場合，カギ括弧での関数コールを返します。
</p>
<p><code>funmake</code>は引数を評価します。
</p>
<p>例:
</p>
<p>通常の Maxima関数に適用された <code>funmake</code>。
</p>
<pre class="example">(%i1) F (x, y) := y^2 - x^2;
                                   2    2
(%o1)                  F(x, y) := y  - x
(%i2) funmake (F, [a + 1, b + 1]);
(%o2)                    F(a + 1, b + 1)
(%i3) ''%;
                              2          2
(%o3)                  (b + 1)  - (a + 1)
</pre>
<p>マクロに適用された <code>funmake</code>。
</p>
<pre class="example">(%i1) G (x) ::= (x - 1)/2;
                                  x - 1
(%o1)                    G(x) ::= -----
                                    2
(%i2) funmake (G, [u]);
(%o2)                         G(u)
(%i3) ''%;
                              u - 1
(%o3)                         -----
                                2
</pre>
<p>添字付き関数に適用された <code>funmake</code>。
</p>
<pre class="example">(%i1) H [a] (x) := (x - 1)^a;
                                        a
(%o1)                   H (x) := (x - 1)
                         a
(%i2) funmake (H [n], [%e]);
                                       n
(%o2)               lambda([x], (x - 1) )(%e)
(%i3) ''%;
                                    n
(%o3)                       (%e - 1)
(%i4) funmake ('(H [n]), [%e]);
(%o4)                        H (%e)
                              n
(%i5) ''%;
                                    n
(%o5)                       (%e - 1)
</pre>
<p>いかなる種類の関数にも定義されていないシンボルへ適用された <code>funmake</code>
</p>
<pre class="example">(%i1) funmake (A, [u]);
(%o1)                         A(u)
(%i2) ''%;
(%o2)                         A(u)
</pre>
<p><code>funmake</code>は引数を評価しますが、戻り値を評価しません。
</p>
<pre class="example">(%i1) det(a,b,c) := b^2 -4*a*c;
                                    2
(%o1)              det(a, b, c) := b  - 4 a c
(%i2) (x : 8, y : 10, z : 12);
(%o2)                          12
(%i3) f : det;
(%o3)                          det
(%i4) funmake (f, [x, y, z]);
(%o4)                    det(8, 10, 12)
(%i5) ''%;
(%o5)                         - 284
</pre>
<p>Maximaは <code>funmake</code>の戻り値を整理します。
</p>
<pre class="example">(%i1) funmake (sin, [%pi / 2]);
(%o1)                           1
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-application">Function application</a> &middot;
<a href="maxima_100.html#Category_003a-Expressions">Expressions</a>
</div>
</p></dd></dl>

<p><a name="lambda"></a>
<a name="Item_003a-lambda"></a>
</p><dl>
<dt><u>関数:</u> <b>lambda</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>lambda</tt> ([<var>x_1</var>, &hellip;, <var>x_m</var>], <var>expr_1</var>, &hellip;, <var>expr_n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>lambda</tt> ([[<var>L</var>]], <var>expr_1</var>, &hellip;, <var>expr_n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>lambda</tt> ([<var>x_1</var>, &hellip;, <var>x_m</var>, [<var>L</var>]], <var>expr_1</var>, &hellip;, <var>expr_n</var>)</i>
<a name="IDX1339"></a>
</dt>
<dd><p>ラムダ式 (すなわち、匿名関数)を定義し返します。
関数は要求された引数 <var>x_1</var>, ..., <var>x_m</var>を持ち、
また、オプション引数 <var>L</var>を持つかもしれません。
オプション引数は関数本体の中にリストとして現れます。
関数の戻り値は <var>expr_n</var>です。
ラムダ式は変数に割り当てることができ、通常の関数のように評価できます。
ラムダ式は関数名が期待されるいくつかのコンテキストで現れるかもしれません。
</p>
<p>関数が評価される時、
バインドされていないローカル変数 <var>x_1</var>, ..., <var>x_m</var>を生成します。
<code>lambda</code>は <code>block</code>の中や別の <code>lambda</code>の中で現れるかもしれません;
ローカル変数は、別の <code>block</code>や <code>lambda</code>が評価される度に毎回確立されます。
ローカル変数は内包する <code>block</code>や <code>lambda</code>にはグローバルのように見えます。
もし変数がローカルでないなら、
その値は、(もし割り当てられたなら)内包する <code>block</code>や
<code>lambda</code>で直近に割り当てられた値です。
そうでないなら、グローバル環境での変数の値です。
このポリシーは「動的スコープ」の普通の理解と一致するかもしれません。
</p>
<p>ローカル変数が確立された後、
<var>expr_1</var>から <var>expr_n</var>までが順に評価されます。
特殊変数 <code>%%</code>―直前の式の値を表します―が認識されます。
<code>throw</code>と <code>catch</code>も式のリストの中に現れるかもしれません。
</p>
<p><code>block</code>で囲まれない限り
<code>return</code>はラムダ式の中には現れません。
<code>block</code>で囲まれた場合、
ブロックがたまたま <var>expr_n</var>に至るということでない限り、
<code>return</code>はラムダ式の戻り値ではなくブロックの戻り値を定義します。
同様に、<code>go</code>は <code>block</code>で囲まれない限りラムダ式の中に現れません。
</p>
<p><code>lambda</code>は引数をクォートします;
クォートクォート演算子 <code>''</code>はクォートに優先します。
</p>
<p>例:
</p>
<ul>
<li>
ラムダ式は変数に割り当てることができ、通常の関数のように評価できます。
</li></ul>

<pre class="example">(%i1) f: lambda ([x], x^2);
                                      2
(%o1)                    lambda([x], x )
(%i2) f(a);
                                2
(%o2)                          a
</pre><ul>
<li>
ラムダ式は
関数評価が期待される文脈で現れるかもしれません。
</li></ul>

<pre class="example">(%i3) lambda ([x], x^2) (a);
                                2
(%o3)                          a
(%i4) apply (lambda ([x], x^2), [a]);
                                2
(%o4)                          a
(%i5) map (lambda ([x], x^2), [a, b, c, d, e]);
                        2   2   2   2   2
(%o5)                 [a , b , c , d , e ]
</pre><ul>
<li>
引数変数はローカル変数です。
他の変数はグローバル変数のように見えます。
ある特殊な評価が <code>''</code>のようにある方法で強制されない限り、
グローバル変数はラムダ式が評価される時評価されます。
</li></ul>

<pre class="example">(%i6) a: %pi$
(%i7) b: %e$
(%i8) g: lambda ([a], a*b);
(%o8)                   lambda([a], a b)
(%i9) b: %gamma$
(%i10) g(1/2);
                             %gamma
(%o10)                       ------
                               2
(%i11) g2: lambda ([a], a*''b);
(%o11)                lambda([a], a %gamma)
(%i12) b: %e$
(%i13) g2(1/2);
                             %gamma
(%o13)                       ------
                               2
</pre><ul>
<li>
ラムダ式は入れ子にできます。
外側のラムダ式の中のローカル変数は、
同じ名前のローカル変数がマスクしない限り、
内側の式にはグローバルに見えます。
</li></ul>

<pre class="example">(%i14) h: lambda ([a, b], h2: lambda ([a], a*b), h2(1/2));
                                                   1
(%o14)    lambda([a, b], h2 : lambda([a], a b), h2(-))
                                                   2
(%i15) h(%pi, %gamma);
                             %gamma
(%o15)                       ------
                               2
</pre><ul>
<li>
<code>lambda</code>は引数をクォートするので、
以下のラムダ式 <code>i</code>は &quot;<code>a</code>を掛ける&quot;関数を定義しません。
以下のラムダ式 <code>i2</code>のように、
そんな関数は <code>buildq</code>を介して定義することができます。
</li></ul>

<pre class="example">(%i16) i: lambda ([a], lambda ([x], a*x));
(%o16)            lambda([a], lambda([x], a x))
(%i17) i(1/2);
(%o17)                  lambda([x], a x)
(%i18) i2: lambda([a], buildq([a: a], lambda([x], a*x)));
(%o18)    lambda([a], buildq([a : a], lambda([x], a x)))
(%i19) i2(1/2);
                                     x
(%o19)                   lambda([x], -)
                                     2
(%i20) i2(1/2)(%pi);
                               %pi
(%o20)                         ---
                                2
</pre><ul>
<li>
ラムダ式は、可変の数の引数を取ることができます。
それは、唯一のまたは最後の引数として <code>[<var>L</var>]</code>で指定されます。
引数は関数本体の中にリストとして現れます。
</li></ul>

<pre class="example">(%i1) f : lambda ([aa, bb, [cc]], aa * cc + bb);
(%o1)          lambda([aa, bb, [cc]], aa cc + bb)
(%i2) f (foo, %i, 17, 29, 256);
(%o2)       [17 foo + %i, 29 foo + %i, 256 foo + %i]
(%i3) g : lambda ([[aa]], apply (&quot;+&quot;, aa));
(%o3)             lambda([[aa]], apply(+, aa))
(%i4) g (17, 29, x, y, z, %e);
(%o4)                  z + y + x + %e + 46
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a>
</div>
</p></dd></dl>


<p><a name="local"></a>
<a name="Item_003a-local"></a>
</p><dl>
<dt><u>関数:</u> <b>local</b><i> (<var>v_1</var>, &hellip;, <var>v_n</var>)</i>
<a name="IDX1340"></a>
</dt>
<dd><p>シンボル <var>v_1</var>, ..., <var>v_n</var>に関連付けられた性質を保存し、
他の式を評価する前にすべての性質を削除し、
<code>local</code>が現れたブロックや他の合成式の終了時に保存した性質を元に戻します。
</p>
<p>いくつかの宣言は、<code>:=</code>、<code>array</code>, <code>dependencies</code>, <code>atvalue</code>,
<code>matchdeclare</code>, <code>atomgrad</code>, <code>constant</code>,
<code>nonscalar</code>その他を含むシンボルの性質として実装されます。
<code>local</code>の効果はブロック内部のみで有効な宣言を作ります;
そうでないなら ブロック内部の宣言は実際にグローバル宣言となります。
</p>
<p><code>local</code>は <code>block</code>や関数定義の本体や <code>lambda</code>式の中に現れます。
それぞれの中で１カ所だけ許されます。
</p>
<p><code>local</code>は引数をクォートします。
<code>local</code>は <code>done</code>を返します。
</p>
<p>例:
</p>
<p>ローカル関数定義。
</p>
<pre class="example">(%i1) foo (x) := 1 - x;
(%o1)                    foo(x) := 1 - x
(%i2) foo (100);
(%o2)                         - 99
(%i3) block (local (foo), foo (x) := 2 * x, foo (100));
(%o3)                          200
(%i4) foo (100);
(%o4)                         - 99
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a> &middot;
<a href="maxima_100.html#Category_003a-Programming">Programming</a>
</div>
</p></dd></dl>

<p><a name="macroexpansion"></a>
<a name="Item_003a-macroexpansion"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>macroexpansion</b>
<a name="IDX1341"></a>
</dt>
<dd><p>デフォルト値: <code>false</code>
</p>
<p><code>macroexpansion</code>はマクロ関数コールにマクロ関数の展開(すなわち戻り値)を
代入するかどうかを制御します。
展開を記憶する代価を伴いますが、代入は続く式評価をスピードアップするかもしれません。
</p>
<dl compact="compact">
<dt> <code>false</code></dt>
<dd><p>マクロ関数コールにマクロ関数の展開を代入しません。
</p>
</dd>
<dt> <code>expand</code></dt>
<dd><p>マクロ関数コールが初めて評価された時、展開を記憶します。
展開は次のコール時には再計算されません;
(<code>print</code>やグローバル変数への割り当てのような)いかなる副作用も
最初にマクロ関数コールを評価した時だけ起こります。
式の中の展開は同じマクロ関数コールを持つ他の式に影響を与えません。
</p></dd>
<dt> <code>displace</code></dt>
<dd><p>マクロ関数コールを初めて評価した時、展開をコールに代入し、
マクロ関数をコールした式を変更します。
展開は次のコール時には再計算されません;
(<code>print</code>やグローバル変数への割り当てのような)いかなる副作用も
最初にマクロ関数コールを評価した時だけ起こります。
式の中の展開は同じマクロ関数コールを持つ他の式に影響を与えません。
</p></dd>
</dl>

<p>例
</p>
<p><code>macroexpansion</code>が <code>false</code>の時、
コールする式を評価する度にマクロ関数をコールし、
コールする式は変更されません。
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x),
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x),
                                                  return(x - 99))
(%i4) macroexpansion: false;
(%o4)                         false
(%i5) f (a * b);
x - 99 is equal to x
x + 99 is equal to x
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
x - 99 is equal to x
x + 99 is equal to x
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p><code>macroexpansion</code>が <code>expand</code>の時、
マクロ関数を一度だけコールし、
コールする式を変更しません。
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x),
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x),
                                                  return(x - 99))
(%i4) macroexpansion: expand;
(%o4)                        expand
(%i5) f (a * b);
x - 99 is equal to x
x + 99 is equal to x
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                  h(x)
(%t6)                     f(x) := ----
                                  g(x)

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<p><code>macroexpansion</code>が<code>displace</code>の時、
マクロ関数を一度だけコールし、
コールする式を変更します。
</p>
<pre class="example">(%i1) f (x) := h (x) / g (x);
                                  h(x)
(%o1)                     f(x) := ----
                                  g(x)
(%i2) g (x) ::= block (print (&quot;x + 99 is equal to&quot;, x),
                       return (x + 99));
(%o2) g(x) ::= block(print(&quot;x + 99 is equal to&quot;, x),
                                                  return(x + 99))
(%i3) h (x) ::= block (print (&quot;x - 99 is equal to&quot;, x),
                       return (x - 99));
(%o3) h(x) ::= block(print(&quot;x - 99 is equal to&quot;, x),
                                                  return(x - 99))
(%i4) macroexpansion: displace;
(%o4)                       displace
(%i5) f (a * b);
x - 99 is equal to x
x + 99 is equal to x
                            a b - 99
(%o5)                       --------
                            a b + 99
(%i6) dispfun (f);
                                 x - 99
(%t6)                    f(x) := ------
                                 x + 99

(%o6)                         done
(%i7) f (a * b);
                            a b - 99
(%o7)                       --------
                            a b + 99
</pre>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-application">Function application</a> &middot;
<a href="maxima_100.html#Category_003a-Global-flags">Global flags</a>
</div>
</p>
</dd></dl>

<p><a name="mode_005fcheckp"></a>
<a name="Item_003a-mode_005fcheckp"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>mode_checkp</b>
<a name="IDX1342"></a>
</dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p><code>mode_checkp</code>が <code>true</code>の時、
<code>mode_declare</code>はバインドされた変数のモードをチェックします。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="mode_005fcheck_005ferrorp"></a>
<a name="Item_003a-mode_005fcheck_005ferrorp"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>mode_check_errorp</b>
<a name="IDX1343"></a>
</dt>
<dd><p>デフォルト値: <code>false</code>
</p>
<p><code>mode_check_errorp</code>が <code>true</code>の時、
<code>mode_declare</code>はエラーをコールします。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p>
</dd></dl>

<p><a name="mode_005fcheck_005fwarnp"></a>
<a name="Item_003a-mode_005fcheck_005fwarnp"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>mode_check_warnp</b>
<a name="IDX1344"></a>
</dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p><code>mode_check_warnp</code>が <code>true</code>の時、
モードエラーが記述されます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>


<p><a name="mode_005fdeclare"></a>
<a name="Item_003a-mode_005fdeclare"></a>
</p><dl>
<dt><u>関数:</u> <b>mode_declare</b><i> (<var>y_1</var>, <var>mode_1</var>, &hellip;, <var>y_n</var>, <var>mode_n</var>)</i>
<a name="IDX1345"></a>
</dt>
<dd><p><code>mode_declare</code>は、
その後の関数の翻訳やコンパイルのために変数と関数のモードを宣言するのに使われます。
<code>mode_declare</code>は、通常、
関数定義の始めや Maximaスクリプトの始めに置かれたり、対話プロンプトで実行されたりします。
</p>
<p><code>mode_declare</code>の引数は変数とモードから構成される対です。
モードは <code>boolean</code>, <code>fixnum</code>, <code>number</code>, <code>rational</code>,
<code>float</code>のいずれか１つです。
変数それぞれは同じモードを持つように宣言される変数すべてのリストも取り得ます。
</p>
<p>もし変数が配列で、かつ、参照される配列のすべての要素が値を持つなら、
</p><pre class="example">array(yi, dim1, dim2, ...)
</pre><p>よりむしろ <code>array (yi, complete, dim1, dim2, &hellip;)</code>を
最初に配列のバインドを宣言する時に使うべきです。
もし配列の要素すべてがモード <code>fixnum</code> (<code>float</code>)なら、
<code>complete</code>の代わりに <code>fixnum</code> (<code>float</code>)を使ってください。
もし配列のすべての要素が同じモード― <code>m</code>としましょう―なら、
効率的な翻訳のためには、
</p>
<pre class="example">mode_declare (completearray (yi), m))
</pre>
<p>を使うべきです。
</p>
<p>配列を使う数値コードは、例えば、10 x 10の浮動小数点配列のために
</p>
<pre class="example">mode_declare (completearray (a [10, 10]), float)
</pre>
<p>というように期待される配列サイズを宣言することでより速く実行されるかもしれません
</p>
<p>引数として <code>function (f_1, f_2, ...)</code>を使うことで
関数の結果のモードを宣言することができます;
ここで <code>f_1</code>, <code>f_2</code>, &hellip;は関数名です。
例えば、式
</p>
<pre class="example">mode_declare ([function (f_1, f_2, ...)], fixnum)
</pre>
<p>は <code>f_1</code>, <code>f_2</code>, ...が返す値が1ワード整数であることを宣言します。
</p>
<p><code>modedeclare</code>は <code>mode_declare</code>と同義です。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>


<p><a name="mode_005fidentity"></a>
<a name="Item_003a-mode_005fidentity"></a>
</p><dl>
<dt><u>関数:</u> <b>mode_identity</b><i> (<var>arg_1</var>, <var>arg_2</var>)</i>
<a name="IDX1346"></a>
</dt>
<dd><p><code>mode_declare</code>と <code>macros</code>で、例えば
flonumsのリストのリストや他の合成データオブジェクトを宣言するのに使われる特殊形式。
<code>mode_identity</code>の最初の引数は、
<code>mode_declare</code>に与えられるようなプリミティブな値モード名(すなわち、
<code>float</code>, <code>fixnum</code>, <code>number</code>, <code>list</code>,
<code>any</code>のいずれか)であり、
二番目の引数は評価され、 <code>mode_identity</code>の値として返される式です。
しかし、もし最初の引数で宣言されたモードが戻り値を許していないなら、
エラーか警告をシグナルします。
重要なことは、 Maximaによって Lisp翻訳器に命じた式のモードが、
二番目の引数のなかで続く一切から独立して最初の引数として与えられるそれだということです。
例えば、 <code>x: 3.3; mode_identity (fixnum, x);</code>はエラーをもたらします。
<code>mode_identity (flonum, x)</code>は 3.3を返します。
これは多くの使い道があります。
例えば、もし <code>first (l)</code>が数を返すと知っていたなら、
<code>mode_identity (number, first (l))</code>と書くかもしれません。
しかし、それをするもっと効率的な方法は、
</p>
<pre class="example">firstnumb (x) ::= buildq ([x], mode_identity (number, first(x)));
</pre>
<p>のように新しいプリミティブを定義し、そして数のリストの最初の要素を取る度に
<code>firstnumb</code>を使うことです。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>

<p><a name="remfunction"></a>
<a name="Item_003a-remfunction"></a>
</p><dl>
<dt><u>関数:</u> <b>remfunction</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>remfunction</tt> (<var>f_1</var>, &hellip;, <var>f_n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>remfunction</tt> (all)</i>
<a name="IDX1347"></a>
</dt>
<dd><p>シンボル <var>f_1</var>, ..., <var>f_n</var>の関数定義をアンバインドします。
引数は（<code>:=</code>か <code>define</code>で生成された）通常の関数名か
(<code>::=</code>で生成された)マクロ関数をとります。
</p>
<p><code>remfunction (all)</code>は関数定義すべてをアンバインドします。
</p>
<p><code>remfunction</code>は引数をクォートします。
</p>
<p><code>remfunction</code>は関数定義はアンバインドされたシンボルのリストを返します。
シンボルに関数定義がないなら、シンボルの代わりに <code>false</code>を返します。
</p>
<p><code>remfunction</code>は配列関数すなわち添字付き関数には適用されません。
これらのタイプの関数には <code>remarray</code>を適用します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Function-definition">Function definition</a>
</div>
</p></dd></dl>

<p><a name="Item_003a-savedef"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>savedef</b>
<a name="IDX1348"></a>
</dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p><code>savedef</code>が <code>true</code>の時、
関数が解釈される時に
ユーザー関数の Maximaバージョンが保持されます。
これは、 <code>dispfun</code>が定義を表示することを許し、
関数を編集することを許します。
</p>
<p><code>savedef</code>が <code>false</code>の時、
解釈された関数の名前は <code>functions</code>リストから取り除かれます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p>
</dd></dl>


<p><a name="transcompile"></a>
<a name="Item_003a-transcompile"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>transcompile</b>
<a name="IDX1349"></a>
</dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p><code>transcompile</code>が <code>true</code>の時、
<code>translate</code>と <code>translate_file</code>は
翻訳コードをコンパイルにより適したものにする宣言を生成します。
</p>
<p><code>compfile</code>は実行中 <code>transcompile: true</code>を設定します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="translate"></a>
<a name="Item_003a-translate"></a>
</p><dl>
<dt><u>関数:</u> <b>translate</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>translate</tt> (<var>f_1</var>, &hellip;, <var>f_n</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>translate</tt> (functions) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>translate</tt> (all)</i>
<a name="IDX1350"></a>
</dt>
<dd><p>ユーザー定義関数 <var>f_1</var>, &hellip;, <var>f_n</var>を Maxima言語から Lispに翻訳し、
Lisp翻訳を評価します。
通常、翻訳された関数は元の関数より速く実行されます。
</p>
<p><code>translate (all)</code>や
<code>translate (functions)</code>はユーザー定義関数すべてを翻訳します。
</p>
<p>翻訳される関数は、より効率的なコードを生成するために可能な時は
先頭に <code>mode_declare</code>コールを含むべきです。
例えば:
</p>
<pre class="example">f (x_1, x_2, ...) := block ([v_1, v_2, ...],
    mode_declare (v_1, mode_1, v_2, mode_2, ...), ...)
</pre>


<p>ここで <var>x_1</var>, <var>x_2</var>, ... は関数のパラメータであり、
<var>v_1</var>, <var>v_2</var>, ...はローカル変数です。
</p>
<p>もし <code>savedef</code>が <code>false</code>なら(以下を参照してください)
翻訳された関数の名前は <code>functions</code>リストから削除され、
<code>props</code>リストに加えられます。
</p>
<p>完全にデバッグされない限り、関数は翻訳すべきではありません。
</p>
<p>式は整理されていると仮定されます;
もしされていないなら、厳密ですが最適でないコードが生成されます。
従って、ユーザーは
<code>simp</code>スイッチを <code>false</code>―翻訳される式の整理を抑制します―
に設定すべきではありません。
</p>
<p>スイッチ <code>translate</code>は、もし <code>true</code>なら、
ユーザー関数の Lispへの自動翻訳をもたらします。
</p>
<p>Lispと Maximaのバージョンの間である非互換性が存在する可能性があるので、
翻訳された関数は翻訳前にしたやり方と同一の動作をするわけではないことに注意してください。
原則として、もし変数のいずれかが <code>mode_declare</code>された標準有理式 (CRE)なら
複数の引数を取る <code>rat</code>関数と <code>ratvars</code>関数は使うべきではありません。
また、 <code>prederror: false</code>設定は翻訳されません。
</p>
<p><code>savedef</code> - もし <code>true</code>なら、
関数が <code>translate</code>された時、 Maximaバージョンのユーザー関数を残すようにします。
これは定義を <code>dispfun</code>で表示することを可能にし、関数を編集することを可能にします。
</p>
<p><code>transrun</code> - もし<code>false</code>なら、
すべての関数について翻訳バージョンではなく、
インタープリトされるバージョン(まだあると仮定して)が実行されるようにします。
</p>
<p><code>translate</code>が返す結果は翻訳された関数名のリストです。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>

<p><a name="translate_005ffile"></a>
<a name="Item_003a-translate_005ffile"></a>
</p><dl>
<dt><u>関数:</u> <b>translate_file</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>translate_file</tt> (<var>maxima_filename</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>translate_file</tt> (<var>maxima_filename</var>, <var>lisp_filename</var>)</i>
<a name="IDX1351"></a>
</dt>
<dd><p>Maximaコードのファイルを Lispコードのファイルに翻訳します。
<code>translate_file</code>は３つのファイル名のリストを返します:
Maximaファイル名、 Lispファイル名、翻訳についての追加情報を含むファイル名。
<code>translate_file</code>は引数を評価します。
</p>
<p><code>translate_file (&quot;foo.mac&quot;); load(&quot;foo.LISP&quot;)</code>は、
例えば、 <code>''</code>と <code>%</code>の利用といった若干の制約を除いて、
コマンド <code>batch (&quot;foo.mac&quot;)</code>と同じです。
</p>
<p><code>translate_file (<var>maxima_filename</var>)</code>はMaximaファイル
<var>maxima_filename</var>を同様に名付けらた Lispファイルに翻訳します。
例えば <code>foo.mac</code>は <code>foo.LISP</code>に翻訳されます。
Maximaのファイル名はディレクトリ名を含むかもしれません。
その場合、 Lisp出力ファイルは Maxima入力ファイルと同じディレクトリに書かれます。
</p>
<p><code>translate_file (<var>maxima_filename</var>, <var>lisp_filename</var>)</code>は、
Maximaファイル <var>maxima_filename</var>を Lispファイル
<var>lisp_filename</var>に翻訳します。
<code>translate_file</code>はどんなものでも
<code>lisp_filename</code>のファイル名の拡張子を無視します;
Lisp出力ファイルのファイル名の拡張子はいつも <code>LISP</code>です。
Lispファイル名はディレクトリ名を含むかもしれません。
その場合、 Lisp出力ファイルは指定されたディレクトリに書かれます。
</p>
<p><code>translate_file</code>は
様々な度合いの厳しさの翻訳器警告メッセージのファイルも書き出します。
このファイルのファイル名拡張子は <code>UNLISP</code>です。
翻訳されたコードの中のバグを追跡するために、
このファイルは、あいまいかもしれませんが価値ある情報を含むかもしれません。
<code>UNLISP</code>ファイルはいつも Maxima入力が来るのと同じディレクトリに書かれます。
</p>
<p><code>translate_file</code>は
Lispコードがコンパイルされるすぐに宣言や定義が効力を発揮するようにする
Lispコードを発行します。
このトピックに関してさらに知るには <code>compile_file</code>を参照してください。
</p>
<p align="left"><code>tr_array_as_ref</code>,
<code>tr_bound_function_applyp</code>,
<code>tr_exponent</code>,
<code>tr_file_tty_messagesp</code>,
<code>tr_float_can_branch_complex</code>,
<code>tr_function_call_default</code>,
<code>tr_numer</code>,
<code>tr_optimize_max_loop</code>,
<code>tr_semicompile</code>,
<code>tr_state_vars</code>,
<code>tr_warnings_get</code>,
<code>tr_warn_bad_function_calls</code>,
<code>tr_warn_fexpr</code>,
<code>tr_warn_meval</code>,
<code>tr_warn_mode</code>,
<code>tr_warn_undeclared</code>,
<code>tr_warn_undefined_variable</code>
</p><p>も参照してください。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>

<p><a name="transrun"></a>
<a name="Item_003a-transrun"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>transrun</b>
<a name="IDX1352"></a>
</dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p><code>transrun</code>が <code>false</code>の時、
すべての関数について、翻訳バージョンではなく、
インタープリトされるバージョン(まだあると仮定して)が実行されるようにします。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>


<p><a name="tr_005farray_005fas_005fref"></a>
<a name="Item_003a-tr_005farray_005fas_005fref"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_array_as_ref</b>
<a name="IDX1353"></a>
</dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p>もし <code>translate_fast_arrays</code>が <code>false</code>なら、
<code>translate_file</code>が発行する Lispコードの中の配列参照は、
<code>tr_array_as_ref</code>に影響されます。
<code>tr_array_as_ref</code>が <code>true</code>の時、配列名は評価されます。
そうでないなら 配列名は翻訳されたコードの中で文字リテラルとして現れます。
</p>
<p>もし <code>translate_fast_arrays</code>が <code>true</code>なら、
<code>tr_array_as_ref</code>は効果を持ちません。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>


<p><a name="tr_005fbound_005ffunction_005fapplyp"></a>
<a name="Item_003a-tr_005fbound_005ffunction_005fapplyp"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_bound_function_applyp</b>
<a name="IDX1354"></a>
</dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p><code>tr_bound_function_applyp</code>が <code>true</code>の時、
もし(関数引数のような)バインドされた変数が関数として使われていることが見つかったら
Maximaは警告を与えます。
<code>tr_bound_function_applyp</code>はそんな場合に生成されたコードに影響しません。
</p>
<p>例えば <code>g (f, x) := f (x+1)</code>のような式は警告メッセージをトリガーします。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005ffile_005ftty_005fmessage"></a>
<a name="Item_003a-tr_005ffile_005ftty_005fmessagesp"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_file_tty_messagesp</b>
<a name="IDX1355"></a>
</dt>
<dd><p>デフォルト値: <code>false</code>
</p>
<p><code>tr_file_tty_messagesp</code>が <code>true</code>の時、
ファイルの翻訳中に
<code>translate_file</code>が生成するメッセージがコンソールに表示され、
<code>false</code>の時、ファイルの翻訳に関するメッセージは
UNLISPファイルに挿入されるだけです。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>


<p><a name="tr_005ffloat_005fcan_005fbranch_005fcomplex"></a>
<a name="Item_003a-tr_005ffloat_005fcan_005fbranch_005fcomplex"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_float_can_branch_complex</b>
<a name="IDX1356"></a>
</dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p>Maxima-to-Lisp翻訳器に関数<code>acos</code>, <code>asin</code>, <code>asec</code>,
<code>acsc</code>が複素数の結果を返すことができることを仮定するように命じます。
</p>
<p><code>tr_float_can_branch_complex</code>の表面上の効果は以下の通りです。
しかし、このフラグは翻訳器出力上の効果を持ちません。
</p>
<p><code>true</code>の時、たとえ (<code>mode_declare</code>が設定したように) <code>x</code>がモード
<code>float</code>でも<code>acos(x)</code>はモード <code>any</code>です。
<code>false</code>の時、 <code>x</code>がモード <code>float</code>の時だけ
<code>acos(x)</code>はモード <code>float</code>です。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005ffunction_005fcall_005fdefault"></a>
<a name="Item_003a-tr_005ffunction_005fcall_005fdefault"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_function_call_default</b>
<a name="IDX1357"></a>
</dt>
<dd><p>デフォルト値: <code>general</code>
</p>
<p><code>false</code>はあきらめて <code>meval</code>をコールすることを意味し、
<code>expr</code>は引数が固定された Lisp関数を仮定することを意味します。
デフォルトである<code>general</code>は
<code>mexprs</code>や <code>mlexprs</code>にはよいが <code>macros</code>にはよくないコードを与えます。
<code>general</code>はコンパイルされたコードの中で変数バインドが正確であることを保証します。
<code>general</code>モードでは、 F(X)を翻訳する時、もし Fがバインドされた変数なら
<code>apply (f, [x])</code>を意味すると仮定され、適切な警告と合わせてそのように翻訳されます。
これをオフにする必要はありません。
デフォルト設定で警告メッセージがないことは、
Maximaインタープリタと、翻訳、コンパイルされたコードの完全互換性を意味します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005fnumer"></a>
<a name="Item_003a-tr_005fnumer"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_numer</b>
<a name="IDX1358"></a>
</dt>
<dd><p>デフォルト値: <code>false</code>
</p>
<p><code>tr_numer</code>が<code>true</code>の時、
<code>numer</code>プロパティはそれらを持つアトム、例えば <code>%pi</code>に使われます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005foptimize_005fmax_005floop"></a>
<a name="Item_003a-tr_005foptimize_005fmax_005floop"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_optimize_max_loop</b>
<a name="IDX1359"></a>
</dt>
<dd><p>デフォルト値: 100
</p>
<p><code>tr_optimize_max_loop</code>は、
翻訳器のマクロ展開と最適化パスが形式を検討する際繰り返す最大回数です。
これはマクロ展開エラーや終了しない最適化プロパティをキャッチします。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005fsemicompile"></a>
<a name="Item_003a-tr_005fsemicompile"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_semicompile</b>
<a name="IDX1360"></a>
</dt>
<dd><p>デフォルト値: <code>false</code>
</p>
<p><code>tr_semicompile</code>が <code>true</code>の時、
<code>translate_file</code>と <code>compfile</code>は、マクロ展開されたが
Lispコンパイラによって機械語にコンパイルされない形式を出力します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p>
</dd></dl>


<p><a name="tr_005fstate_005fvars"></a>
<a name="Item_003a-tr_005fstate_005fvars"></a>
</p><dl>
<dt><u>システム変数:</u> <b>tr_state_vars</b>
<a name="IDX1361"></a>
</dt>
<dd><p>デフォルト値:
</p><pre class="example">[transcompile, tr_semicompile, tr_warn_undeclared, tr_warn_meval,
tr_warn_fexpr, tr_warn_mode, tr_warn_undefined_variable,
tr_function_call_default, tr_array_as_ref,tr_numer]
</pre>
<p>翻訳された出力の形式に影響するスイッチのリスト。
翻訳器をデバッグしようとする時、この情報はシステムの人たちに役に立ちます。
翻訳された生成物を与えられた状態で生成されるべきだったものと比較することによって、
バグを追跡することが可能です。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p>
</dd></dl>


<p><a name="tr_005fwarnings_005fget"></a>
<a name="Item_003a-tr_005fwarnings_005fget"></a>
</p><dl>
<dt><u>関数:</u> <b>tr_warnings_get</b><i> ()</i>
<a name="IDX1362"></a>
</dt>
<dd><p>現在の翻訳の間に翻訳器が与える警告のリストを印字します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>

<p><a name="Item_003a-tr_005fwarn_005fbad_005ffunction_005fcalls"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_warn_bad_function_calls</b>
<a name="IDX1363"></a>
</dt>
<dd><p>デフォルト値: <code>true</code>
</p>
<p>- 翻訳時にされた不適切な宣言のせいで正確でないかもしれない関数コールが行われている時、
警告を与えます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005fwarn_005ffexpr"></a>
<a name="Item_003a-tr_005fwarn_005ffexpr"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_warn_fexpr</b>
<a name="IDX1364"></a>
</dt>
<dd><p>デフォルト値: <code>compfile</code>
</p>
<p>- もしFEXPRに遭遇したら、警告を与えます。
FEXPRは、通常、翻訳コードの中で出力すべきではありません。
合法で特殊なプログラム形式はすべて翻訳されます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005fwarn_005fmeval"></a>
<a name="Item_003a-tr_005fwarn_005fmeval"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_warn_meval</b>
<a name="IDX1365"></a>
</dt>
<dd><p>デフォルト値: <code>compfile</code>
</p>
<p>- もし関数 <code>meval</code>がコールされたら、警告を与えます。
もし <code>meval</code>がコールされたら、それは翻訳の中の問題を示唆します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005fwarn_005fmode"></a>
<a name="Item_003a-tr_005fwarn_005fmode"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_warn_mode</b>
<a name="IDX1366"></a>
</dt>
<dd><p>デフォルト値: <code>all</code>
</p>
<p>- 変数がそのモードに不適切な値を割り当てられた時、警告を与えます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005fwarn_005fundeclared"></a>
<a name="Item_003a-tr_005fwarn_005fundeclared"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_warn_undeclared</b>
<a name="IDX1367"></a>
</dt>
<dd><p>デフォルト値: <code>compile</code>
</p>
<p>- 未宣言変数についての警告をいつ TTYに送るかを決めます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="tr_005fwarn_005fundefined_005fvariable"></a>
<a name="Item_003a-tr_005fwarn_005fundefined_005fvariable"></a>
</p><dl>
<dt><u>オプション変数:</u> <b>tr_warn_undefined_variable</b>
<a name="IDX1368"></a>
</dt>
<dd><p>デフォルト値: <code>all</code>
</p>
<p>- 未定義のグローバル変数が見られた時、警告を与えます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-flags-and-variables">Translation flags and variables</a>
</div>
</p></dd></dl>

<p><a name="compile_005ffile"></a>
<a name="Item_003a-compile_005ffile"></a>
</p><dl>
<dt><u>関数:</u> <b>compile_file</b><i> &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>compile_file</tt> (<var>filename</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>compile_file</tt> (<var>filename</var>, <var>compiled_filename</var>) &nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;<tt>compile_file</tt> (<var>filename</var>, <var>compiled_filename</var>, <var>lisp_filename</var>)</i>
<a name="IDX1369"></a>
</dt>
<dd><p>Maximaファイル <var>filename</var>を Lispに翻訳し、 Lispコンパイラを実行し、
もし翻訳とコンパイルが成功したら、コンパイルされたコードを Maximaにロードします。
</p>
<p><code>compile_file</code>は４つのファイル名のリストを返します:
元の Maximaファイル、 Lisp翻訳、翻訳時ノート、コンパイルされたコード。
もしコンパイルが失敗したら、4番目の項目は <code>false</code>です。
</p>
<p>Lispコードがコンパイルされると(コンパイルされたコードをロードすることなしに)すぐに
いくつかの宣言と定義は効力を発揮します。
これらは <code>:=</code>演算子で定義された関数、
<code>::=</code>演算子で定義されたマクロ、
<code>alias</code>, <code>declare</code>,
<code>define_variable</code>,  <code>mode_declare</code>,
<code>infix</code>, <code>matchfix</code>,
<code>nofix</code>, <code>postfix</code>, <code>prefix</code>,
<code>compfile</code>
を含みます。
</p>
<p>コンパイルされたコードがロードされるまで
割り当てと関数コールは評価されません。
特に、 Maximaファイルの中で
(<code>tr_numer</code>, など)翻訳フラグへの割り当ては翻訳時に効果を持ちません。
</p>

<p><var>filename</var>は <code>:lisp</code>文を含むことができません。
</p>
<p><code>compile_file</code>は引数を評価します。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>


<p><a name="declare_005ftranslated"></a>
<a name="Item_003a-declare_005ftranslated"></a>
</p><dl>
<dt><u>関数:</u> <b>declare_translated</b><i> (<var>f_1</var>, <var>f_2</var>, &hellip;)</i>
<a name="IDX1370"></a>
</dt>
<dd><p>Maximaコードのファイルを Lispに翻訳する時、
ファイルの中で見る関数が翻訳された関数としてコールされるか、
コンパイルされた関数としてコールされるか、
また、どの関数が Maxima関数か未定義なのか、翻訳器が知ることが重要です。
この宣言をファイルの先頭に置くと、
翻訳器は、
Lisp関数値をまだ持たないシンボルがコール時には持つだろうということを知ります．
(Putting this declaration at the top of the file, lets it know that although a symbol does which does not yet have a Lisp function value, will have one at call time.)
<code>fn</code>が Lisp関数になるつもりであることを翻訳器が知らない時、
<code>(MFUNCTION-CALL fn arg1 arg2 ...)</code>が生成されます。
</p>
<div class=categorybox>

<p>Categories:&nbsp;&nbsp;<a href="maxima_100.html#Category_003a-Translation-and-compilation">Translation and compilation</a>
</div>
</p></dd></dl>

<p><a name="Item_003a-Program-Flow"></a>
</p><hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC194" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_37.html#SEC201" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  この文書は<em>市川 雄二</em>によって<em>5月, 20 2015</em>に<a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>を用いて生成されました。
 </font>
 <br>

</p>
</body>
</html>
