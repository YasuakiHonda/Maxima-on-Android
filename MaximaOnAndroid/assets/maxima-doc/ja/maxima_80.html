<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on 5月, 20 2015 by texi2html 1.76 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Maxima 5.36.1 Manual: 80. to_poly_solve</title>

<meta name="description" content="Maxima 5.36.1 Manual: 80. to_poly_solve">
<meta name="keywords" content="Maxima 5.36.1 Manual: 80. to_poly_solve">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.76">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.sansserif {font-family:sans-serif; font-weight:normal;}
ul.toc {list-style: none}
body {color: black; background: white;  margin-left: 8%; margin-right: 13%;
      font-family: "FreeSans", sans-serif}
h1 {font-size: 150%; font-family: "FreeSans", sans-serif}
h2 {font-size: 125%; font-family: "FreeSans", sans-serif}
h3 {font-size: 100%; font-family: "FreeSans", sans-serif}
a[href] {color: rgb(0,0,255); text-decoration: none;}
a[href]:hover {background: rgb(220,220,220);}
div.textbox {border: solid; border-width: thin; padding-top: 1em;
    padding-bottom: 1em; padding-left: 2em; padding-right: 2em}
div.titlebox {border: none; padding-top: 1em; padding-bottom: 1em;
    padding-left: 2em; padding-right: 2em; background: rgb(200,255,255);
    font-family: sans-serif}
div.synopsisbox {
    border: none; padding-top: 1em; padding-bottom: 1em; padding-left: 2em;
    padding-right: 2em; background: rgb(255,220,255);}
pre.example {border: 1px solid rgb(180,180,180); padding-top: 1em;
    padding-bottom: 1em; padding-left: 1em; padding-right: 1em;
    background-color: rgb(238,238,255)}
div.spacerbox {border: none; padding-top: 2em; padding-bottom: 2em}
div.image {margin: 0; padding: 1em; text-align: center}
div.categorybox {border: 1px solid gray; padding-top: 0px; padding-bottom: 0px;
    padding-left: 1em; padding-right: 1em; background: rgb(247,242,220)}

-->
</style>

<link rel="icon" href="figures/favicon.ico"/>

<script type="text/javascript"><!--

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-510249-14']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

--></script>
</head>

<body lang="ja" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="to_005fpoly_005fsolve"></a>
<a name="SEC379"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="maxima_79.html#SEC378" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC380" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima_79.html#SEC374" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC381" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h1 class="chapter"> 80. to_poly_solve </h1>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top"><a href="#SEC380">80.1 Functions and Variables for to_poly_solve</a></td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p><a name="Item_003a-Functions-and-Variables-for-to_005fpoly_005fsolve"></a>
</p><hr size="6">
<a name="Functions-and-Variables-for-to_005fpoly_005fsolve"></a>
<a name="SEC380"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC379" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC381" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="#SEC379" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="#SEC379" title="Up section">上</a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC381" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<h2 class="section"> 80.1 Functions and Variables for to_poly_solve </h2>

<p>パッケージ <code>to_poly</code>と <code>to_poly_solve</code>は実験的なものです;
これらのパッケージの関数の仕様は変更の可能性があり、
これらのパッケージの関数のいくつかは他の Maxima関数にマージされるかもしれません。
</p>
<p>Barton Willis (University of Nebraska at Kearneyの数学科の教授)が
<code>to_poly</code>と <code>to_poly_solve</code>パッケージと
これらのパッケージのための英語のユーザードキュメンテーションを書きました。
</p>
<p><a name="Item_003a-_0025and"></a>
</p><dl>
<dt><u>Operator:</u> <b>%and</b>
<a name="IDX2462"></a>
</dt>
<dd><p>演算子 <code>%and</code>は整理化(simplifying)非短絡論理積です。
Maximaは <code>%and</code>式を trueか falseか論理的に同値ですが整理された式に整理します。
演算子 <code>%and</code>は結合的で可換でべき等的です。
そして、 <code>%and</code>が名詞形を返す時、
<code>%and</code>の引数は非冗長なソートされたリストを形成します;
例えば、
</p>
<pre class="example">(%i1) a %and (a %and b);
(%o1)                       a %and b
</pre>
<p>もし積の引数の1つが <i>明示的に</i>もう一つの引数の否定なら、
<code>%and</code>は falseを返します:
</p>
<pre class="example">(%i2) a %and (not a);
(%o2)                         false
</pre>
<p>積のいずれかのメンバーが falseなら、
たとえ他のメンバーが明白に非ブーリアンでも積は falseに整理されます;
例えば、
</p>
<pre class="example">(%i3) 42 %and false;
(%o3)                         false
</pre>
<p>inequation(すなわち、不等もしくは等式)の <code>%and</code>式の任意の引数は
Fourier消去パッケージを使って整理されます。
Fourier消去整理器は
すべてでないですがいくつかの非線形 inequationを線形
inequationに変換するプリプロセッサを持ちます;
例えば、 Fourier消去コードは
<code>abs(x) + 1 &gt; 0</code>を trueに整理します。だから、
</p>
<pre class="example">(%i4) (x &lt; 1) %and (abs(x) + 1 &gt; 0);
(%o4)                         x &lt; 1
</pre>
<p><b>注釈</b>  
</p><ul>
<li>
オプション変数 <code>prederror</code>は
<code>%and</code>式の整理を変え<i>ません</i>。

</li><li>
演算子の優先順位エラーを避けるため、
演算子 <code>%and, %or</code>と <code>not</code>を含む複合式は完全に括弧でくくらなくてはいけません。

</li><li>
Maxima演算子 <code>and</code>と <code>or</code>はどちらも短絡的です。
なので <code>and</code>は結合的でなかったり可換ではなかったりします。

</li></ul>

<p><b>制限</b> 積 <code>%and</code>はinequationを
<i>大域的にではなく局所的に</i>整理します。
これは以下のような積は falseに整理<i>されない</i>ことを意味します。
</p>
<pre class="example">(%i5) (x &lt; 1) %and (x &gt; 1);
(%o5)                 (x &gt; 1) %and (x &lt; 1)
</pre>
<p>また、 Fourier消去コードは事実データベースを<i>無視します</i>。
</p>
<pre class="example">(%i6) assume(x &gt; 5);
(%o6)                        [x &gt; 5]
(%i7) (x &gt; 1) %and (x &gt; 2);
(%o7)                 (x &gt; 1) %and (x &gt; 2)
</pre>
<p>最終的に、同値の線形 inequationに容易に変換されない非線形 inequationは整理されません。
</p>
<p><code>%or</code>上に <code>%and</code>を分配するためのサポートはありません;
<code>%and</code>上に論理否定を分配するサポートもありません。
</p>
<p><b>利用のためには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>関連関数</b> <code>%or, %if, and, or, not</code>
</p>
<p><b>状況</b> 演算子 <code>%and</code>は実験的です;
この関数の仕様は変更の可能性があり、
その機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-_0025if"></a>
</p><dl>
<dt><u>演算子:</u> <b>%if</b><i> (<var>bool</var>, <var>a</var>, <var>b</var>)</i>
<a name="IDX2463"></a>
</dt>
<dd><p>演算子 <code>%if</code>は整理化条件文です。
<i>条件</i> <var>bool</var>はブーリアン値でなければいけません。
条件が trueの時、二番目の引数を返します;
条件が falseの時、三番目の引数を返します;
その他の場合、名詞形を返します。
</p>
<p>Maxima inequations (不等式か等式)はブーリアン値では<i>ありません</i>;
例えば、 Maximaは <em>5 &lt; 6</em>を trueに整理 <i>しません</i>し、
<em>5 = 6</em>を falseに整理しません;
しかしながら、 <code>%if</code>文への条件の文脈では、
Maximaは <i>自動的に</i> inequationの真値を決定しようとします。
例:
</p>
<pre class="example">(%i1) f : %if(x # 1, 2, 8);
(%o1)                 %if(x - 1 # 0, 2, 8)
(%i2) [subst(x = -1,f), subst(x=1,f)];
(%o2)                        [2, 8]
</pre>
<p>もし条件が inequationを含むなら、
Maximaは Fourier消去パッケージを使ってそれを整理します。
</p>
<p><b>注釈</b> 
</p>
<ul>
<li>
もし条件が明白に非ブーリアンなら、 Maximaは名詞形を返します:
</li></ul>

<pre class="example">(%i3) %if(42,1,2);
(%o3)                     %if(42, 1, 2)
</pre>
<ul>
<li>
Maxima演算子 <code>if</code>は n項演算子ですが、演算子 <code>%if</code>は
n項演算子<i>ではないです</i>。
</li></ul>

<p><b>制限</b> Fourier消去コードは
同値の線形 inequationに容易に変換可能な非線形 inequationだけを
整理します。
</p>
<p><b>利用には:</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況:</b> 演算子 <code>%if</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>
  
<p><a name="Item_003a-_0025or"></a>
</p><dl>
<dt><u>演算子:</u> <b>%or</b>
<a name="IDX2464"></a>
</dt>
<dd><p>演算子 <code>%or</code>は整理化非短絡論理和です。
Maximaは
<code>%or</code>式を trueか falseか論理的に同値ですが整理された式に整理します。
演算子 <code>%or</code>は結合的で可換でべき等です。
そして
<code>%or</code>が名詞形を返す時、
<code>%or</code>の引数は非冗長なソートされたリストを形成します;
例えば、
</p>
<pre class="example">(%i1) a %or (a %or b);
(%o1)                        a %or b
</pre>
<p>もし和のメンバーの１つが<i>明示的に</i>他のメンバーの否定なら、
<code>%or</code>は trueを返します:
</p>
<pre class="example">(%i2) a %or (not a);
(%o2)                         true
</pre>
<p>もし和の任意のメンバーが trueなら、
たとえ和の他のメンバーが明白に非ブーリアンでも和は trueに整理されます。
例えば
</p>
<pre class="example">(%i3) 42 %or true;
(%o3)                         true
</pre>
<p>inequation(不等式か等式)である <code>%or</code>式の任意の引数は
Fourier消去パッケージを使って整理されます。
Fourier消去コードは <code>abs(x) + 1 &gt; 0</code>を trueに整理します。
なので、
</p>
<pre class="example">(%i4) (x &lt; 1) %or (abs(x) + 1 &gt; 0);
(%o4)                         true
</pre>
<p><b>注釈</b>  
</p><ul>
<li>
オプション変数 <code>prederror</code>は
<code>%or</code>式の整理を変更<i>しません</i>。

</li><li>
演算子 <code>%and, %or</code>, <code>not</code>を含む複合式は括弧でくくらなければいけません;
これらの演算子の結合力は期待と一致しないことがあります。

</li><li>
Maxima演算子 <code>and</code>と <code>or</code>はどちらも短絡的です。
なので <code>or</code>は結合的でないか可換でないかです。

</li></ul>

<p><b>制限</b> 和 <code>%or</code>はinequationを
<i>大域的にではなく、局所的に</i>整理します。
これは以下のような和は trueに整理<i>されない</i>ことを意味します。
</p>

<pre class="example">(%i1) (x &lt; 1) %or (x &gt;= 1);
(%o1) (x &gt; 1) %or (x &gt;= 1)
</pre>
<p>更に Fourier消去コードは事実データベースを無視します:
</p>
<pre class="example">(%i2) assume(x &gt; 5);
(%o2)                        [x &gt; 5]
(%i3) (x &gt; 1) %and (x &gt; 2);
(%o3)                 (x &gt; 1) %and (x &gt; 2)
</pre>
<p>最終的に、同値の線形 inequationに容易に変換されない非線形 inequationは整理されません。
</p>
<p>両方とも falseである項を探すアルゴリズムは弱いものです;
また、<code>%and</code>上に <code>%or</code>を分配するためのサポートはありません;
<code>%or</code>上に論理否定を分配するサポートもありません。
</p>
<p><b>利用のためには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>関連関数</b> <code>%or, %if, and, or, not</code>
</p>
<p><b>状況</b> 演算子 <code>%or</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-complex_005fnumber_005fp"></a>
</p><dl>
<dt><u>関数:</u> <b>complex_number_p</b><i> (<var>x</var>)</i>
<a name="IDX2465"></a>
</dt>
<dd><p>もし引数が
<code>a + %i * b</code>, <code>a</code>, <code>%i b</code>, <code>%i</code>のいずれかなら、
述語論理 <code>complex_number_p</code>は trueを返します。
ここで <code>a</code>と <code>b</code>は有理数か(多倍長浮動小数点数を含む)浮動小数点数です;
他のすべての入力に対して、
<code>complex_number_p</code>は falseを返します; 例えば
</p>
<pre class="example">(%i1) map('complex_number_p,[2/3, 2 + 1.5 * %i, %i]);
(%o1)                  [true, true, true]
(%i2) complex_number_p((2+%i)/(5-%i));
(%o2)                         false
(%i3) complex_number_p(cos(5 - 2 * %i));
(%o3)                         false
</pre>
<p><b>関連関数</b> <code>isreal_p</code>
</p>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況</b> 関数 <code>complex_number_p</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-compose_005ffunctions"></a>
</p><dl>
<dt><u>関数:</u> <b>compose_functions</b><i> (<var>l</var>)</i>
<a name="IDX2466"></a>
</dt>
<dd><p>関数コール <code>compose_functions(l)</code>は
リスト <var>l</var>の中の関数の合成をラムダ形を返します。
関数は<i>右</i>から <i>左</i>へ適用されます; 例えば
</p>
<pre class="example">(%i1) compose_functions([cos, exp]);
                                        %g151
(%o1)             lambda([%g151], cos(%e     ))
(%i2) %(x);
                                  x
(%o2)                       cos(%e )
</pre>
<p>関数リストが空のとき、恒等関数を返します:
</p>
<pre class="example">(%i3) compose_functions([]);
(%o3)                lambda([%g152], %g152)
(%i4)  %(x);
(%o4)                           x
</pre>
<p><b>注釈</b> 
</p><ul>
<li>
Maximaがリストメンバーがシンボルやラムダ形でないか決める時、
(<code>compose_functions</code><i>ではなく</i>) <code>funmake</code>がエラーをシグナルします:
</li></ul>

<pre class="example">(%i5) compose_functions([a &lt; b]);

funmake: first argument must be a symbol, subscripted symbol,
string, or lambda expression; found: a &lt; b
#0: compose_functions(l=[a &lt; b])(to_poly_solve.mac line 40)
 -- an error. To debug this try: debugmode(true);
</pre>
<ul>
<li>
名前の衝突を避けるために、独立変数は関数 <code>new_variable</code>が決めます。

<pre class="example">(%i6) compose_functions([%g0]);
(%o6)              lambda([%g154], %g0(%g154))
(%i7) compose_functions([%g0]);
(%o7)              lambda([%g155], %g0(%g155))
</pre>
<p>独立変数が違っても、
Maximaはこれらのラムダ形が意味的に等しいことを演繹できます:
</p>
<pre class="example">(%i8) is(equal(%o6,%o7));
(%o8)                         true
</pre></li></ul>

<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況</b> 関数 <code>compose_functions</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p></dd></dl>

<p><a name="Item_003a-dfloat"></a>
</p><dl>
<dt><u>関数:</u> <b>dfloat</b><i> (<var>x</var>)</i>
<a name="IDX2467"></a>
</dt>
<dd><p>関数 <code>dfloat</code>は
<code>float</code>に似ていますが、
<code>float</code>が IEEE 倍精度浮動小数点数に評価するのを失敗した時、
関数 <code>dfloat</code>は
<code>rectform</code>を適用します; 例えば
</p>
<pre class="example">(%i1) float(4.5^(1 + %i));
                               %i + 1
(%o1)                       4.5
(%i2) dfloat(4.5^(1 + %i));
(%o2)        4.48998802962884 %i + .3000124893895671
</pre>
<p><b>注釈</b> 
</p>
<ul>
<li>
式の直交形は
数値評価には不完全で合わないかもしれません-例えば、
直交形は不必要に浮動小数点数の差(桁落ち)を含むかもしれません。

</li><li>
識別子 <code>float</code>は(デフォルト値が falseの)オプション変数であり
かつ関数名です。

</li></ul>

<p><b>関連関数</b> <code>float, bfloat</code>
</p>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況</b> 関数 <code>dfloat</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-elim"></a>
</p><dl>
<dt><u>関数:</u> <b>elim</b><i> (<var>l</var>, <var>x</var>)</i>
<a name="IDX2468"></a>
</dt>
<dd><p>関数 <code>elim</code>は
集合もしくはリスト <code>l</code>内の等式から
集合もしくはリスト <code>x</code>内の変数を消去します。
<code>x</code>のメンバーそれぞれはシンボルでなければいけません;
<code>l</code>のメンバーは等式か零に等しいと仮定される式であり得ます。
</p>
<p>関数 <code>elim</code>は2つのリストのリストを返します;
一番目は変数が消去された式のリストです;
二番目はピボットのリストです;
二番目のリストは
<code>elim</code>が変数を消去するのに使った式のリストです。
</p>
<p>以下は線形方程式を消去する例です:
</p>
<pre class="example">(%i1) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1), 
           set(x,y));
(%o1)            [[2 z - 7], [y + 7, z - x + 1]]
</pre>
<p><code>x</code>と <code>y</code>の消去は一つの等式 <code>2 z - 7 = 0</code>をもたらします;
等式 <code>y + 7 = 0</code>と <code>z - z + 1 = 1</code>がピボットとして使われました。
これらの等式から3つの変数すべての消去は、線形系を三角化します:
</p>
<pre class="example">(%i2) elim(set(x + y + z = 1, x - y  - z = 8, x - z = 1),
           set(x,y,z));
(%o2)           [[], [2 z - 7, y + 7, z - x + 1]]
</pre>
<p>もちろん、等式は線形である必要はありません:
</p>
<pre class="example">(%i3) elim(set(x^2 - 2 * y^3 = 1,  x - y = 5), [x,y]);
                     3    2
(%o3)       [[], [2 y  - y  - 10 y - 24, y - x + 5]]
</pre>
<p>ユーザーは変数が消去される順序を制御しません。
確かに、アルゴリズムは最良のピボットと最良の消去順序を選ぼうとする発見的方法を使います。
</p>
<p><b>注釈</b> 
</p>
<ul>
<li>
関連関数 <code>eliminate</code>と違い、等式の数が変数の数と等しい時、関数 <code>elim</code>は
<code>solve</code>を呼び出し<i>ません</i>。

</li><li>
関数 <code>elim</code>は終結式を適用することで機能します;
オプション変数 <code>resultant</code>は
Maximaがどのアルゴリズムを使うか決めます。
<code>sqfr</code>を使って、
Maximaはそれぞれの終結式を因数分解し、多重零点を抑制します。

</li><li>
<code>elim</code>は多項式方程式の非線形一式を三角化します;
三角化された集合の解集合は
三角化されていない集合の解集合よりも大きい<i>かもしれません</i>。
例えば、、
三角化された方程式は<i>見せかけの</i>解を持ち得ます。
</li></ul>

<p><b>関連関数</b> <i>elim_allbut, eliminate_using, eliminate</i>
</p>
<p><b>オプション変数</b> <i>resultant</i>
</p>
<p><b>利用するには</b> <tt>`load(to_poly)'</tt>
</p>
<p><b>状況</b> 関数 <code>elim</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>
 
<p><a name="Item_003a-elim_005fallbut"></a>
</p><dl>
<dt><u>関数:</u> <b>elim_allbut</b><i> (<var>l</var>, <var>x</var>)</i>
<a name="IDX2469"></a>
</dt>
<dd><p>この関数は、
等式のリスト <code>l</code>内のリスト
<code>x</code>内の変数を <i>除いて</i>変数すべてを消去することを除いて、
<code>elim</code>に似ています。
</p>
<pre class="example">(%i1) elim_allbut([x+y = 1, x - 5*y = 1],[]);
(%o1)                 [[], [y, y + x - 1]]
(%i2) elim_allbut([x+y = 1, x - 5*y = 1],[x]);
(%o2)                [[x - 1], [y + x - 1]]
</pre>
<p><b>利用するには</b> <tt>`load(to_poly)'</tt>
</p>
<p><b>オプション変数</b> <i>resultant</i>
</p>
<p><b>関連関数</b> <i>elim, eliminate_using, eliminate</i>
</p>
<p><b>状況</b> 関数 <code>elim_allbut</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-eliminate_005fusing"></a>
</p><dl>
<dt><u>関数:</u> <b>eliminate_using</b><i> (<var>l</var>, <var>e</var>, <var>x</var>)</i>
<a name="IDX2470"></a>
</dt>
<dd><p><code>e</code>をピボットとして使って、
<code>l</code>の中の等式のリストか集合からシンボル <code>x</code>を消去します。
関数 <code>eliminate_using</code>は集合を返します。
</p>
<pre class="example">(%i1) eq : [x^2 - y^2 - z^3 , x*y - z^2 - 5, x - y + z];
               3    2    2     2
(%o1)      [- z  - y  + x , - z  + x y - 5, z - y + x]
(%i2) eliminate_using(eq,first(eq),z);
        3              2      2      3    2
(%o2) {y  + (1 - 3 x) y  + 3 x  y - x  - x , 
                        4    3  3       2  2             4
                       y  - x  y  + 13 x  y  - 75 x y + x  + 125}
(%i3) eliminate_using(eq,second(eq),z);
        2            2       4    3  3       2  2             4
(%o3) {y  - 3 x y + x  + 5, y  - x  y  + 13 x  y  - 75 x y + x
                                                           + 125}
(%i4) eliminate_using(eq, third(eq),z);
        2            2       3              2      2      3    2
(%o4) {y  - 3 x y + x  + 5, y  + (1 - 3 x) y  + 3 x  y - x  - x }
</pre>
<p><b>オプション変数</b> <i>resultant</i>
</p>
<p><b>関連関数</b> <i>elim, eliminate, elim_allbut</i>
</p>
<p><b>利用するには</b> <tt>`load(to_poly)'</tt>
</p>
<p><b>状況</b> 関数 <code>elimimate_using</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-fourier_005felim"></a>
</p><dl>
<dt><u>関数:</u> <b>fourier_elim</b><i> ([<var>eq1</var>, <var>eq2</var>, &hellip;], [<var>var1</var>, <var>var</var>, &hellip;])</i>
<a name="IDX2471"></a>
</dt>
<dd><p>Fourier消去は
Gauss消去の線形 inequation(等式か不等式)に関する類似物です。
関数コール <code>fourier_elim([eq1, eq2, ...], [var1, var2, ...])</code>は
線形 inequationsのリスト <code>[eq1, eq2, ...]</code>上の変数
<code>[var1, var2, ...]</code>に関する Fourier消去です;
例えば
</p>
<pre class="example">(%i1) fourier_elim([y-x &lt; 5, x - y &lt; 7, 10 &lt; y],[x,y]);
(%o1)            [y - 5 &lt; x, x &lt; y + 7, 10 &lt; y]
(%i2) fourier_elim([y-x &lt; 5, x - y &lt; 7, 10 &lt; y],[y,x]);
(%o2)        [max(10, x - 7) &lt; y, y &lt; x + 5, 5 &lt; x]
</pre>
<p>最初に <em>x</em>を、次に <em>y</em>を消去することは
<em>x</em>の下限と上限―<em>y</em>に依存します―をもたらし、
そして <em>y</em>の下限と上限ーそれらは数ですーをもたらします。
他の順序での消去は <em>x</em>依存の <em>y</em>の下限と上限、
そして <em>x</em>の数値的下限と上限を与えます。
</p>
<p>必要な時、 <code>fourier_elim</code>は inequationのリストの<em>論理和</em>を返します:
</p>
<pre class="example">(%i3) fourier_elim([x # 6],[x]);
(%o3)                  [x &lt; 6] or [6 &lt; x]
</pre>
<p>解集合が空の時、 <code>fourier_elim</code>は <code>emptyset</code>を返し、
解集合が実数すべての時、 <code>fourier_elim</code>は <code>universalset</code>を返します;
例えば
</p>
<pre class="example">(%i4) fourier_elim([x &lt; 1, x &gt; 1],[x]);
(%o4)                       emptyset
(%i5) fourier_elim([minf &lt; x, x &lt; inf],[x]);
(%o5)                     universalset
</pre>
<p>非線形 inequationに対して、
<code>fourier_elim</code>は(幾分)整理された inequationsのリストを返します:
</p>
<pre class="example">(%i6) fourier_elim([x^3 - 1 &gt; 0],[x]);
               2                             2
(%o6) [1 &lt; x, x  + x + 1 &gt; 0] or [x &lt; 1, - (x  + x + 1) &gt; 0]
(%i7) fourier_elim([cos(x) &lt; 1/2],[x]);
(%o7)                  [1 - 2 cos(x) &gt; 0]
</pre>
<p>inequationのリストの代わりに、
<code>fourier_elim</code>の一番目の引数は論理和か論理積であるかもしれません:
</p>
<pre class="example">(%i8) fourier_elim((x + y &lt; 5) and (x - y &gt;8),[x,y]);
                                              3
(%o8)            [y + 8 &lt; x, x &lt; 5 - y, y &lt; - -]
                                              2
(%i9) fourier_elim(((x + y &lt; 5) and x &lt; 1) or  (x - y &gt;8),[x,y]);
(%o9)          [y + 8 &lt; x] or [x &lt; min(1, 5 - y)]
</pre>
<p>関数 <code>fourier_elim</code>は
inequation演算子 <code>&lt;, &lt;=, &gt;, &gt;=, #</code>, <code>=</code>をサポートします。
</p>
<p>Fourier消去コードは
絶対値や最小、最大関数を含むいくつかの非線形 inequationを
線形 inequationに変換するプリプロセッサを持ちます．
加えて、プリプロセッサは線形項の積か商であるいくつかの式を扱います:
</p>
<pre class="example">(%i10) fourier_elim([max(x,y) &gt; 6, x # 8, abs(y-1) &gt; 12],[x,y]);
(%o10) [6 &lt; x, x &lt; 8, y &lt; - 11] or [8 &lt; x, y &lt; - 11]
 or [x &lt; 8, 13 &lt; y] or [x = y, 13 &lt; y] or [8 &lt; x, x &lt; y, 13 &lt; y]
 or [y &lt; x, 13 &lt; y]
(%i11) fourier_elim([(x+6)/(x-9) &lt;= 6],[x]);
(%o11)           [x = 12] or [12 &lt; x] or [x &lt; 9]
(%i12) fourier_elim([x^2 - 1 # 0],[x]);
(%o12)      [- 1 &lt; x, x &lt; 1] or [1 &lt; x] or [x &lt; - 1]
</pre>
<p><b>利用するには</b> <tt>`load(fourier_elim)'</tt>
</p>
</dd></dl>

<p><a name="Item_003a-isreal_005fp"></a>
</p><dl>
<dt><u>関数:</u> <b>isreal_p</b><i> (<var>e</var>)</i>
<a name="IDX2472"></a>
</dt>
<dd><p>述語論理 <code>isreal_p</code>は、
Maximaが <code>e</code>が実数線<i>全体</i>上で実数値であることを
決められる時 trueを返します;
Maximaが実数線の空でないある部分集合上で
<code>e</code>が実数値で<i>ない</i>ことを決められる時 falseを返します;
他の場合、名詞形を返します。
</p>
<pre class="example">(%i1) map('isreal_p, [-1, 0, %i, %pi]);
(%o1)               [true, true, false, true]
</pre>
<p>Maxima変数は実と仮定されます; たとえば
</p>
<pre class="example">(%i2) isreal_p(x);
(%o2)                         true
</pre>
<p>関数 <code>isreal_p</code>は事実データベースを検査します:
</p>
<pre class="example">(%i3) declare(z,complex)$

(%i4) isreal_p(z);
(%o4)                      isreal_p(z)
</pre>
<p><b>制限</b>
頻繁すぎるほど <code>isreal_p</code>は
falseを返すことができる時に名詞形を返します;
対数函数は実数線全体で実数値ではありません。
だから <code>isreal_p(log(x))</code>は falseを返すべきです;
しかしながら
</p>
<pre class="example">(%i5) isreal_p(log(x));
(%o5)                   isreal_p(log(x))
</pre>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>関連関数</b> <i>complex_number_p</i>
</p>
<p><b>状況</b> 関数 <code>isreal_p</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p></dd></dl>


<p><a name="Item_003a-new_005fvariable"></a>
</p><dl>
<dt><u>関数:</u> <b>new_variable</b><i> (type)</i>
<a name="IDX2473"></a>
</dt>
<dd><p><code>%[z,n,r,c,g]k</code>という形のユニークなシンボルを返します。
ここで <code>k</code>は整数です
<em>type</em>に許される値は
<i>integer, natural_number, real, natural_number,</i> <i>general</i>です。
(自然数(natural number)は <i>非負整数</i>を意味します;
なので零は自然数です
自然数の定義のすべてではありませんがいくつかは零を<i>除外します</i>。)
</p>
<p><em>type</em>が許される値の１つでない時、
<em>type</em>は <em>general</em>にデフォルト設定されます。
整数、自然数、複素数に対して、
Maximaは自動的にこの情報を事実データベースに追加します。
</p>
<pre class="example">(%i1) map('new_variable,
          ['integer, 'natural_number, 'real, 'complex, 'general]);
(%o1)          [%z144, %n145, %r146, %c147, %g148]
(%i2) nicedummies(%);
(%o2)               [%z0, %n0, %r0, %c0, %g0]
(%i3) featurep(%z0, 'integer);
(%o3)                         true
(%i4) featurep(%n0, 'integer);
(%o4)                         true
(%i5) is(%n0 &gt;= 0);
(%o5)                         true
(%i6) featurep(%c0, 'complex);
(%o6)                         true
</pre>
<p><b>注釈</b> 一般に、<code>new_variable</code>の引数はクォートすべきです。
クォートは以下に似たエラーを防ぎます。
</p>
<pre class="example">(%i7) integer : 12$

(%i8) new_variable(integer);
(%o8)                         %g149
(%i9) new_variable('integer);
(%o9)                         %z150
</pre>
<p><b>関連関数</b> <i>nicedummies</i>
</p>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況</b> 関数 <code>new_variable</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-nicedummies"></a>
</p><dl>
<dt><u>関数:</u> <b>nicedummies</b>
<a name="IDX2474"></a>
</dt>
<dd><p>関数 <code>nicedummies</code>は
<code>new_variable</code>が導入した式の中の変数を零から再インデックスします;
</p>
<pre class="example">(%i1) new_variable('integer) + 52 * new_variable('integer);
(%o1)                   52 %z136 + %z135
(%i2) new_variable('integer) - new_variable('integer);
(%o2)                     %z137 - %z138
(%i3) nicedummies(%);
(%o3)                       %z0 - %z1
</pre>
<p><b>関連関数</b> <i>new_variable</i>
</p>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況</b> 関数 <code>nicedummies</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-parg"></a>
</p><dl>
<dt><u>関数:</u> <b>parg</b><i> (<var>x</var>)</i>
<a name="IDX2475"></a>
</dt>
<dd><p>関数 <code>parg</code>は複素偏角関数 <code>carg</code>の整理化バージョンです;
例えば
</p>
<pre class="example">(%i1) map('parg,[1,1+%i,%i, -1 + %i, -1]);
                        %pi  %pi  3 %pi
(%o1)               [0, ---, ---, -----, %pi]
                         4    2     4
</pre>
<p>一般に非定数入力に対して <code>parg</code>は名詞形を返します;例えば
</p>
<pre class="example">(%i2) parg(x + %i * sqrt(x));
(%o2)                 parg(x + %i sqrt(x))
</pre>
<p><code>sign</code>を使って入力が正の実数か負の実数か決めることができる時
<code>parg</code>は非定数入力に対して非名詞形を返します。
以下は2つの例です:
</p>

<pre class="example">(%i3) parg(abs(x));
(%o3) 0
(%i4) parg(-x^2-1);
(%o4)                          %pi
</pre>
<p><b>注釈</b> <code>sign</code>関数は
複素数と宣言された変数 (<code>declare(x,complex)</code>)を
ほとんど無視します;
複素数と宣言された変数に対して、
<code>parg</code>は間違った値を返す可能性があります;
例えば
</p>

<pre class="example">(%i1) declare(x,complex)$

(%i2) parg(x^2 + 1);
(%o2) 0
</pre>
<p><b>Related function</b> <i>carg, isreal_p</i>
</p>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況</b> 関数 <code>parg</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-real_005fimagpart_005fto_005fconjugate"></a>
</p><dl>
<dt><u>関数:</u> <b>real_imagpart_to_conjugate</b><i> (<var>e</var>)</i>
<a name="IDX2476"></a>
</dt>
<dd><p>関数 <code>real_imagpart_to_conjugate</code>は
<code>realpart</code>と <code>imagpart</code>をすべて
<code>conjugate</code>を含む代数的に同値な式に置き換えます。
</p>
<pre class="example">(%i1) declare(x, complex)$

(%i2) real_imagpart_to_conjugate(realpart(x) +  imagpart(x) = 3);
          conjugate(x) + x   %i (x - conjugate(x))
(%o2)     ---------------- - --------------------- = 3
                 2                     2
</pre>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況</b> 関数 <code>real_imagpart_to_conjugate</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-rectform_005flog_005fif_005fconstant"></a>
</p><dl>
<dt><u>関数:</u> <b>rectform_log_if_constant</b><i> (<var>e</var>)</i>
<a name="IDX2477"></a>
</dt>
<dd><p>関数 <code>rectform_log_if_constant</code>は
<code> log(c)</code>の形の項をすべて
<code>rectform(log(c))</code>に変換します。
ここで <code>c</code>は宣言された定数式か明示的に宣言された定数です。
</p>
<pre class="example">(%i1) rectform_log_if_constant(log(1-%i) - log(x - %i));
                                 log(2)   %i %pi
(%o1)            - log(x - %i) + ------ - ------
                                   2        4
(%i2) declare(a,constant, b,constant)$

(%i3) rectform_log_if_constant(log(a + %i*b));
                       2    2
                  log(b  + a )
(%o3)             ------------ + %i atan2(b, a)
                       2
</pre>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況</b> 関数 <code>rectform_log_if_constant</code>は実験的です;
仕様は変更の可能性があり、
機能は他のMaxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-simp_005finequality"></a>
</p><dl>
<dt><u>関数:</u> <b>simp_inequality</b><i> (<var>e</var>)</i>
<a name="IDX2478"></a>
</dt>
<dd><p>関数 <code>simp_inequality</code>は
inequationの論理積と論理和にいくつかの整理を適用します。
</p>
<p><b>制限</b> 関数 <code>simp_inequality</code>は少なくとも2つの点で制限されます;
第一に整理が局所的です; 例えば
</p>

<pre class="example">(%i1) simp_inequality((x &gt; minf) %and (x &lt; 0));
(%o1) (x&gt;1) %and (x&lt;1)
</pre>
<p>第二に <code>simp_inequality</code>は事実データベースを参照しません:
</p>
<pre class="example">(%i2) assume(x &gt; 0)$

(%i3) simp_inequality(x &gt; 0);
(%o3)                         x &gt; 0
</pre>
<p><b>利用するには</b> <tt>`load(fourier_elim)'</tt>
</p>
<p><b>状況</b> 関数 <code>simp_inequality</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-standardize_005finverse_005ftrig"></a>
</p><dl>
<dt><u>関数:</u> <b>standardize_inverse_trig</b><i> (<var>e</var>)</i>
<a name="IDX2479"></a>
</dt>
<dd><p>この関数は
恒等式 <code>cot(x) = atan(1/x), acsc(x) = asin(1/x),</code>と
<code>asec, acoth, acsch</code> <code>asech</code>に関する類似の恒等式を式に適応します。
Abramowitz and Stegun, Eqs. 4.4.6 から 4.4.8までと
4.6.4から 4.6.6までを参照してください。
</p>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況</b> 関数 <code>standardize_inverse_trig</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p></dd></dl>

<p><a name="Item_003a-subst_005fparallel"></a>
</p><dl>
<dt><u>関数:</u> <b>subst_parallel</b><i> (<var>l</var>, <var>e</var>)</i>
<a name="IDX2480"></a>
</dt>
<dd><p><code>l</code>が単一の等式か等式のリストの時、それぞれの等式の右辺側を左辺に代入します。
代入は並列に行われます; 例えば
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) subst_parallel([x=y,y=x], [x,y]);
(%o2)                        [y, x]
</pre>
<p>これを順にされる代入と比較します:
</p>
<pre class="example">(%i3) subst([x=y,y=x],[x,y]);
(%o3)                        [x, x]
</pre>
<p>関数 <code>subst_parallel</code>は、
<code>subst_parallel</code>は非アトムの代入を許すことを除いて
<code>sublis</code>と似ています;
例えば
</p>
<pre class="example">(%i4) subst_parallel([x^2 = a, y = b], x^2 * y);
(%o4)                          a b
(%i5) sublis([x^2 = a, y = b], x^2 * y);

                                                             2
sublis: left-hand side of equation must be a symbol; found: x
 -- an error. To debug this try: debugmode(true);
</pre>
<p><code>subst_parallel</code>が行う代入は文字通りであり意味論的ではありません;
なので
<code>subst_parallel</code>は
<em>x * y</em>が <em>x^2 * y</em>の部分式であることを認識<i>しません</i>
</p>
<pre class="example">(%i6) subst_parallel([x * y = a], x^2 * y);
                               2
(%o6)                         x  y
</pre>
<p>関数 <code>subst_parallel</code>は整理の<i>前に</i>すべての代入を完了します。
これは、もし整理が前に行われていたらエラーが起こるような条件式への代入を許します:
</p>
<pre class="example">(%i7) subst_parallel([x = 0], %if(x &lt; 1, 5, log(x)));
(%o7)                           5
(%i8) subst([x = 0], %if(x &lt; 1, 5, log(x)));

log: encountered log(0).
 -- an error. To debug this try: debugmode(true);
</pre>
<p><b>関連関数</b> <i>subst, sublis, ratsubst</i>
</p>
<p><b>利用するには</b> <tt>`load(to_poly_solve_extra.lisp)'</tt>
</p>
<p><b>状況</b> 関数 <code>subst_parallel</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>

<p><a name="Item_003a-to_005fpoly"></a>
</p><dl>
<dt><u>関数:</u> <b>to_poly</b><i> (<var>e</var>, <var>l</var>)</i>
<a name="IDX2481"></a>
</dt>
<dd><p>関数 <code>to_poly</code>は等式 <code>e</code>を
inequation制約を伴う多項式系に変換しようとします;
制約を満たす多項式系の解は等式 <code>e</code>の解です。
非公式には <code>to_poly</code>は等式 <var>e</var>を多項式化しようとします; 
例がわかりやすいかもしれません:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) to_poly(sqrt(x) = 3, [x]);
                            2
(%o2) [[%g130 - 3, x = %g130 ], 
                      %pi                               %pi
                   [- --- &lt; parg(%g130), parg(%g130) &lt;= ---], []]
                       2                                 2
</pre>
<p>条件 <code>-%pi/2&lt;parg(%g130),parg(%g130)&lt;=%pi/2</code>は
<code>%g130</code>が平方根関数の範囲内であることを告げます。
これが trueの時、
<code>sqrt(x) = 3</code>に設定された解は
<code>%g130-3,x=%g130^2</code>に設定された解と同じです。
</p>
<p>三角式を多項式化するには、非代数的代入の導入が必要です;
これらの非代数的代入は
<code>to_poly</code>が返す三番目のリスト内で返されます;
例えば
</p>
<pre class="example">(%i3) to_poly(cos(x),[x]);
                2                                 %i x
(%o3)    [[%g131  + 1], [2 %g131 # 0], [%g131 = %e    ]]
</pre>
<p>数字 1が変数リストのメンバーでない限り定数項は多項式化されません;
例えば
</p>
<pre class="example">(%i4) to_poly(x = sqrt(5),[x]);
(%o4)                [[x - sqrt(5)], [], []]
(%i5) to_poly(x = sqrt(5),[1,x]);
                            2
(%o5) [[x - %g132, 5 = %g132 ], 
                      %pi                               %pi
                   [- --- &lt; parg(%g132), parg(%g132) &lt;= ---], []]
                       2                                 2
</pre>
<p>根の 1つとして
<em>sqrt(5) + sqrt(7)</em>を持つ多項式を生成するには、以下のコマンドを使います。
</p>
<pre class="example">(%i6) first(elim_allbut(first(to_poly(x = sqrt(5) + sqrt(7),
                                      [1,x])), [x]));
                          4       2
(%o6)                   [x  - 24 x  + 4]
</pre>
<p><b>関連関数</b> <i>to_poly_solve</i>
</p>
<p><b>利用するには</b> <tt>`load(to_poly)'</tt>
</p>
<p><b>状況:</b> 関数 <code>to_poly</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p>
</dd></dl>


<dl>
<dt><u>関数:</u> <b>to_poly_solve</b><i> (<var>e</var>, <var>l</var>, [options])</i>
<a name="IDX2482"></a>
</dt>
<dd><p>関数 <code>to_poly_solve</code>は等式 <em>e</em>を変数 <em>l</em>について解こうとします。
等式 <em>e</em>は単一の式か式の集合もしくはリストでありえます;
同様に <em>l</em>は単一のシンボルかシンボルの集合のリストでありえます;
<em>e</em>のメンバーが明示的に等式でない時(例えば <em>x^2 -1</em>)、
ソルバは式は 0に等しいと仮定します。
</p>
<p><code>to_poly_solve</code>の基本戦略は
入力を多項式形に変換し、 多項式系上で<code>algsys</code>を呼ぶことです。
内部的には、 <code>to_poly_solve</code>は <code>algexact</code>を trueに設定します。
<code>algexact</code>のデフォルト置を変えるには、 'algexact=falseを  <code>to_poly_solve</code>の引数リストに追加してください。
</p>
<p><code>to_poly_solve</code>が解集合を決定できる時、解集合のそれぞれのメンバーは
<code>%union</code>オブジェクト内のリストです:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) to_poly_solve(x*(x-1) = 0, x);
(%o2)               %union([x = 0], [x = 1])
</pre>
<p><code>to_poly_solve</code>が解集合を決定<i>できない</i>時
<code>%solve</code>名詞形が返されます。(この場合、警告が印字されます。)
</p>
<pre class="example">(%i3) to_poly_solve(x^k + 2* x + 1 = 0, x);

Nonalgebraic argument given to 'to_poly'
unable to solve
                          k
(%o3)            %solve([x  + 2 x + 1 = 0], [x])
</pre>
<p><code>%solve</code>名詞形への代入は時々解に帰着します。
</p>
<pre class="example">(%i4) subst(k = 2, %);
(%o4)                   %union([x = - 1])
</pre>
<p>特に三角等式の場合、ソルバは時々任意整数の導入を必要とします。
これらの任意整数は
<code>%zXXX</code>という形を持ちます。
ここで <code>XXX</code>は整数です;
例えば
</p>
<pre class="example">(%i5) to_poly_solve(sin(x) = 0, x);
(%o5)   %union([x = 2 %pi %z33 + %pi], [x = 2 %pi %z35])
</pre>
<p>これらの変数を零から再インデックスするには <code>nicedummies</code>を使います:
</p>
<pre class="example">(%i6) nicedummies(%);
(%o6)    %union([x = 2 %pi %z0 + %pi], [x = 2 %pi %z1])
</pre>
<p>時折、ソルバは
<code>%cXXX</code>という形の任意複素数か
<code>%rXXX</code>という形の任意実数を導入します。
関数 <code>nicedummies</code>はこれらの識別子を零から再インデックスします。
</p>
<p>解集合は時々
論理積、論理和、含意に関してそれぞれ <code>%and</code>か, <code>%or</code>,
<code>%if</code>を含む様々な論理演算子の整理化バージョンを含みます;
例えば
</p>
<pre class="example">(%i7) sol : to_poly_solve(abs(x) = a, x);
(%o7) %union(%if(isnonnegative_p(a), [x = - a], %union()), 
                      %if(isnonnegative_p(a), [x = a], %union()))
(%i8) subst(a = 42, sol);
(%o8)             %union([x = - 42], [x = 42])
(%i9) subst(a = -42, sol);
(%o9)                       %union()
</pre>
<p>空集合は <code>%union</code>によって表現されます。
</p>
<p>関数 <code>to_poly_solve</code>は有理数や非有理べき、絶対値、三角関数、最小最大を含む等式の
(すべてではありませんが)いくつかを解くことができます。
Lambert W 函数を使って解くことができるいくつかの等式も解くことができます;
例:
</p>
<pre class="example">(%i1) load(to_poly_solve)$

(%i2) to_poly_solve(set(max(x,y) = 5, x+y = 2), set(x,y));
(%o2)      %union([x = - 3, y = 5], [x = 5, y = - 3])
(%i3) to_poly_solve(abs(1-abs(1-x)) = 10,x);
(%o3)             %union([x = - 10], [x = 12])
(%i4) to_poly_solve(set(sqrt(x) + sqrt(y) = 5, x + y = 10),
                    set(x,y));
                     3/2               3/2
                    5    %i - 10      5    %i + 10
(%o4) %union([x = - ------------, y = ------------], 
                         2                 2
                                3/2                 3/2
                               5    %i + 10        5    %i - 10
                          [x = ------------, y = - ------------])
                                    2                   2
(%i5) to_poly_solve(cos(x) * sin(x) = 1/2,x,
                    'simpfuncs = ['expand, 'nicedummies]);
                                         %pi
(%o5)              %union([x = %pi %z0 + ---])
                                          4
(%i6) to_poly_solve(x^(2*a) + x^a + 1,x);
                                        2 %i %pi %z81
                                        -------------
                                  1/a         a
                  (sqrt(3) %i - 1)    %e
(%o6) %union([x = -----------------------------------], 
                                  1/a
                                 2
                                                  2 %i %pi %z83
                                                  -------------
                                            1/a         a
                          (- sqrt(3) %i - 1)    %e
                     [x = -------------------------------------])
                                           1/a
                                          2
(%i7) to_poly_solve(x * exp(x) = a, x);
(%o7)              %union([x = lambert_w(a)])
</pre>
<p><i>線形</i>不等式に対して、 <code>to_poly_solve</code>は自動的に Fourier消去を行います:
</p>
<pre class="example">(%i8) to_poly_solve([x + y &lt; 1, x - y &gt;= 8], [x,y]);
                               7
(%o8) %union([x = y + 8, y &lt; - -], 
                               2
                                                              7
                                 [y + 8 &lt; x, x &lt; 1 - y, y &lt; - -])
                                                              2
</pre>
<p><code>to_poly_solve</code>のオプション引数のそれぞれは等式でなければいけません;
一般にこれらのオプションの順序は問題になりません．
</p>
<ul>
<li>
<code>simpfuncs = l</code>, 
ここで <code>l</code>は函数のリストです。
lのメンバーの合成をそれぞれの解に適用します。

<pre class="example">(%i1) to_poly_solve(x^2=%i,x);
                               1/4             1/4
(%o1)       %union([x = - (- 1)   ], [x = (- 1)   ])
(%i2) to_poly_solve(x^2= %i,x, 'simpfuncs = ['rectform]);
                      %i         1             %i         1
(%o2) %union([x = - ------- - -------], [x = ------- + -------])
                    sqrt(2)   sqrt(2)        sqrt(2)   sqrt(2)
</pre>
<p>時々追加の整理は整理を戻すことがあります;
例えば
</p>
<pre class="example">(%i3) to_poly_solve(x^2=1,x);
(%o3)              %union([x = - 1], [x = 1])
(%i4) to_poly_solve(x^2= 1,x, 'simpfuncs = [polarform]);
                                        %i %pi
(%o4)            %union([x = 1], [x = %e      ]
</pre>
<p>Maximaは
関数リスト <code>l</code>のそれぞれのメンバーが純粋に整理であるかチェックしようとしません;
例えば
</p>
<pre class="example">(%i5) to_poly_solve(x^2 = %i,x, 'simpfuncs = [lambda([s],s^2)]);
(%o5)                   %union([x = %i])
</pre>
<p>それぞれの解を倍精度浮動小数点数に変換するには
<code>simpfunc = ['dfloat]</code>を使います:
</p>
<pre class="example">(%i6) to_poly_solve(x^3 +x + 1 = 0,x, 
                    'simpfuncs = ['dfloat]), algexact : true;
(%o6) %union([x = - .6823278038280178], 
[x = .3411639019140089 - 1.161541399997251 %i], 
[x = 1.161541399997251 %i + .3411639019140089])
</pre>
</li><li>
<code>use_grobner = true</code>
このオプションを使うと
解を企てる前に関数 <code>poly_reduced_grobner</code>が等式に適用されます
主として、このオプションは関数 <code>algsys</code>の弱みに対する応急措置を提供します。
以下はそんな応急措置の例です:

<pre class="example">(%i7) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y],
                    'use_grobner = true);
                    sqrt(7) - 1      sqrt(7) + 1
(%o7) %union([x = - -----------, y = -----------], 
                         2                2
                                 sqrt(7) + 1        sqrt(7) - 1
                            [x = -----------, y = - -----------])
                                      2                  2
(%i8) to_poly_solve([x^2+y^2=2^2,(x-1)^2+(y-1)^2=2^2],[x,y]);
(%o8)                       %union()
</pre>
</li><li>
<code>maxdepth = k</code>,
ここで <code>k</code>は正の整数です。
この関数はソルバの最大再帰深さを制御します。
<code>maxdepth</code>のデフォルト値は 5です。
再帰深さを越えた時、ソルバはエラーをシグナルします:

<pre class="example">(%i9) to_poly_solve(cos(x) = x,x, 'maxdepth = 2);

Unable to solve
Unable to solve
(%o9)        %solve([cos(x) = x], [x], maxdepth = 2)
</pre>
</li><li>
<code>parameters = l</code>,
ここで <code>l</code>はシンボルのリストです。
ソルバはリスト <code>l</code>のメンバーすべてに有効な解を返そうとします;
例えば:

<pre class="example">(%i10) to_poly_solve(a * x = x, x);
(%o10)                   %union([x = 0])
(%i11) to_poly_solve(a * x = x, x, 'parameters = [a]);
(%o11) %union(%if(a - 1 = 0, [x = %c111], %union()), 
                               %if(a - 1 # 0, [x = 0], %union()))
</pre>
<p><code>(%o2)</code>で、ソルバはダミー変数を導入しました;
これらのダミー変数を再インデックスするには、関数 <code>nicedummies</code>を使います:
</p>
<pre class="example">(%i12) nicedummies(%);
(%o12) %union(%if(a - 1 = 0, [x = %c0], %union()), 
                               %if(a - 1 # 0, [x = 0], %union()))
</pre></li></ul>

<p><em>f(a) = f(b)</em>という形の等式を解くために
<code>to_poly_solve</code>はハッシュ配列
<code>one_to_one_reduce</code>に記憶されたデータを使います。
割り当て <code>one_to_one_reduce['f,'f] : lambda([a,b], a=b)</code>は
<code>to_poly_solve</code>に
<em>f(a) = f(b)</em>の解集合が<em>a=b</em>の解集合に等しいことを告げます;
例えば
</p>
<pre class="example">(%i13) one_to_one_reduce['f,'f] : lambda([a,b], a=b)$

(%i14) to_poly_solve(f(x^2-1) = f(0),x);
(%o14)             %union([x = - 1], [x = 1])
</pre>
<p>さらに一般的に、割り当て
<code>one_to_one_reduce['f,'g] : lambda([a,b], w(a, b) = 0</code>は
<code>to_poly_solve</code>に
<em>f(a) = f(b)</em>の解集合が <em>w(a,b) = 0</em>の解集合に等しいことを告げます;
例えば
</p>
<pre class="example">(%i15) one_to_one_reduce['f,'g] : lambda([a,b], a = 1 + b/2)$

(%i16) to_poly_solve(f(x) - g(x),x);
(%o16)                   %union([x = 2])
</pre>
<p>加えて、<em>f(a) = b</em>という形の等式を解くために関数
<code>to_poly_solve</code>はハッシュ配列
<code>function_inverse</code>に記憶されたデータを使います。
割り当て <code>function_inverse['f] : lambda([s], g(s))</code>は
<code>to_poly_solve</code>に
<code>f(x) = b</code>に設定された解が
<code>x = g(b)</code>に設定された解に等しいことを知らせます;
2つの例:
</p>
<pre class="example">(%i17) function_inverse['Q] : lambda([s], P(s))$

(%i18) to_poly_solve(Q(x-1) = 2009,x);
(%o18)              %union([x = P(2009) + 1])
(%i19) function_inverse['G] : lambda([s], s+new_variable(integer));
(%o19)       lambda([s], s + new_variable(integer))
(%i20) to_poly_solve(G(x - a) = b,x);
(%o20)             %union([x = b + a + %z125])
</pre>

<p><b>注釈</b>
</p>
<ul class="toc">
<li>
解く変数はシンボルである必要はありません;
<code>fullratsubst</code>が適切に代入できる時、
解く変数は非シンボルであり得ます:
</li></ul>

<pre class="example">(%i1) to_poly_solve([x^2 + y^2 + x * y = 5, x * y = 8],
                    [x^2 + y^2, x * y]);
                                  2    2
(%o1)           %union([x y = 8, y  + x  = - 3])
</pre>
<ul class="toc">
<li>
複素共役を含む等式に対して、ソルバは自動的に共役等式を追加します;
例えば
</li></ul>

<pre class="example">(%i1) declare(x,complex)$

(%i2) to_poly_solve(x + (5 + %i) * conjugate(x) = 1, x);
                                   %i + 21
(%o2)              %union([x = - -----------])
                                 25 %i - 125
(%i3) declare(y,complex)$

(%i4) to_poly_solve(set(conjugate(x) - y = 42 + %i,
                        x + conjugate(y) = 0), set(x,y));
                           %i - 42        %i + 42
(%o4)        %union([x = - -------, y = - -------])
                              2              2
</pre>
<ul class="toc">
<li>
絶対値関数を含む等式に対して、
<code>to_poly_solve</code>は
絶対値の引数が複素数値か決めるため事実データベースに問い合わせます。

<pre class="example">(%i1) to_poly_solve(abs(x) = 6, x);
(%o1)              %union([x = - 6], [x = 6])
(%i2) declare(z,complex)$

(%i3) to_poly_solve(abs(z) = 6, z);
(%o3) %union(%if((%c11 # 0) %and (%c11 conjugate(%c11) - 36 = 
                                       0), [z = %c11], %union()))
</pre>
<p><i>これはソルバが事実データベースを参照する唯一の状況です。
例えば、もし解く変数が整数と宣言されていたら、
<code>to_poly_solve</code>はこの宣言を無視します</i>。
</p></li></ul>

<p><b>Relevant option variables</b> <i>algexact, resultant, algebraic</i>
</p>
<p><b>関連関数</b> <i>to_poly</i>
</p>
<p><b>利用するには</b> <tt>`load(to_poly_solve)'</tt>
</p>
<p><b>状況:</b> 関数 <code>to_poly_solve</code>は実験的です;
仕様は変更の可能性があり、
機能は他の Maxima関数にマージされるかもしれません。
</p></dd></dl>

<p><a name="Item_003a-unit"></a>
</p><hr size="6">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="#SEC379" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="maxima_81.html#SEC381" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="maxima.html#SEC_Top" title="Cover (top) of document">冒頭</a>]</td>
<td valign="middle" align="left">[<a href="maxima_toc.html#SEC_Contents" title="Table of contents">目次</a>]</td>
<td valign="middle" align="left">[<a href="maxima_84.html#SEC395" title="Index">見出し</a>]</td>
<td valign="middle" align="left">[<a href="maxima_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  この文書は<em>市川 雄二</em>によって<em>5月, 20 2015</em>に<a href="http://texi2html.cvshome.org/"><em>texi2html 1.76</em></a>を用いて生成されました。
 </font>
 <br>

</p>
</body>
</html>
